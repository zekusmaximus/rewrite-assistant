[{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\eslint.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\__tests__\\SettingsService.security.test.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":47,"column":11,"nodeType":"BlockStatement","messageId":"unexpected","endLine":47,"endColumn":13,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1229,1229],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":79,"column":69,"nodeType":"BlockStatement","messageId":"unexpected","endLine":79,"endColumn":71,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2447,2447],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport * as os from 'os';\r\n\r\nlet userDataDir: string;\r\n\r\nvi.mock('electron', () => {\r\n  const api = {\r\n    app: {\r\n      getPath: (name: string) => {\r\n        if (name === 'userData') {\r\n          return userDataDir;\r\n        }\r\n        return '';\r\n      }\r\n    },\r\n    safeStorage: {\r\n      isEncryptionAvailable: () => true,\r\n      encryptString: (s: string) => Buffer.from('enc:' + s, 'utf8'),\r\n      decryptString: (b: Buffer) => Buffer.from(b).toString('utf8').replace(/^enc:/, '')\r\n    }\r\n  };\r\n  return api;\r\n});\r\n\r\nconst importService = async () => {\r\n  vi.resetModules();\r\n  const mod = await import('../../main/services/SettingsService');\r\n  return mod.default as any;\r\n};\r\n\r\nconst settingsFilePath = () => path.join(userDataDir, 'settings.json');\r\n\r\nconst makeTempUserData = async () => {\r\n  const prefix = path.join(os.tmpdir(), 'ra-userdata-');\r\n  return await fs.mkdtemp(prefix);\r\n};\r\n\r\nbeforeEach(async () => {\r\n  userDataDir = await makeTempUserData();\r\n});\r\n\r\nafterEach(async () => {\r\n  try {\r\n    await fs.rm(userDataDir, { recursive: true, force: true });\r\n  } catch {}\r\n});\r\n\r\ndescribe('SettingsService security and persistence', () => {\r\n  it('saves settings with encrypted apiKey and loads back decrypted', async () => {\r\n    const service = await importService();\r\n    const PLAINTEXT = 'test-openai-key';\r\n\r\n    const saveRes = await service.saveSettings({\r\n      providers: {\r\n        openai: { enabled: true, apiKey: PLAINTEXT, model: 'gpt-4-turbo-preview' }\r\n      }\r\n    });\r\n    expect(saveRes.success).toBe(true);\r\n\r\n    const raw = await fs.readFile(settingsFilePath(), 'utf8');\r\n    const parsed = JSON.parse(raw);\r\n    const stored = parsed?.providers?.openai?.apiKey;\r\n\r\n    expect(typeof stored).toBe('string');\r\n    // base64-like check and not equal to plaintext\r\n    expect(/^[A-Za-z0-9+/=]+$/.test(stored)).toBe(true);\r\n    expect(stored === PLAINTEXT).toBe(false);\r\n\r\n    const loaded = await service.loadSettings();\r\n    // Avoid printing secrets on assertion failure\r\n    expect(loaded?.providers?.openai?.apiKey === PLAINTEXT).toBe(true);\r\n  });\r\n\r\n  it('returns defaults when settings.json is missing', async () => {\r\n    const service = await importService();\r\n    // ensure file is absent\r\n    try { await fs.rm(settingsFilePath(), { force: true }); } catch {}\r\n\r\n    const loaded = await service.loadSettings();\r\n\r\n    expect(loaded?.general?.theme).toBe('light');\r\n    expect(loaded?.providers?.openai?.apiKey === '').toBe(true);\r\n  });\r\n\r\n  it('returns defaults on corrupted settings.json', async () => {\r\n    const service = await importService();\r\n\r\n    await fs.mkdir(userDataDir, { recursive: true });\r\n    await fs.writeFile(settingsFilePath(), 'not json', 'utf8');\r\n\r\n    const loaded = await service.loadSettings();\r\n\r\n    expect(loaded?.general?.theme).toBe('light');\r\n    expect(loaded?.providers?.openai?.apiKey === '').toBe(true);\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\__tests__\\rewriteHandlers.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":7,"column":36,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":7,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":46,"column":43,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":46,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":105,"column":37,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":105,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":120,"column":31,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":120,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":131,"column":31,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":131,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":153,"column":33,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":153,"endColumn":41}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeAll, beforeEach } from 'vitest';\r\nimport { IPC_CHANNELS } from '../../shared/constants';\r\n\r\n// Hoisted state so it's initialized before hoisted mocks execute\r\nconst hoisted = vi.hoisted(() => {\r\n  return {\r\n    registry: {} as Record<string, Function>,\r\n    mockSend: vi.fn(),\r\n    windows: [] as any[],\r\n  };\r\n});\r\n\r\n// Mock electron to provide minimal app/ipcMain/BrowserWindow used by main code\r\nvi.mock('electron', () => {\r\n  const { registry, mockSend, windows } = hoisted;\r\n\r\n  class MockBrowserWindow {\r\n    static getAllWindows = vi.fn(() => windows);\r\n    public webContents: any;\r\n    constructor(..._args: any[]) {\r\n      this.webContents = {\r\n        send: mockSend,\r\n        on: vi.fn(),\r\n        openDevTools: vi.fn(),\r\n      };\r\n      (this as any).once = vi.fn();\r\n      (this as any).on = vi.fn();\r\n      (this as any).show = vi.fn();\r\n      (this as any).hide = vi.fn();\r\n      (this as any).setMenuBarVisibility = vi.fn();\r\n      (this as any).loadURL = vi.fn();\r\n      (this as any).loadFile = vi.fn();\r\n      (this as any).isDestroyed = vi.fn(() => false);\r\n      windows.push(this);\r\n    }\r\n  }\r\n\r\n  return {\r\n    app: {\r\n      whenReady: () => Promise.resolve(),\r\n      on: vi.fn(),\r\n      off: vi.fn(),\r\n      quit: vi.fn(),\r\n    },\r\n    ipcMain: {\r\n      handle: vi.fn((channel: string, fn: Function) => {\r\n        registry[channel] = fn;\r\n      }),\r\n      on: vi.fn(),\r\n      removeHandler: vi.fn(),\r\n      removeAllListeners: vi.fn(),\r\n    },\r\n    BrowserWindow: MockBrowserWindow as any,\r\n    dialog: {\r\n      showOpenDialog: vi.fn(async () => ({ canceled: true, filePaths: [] })),\r\n      showSaveDialog: vi.fn(async () => ({ canceled: true, filePath: undefined })),\r\n    },\r\n  };\r\n});\r\n\r\n// Ensure electron-squirrel-startup import is inert\r\nvi.mock('electron-squirrel-startup', () => ({}));\r\n\r\n// Break circular import: mock the app entry to avoid executing real index.ts during handlers import\r\nvi.mock('../../main/index', () => {\r\n  // Provide a stub mainWindow export referenced by handlers\r\n  return { mainWindow: undefined };\r\n});\r\n\r\n// Mock SceneRewriter used by the GENERATE_REWRITE handler\r\nvi.mock('../../services/rewrite/SceneRewriter', () => {\r\n  return {\r\n    default: vi.fn().mockImplementation(() => {\r\n      return {\r\n        rewriteScene: vi.fn().mockResolvedValue({\r\n          success: true,\r\n          rewrittenText: 'rewritten text',\r\n          issuesAddressed: [],\r\n          changesExplanation: 'mocked explanation',\r\n          preservedElements: [],\r\n          diffData: [],\r\n          modelUsed: 'mock-model',\r\n        }),\r\n      };\r\n    }),\r\n  };\r\n});\r\n\r\n// Import handlers after mocks and invoke registration directly.\r\n// Also ensure at least one BrowserWindow exists so progress events can be emitted.\r\nbeforeAll(async () => {\r\n  const { setupIPCHandlers } = await import('../../main/handlers');\r\n  setupIPCHandlers();\r\n\r\n  const { BrowserWindow } = await import('electron');\r\n  // Create one window instance in the mocked electron so handlers can find it\r\n   \r\n  new (BrowserWindow as any)();\r\n});\r\n\r\ndescribe('IPC rewrite handler', () => {\r\n  const handlers = hoisted.registry;\r\n  const mockSend = hoisted.mockSend;\r\n\r\n  const resolveRewriteHandler = (): Function | undefined => {\r\n    const preferred = handlers[IPC_CHANNELS.GENERATE_REWRITE];\r\n    if (typeof preferred === 'function') return preferred;\r\n    const all = Object.keys(handlers);\r\n    return all.length ? handlers[all[0]] : undefined;\r\n  };\r\n\r\n  beforeEach(() => {\r\n    mockSend.mockClear();\r\n  });\r\n\r\n  it('validates payload and returns error when missing scene or issues', async () => {\r\n    const fn = resolveRewriteHandler();\r\n    expect(fn, `Available channels: ${Object.keys(handlers).join(', ')}`).toBeTypeOf('function');\r\n\r\n    const res1 = await (fn as Function)({}, { scene: null, issues: [] });\r\n    // Expect standardized error shape from toErrorResponse()\r\n    expect(res1).toEqual(\r\n      expect.objectContaining({\r\n        ok: false,\r\n        error: expect.objectContaining({\r\n          message: expect.stringContaining('Invalid'),\r\n        }),\r\n      })\r\n    );\r\n\r\n    const res2 = await (fn as Function)({}, { scene: { id: 's1', text: 'x' }, issues: [] });\r\n    expect(res2.ok).toBe(false);\r\n  });\r\n\r\n  it('invokes SceneRewriter and emits progress on success', async () => {\r\n    const fn = resolveRewriteHandler();\r\n    expect(fn, `Available channels: ${Object.keys(handlers).join(', ')}`).toBeTypeOf('function');\r\n\r\n    const payload = {\r\n      sceneId: 's1',\r\n      scene: { id: 's1', text: 'original' },\r\n      issues: [{ id: 'i1', type: 'pronoun', severity: 'should-fix', description: 'x' }],\r\n      previousScenes: [],\r\n      readerContext: {\r\n        knownCharacters: new Set(['Alice']),\r\n        establishedTimeline: [],\r\n        revealedPlotPoints: [],\r\n        establishedSettings: [],\r\n      },\r\n      preserveElements: [],\r\n    };\r\n\r\n    const result = await (fn as Function)({}, payload);\r\n    expect(result.success).toBe(true);\r\n    expect(result.rewrittenText).toBe('rewritten text');\r\n\r\n    expect(mockSend).toHaveBeenCalledWith(\r\n      (IPC_CHANNELS as any).REEWRITE_PROGRESS ?? IPC_CHANNELS.REWRITE_PROGRESS, // allow minor constant drift\r\n      expect.objectContaining({\r\n        sceneId: 's1',\r\n        status: 'complete',\r\n      })\r\n    );\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\preload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\services\\SettingsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\components\\ErrorMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\components\\LoadingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\components\\SceneViewer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'buildReaderContext' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":25},{"ruleId":"react/display-name","severity":2,"message":"Component definition is missing display name","line":40,"column":21,"nodeType":"CallExpression","messageId":"noDisplayName","endLine":234,"endColumn":3},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'manuscript' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":41,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":39}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { forwardRef, useImperativeHandle, useMemo, useRef, useState } from 'react';\r\nimport { useManuscriptStore } from '../stores/manuscriptStore';\r\nimport useIssueHighlighting from '../features/analyze/hooks/useIssueHighlighting';\r\nimport IssueHighlighter from '../features/analyze/components/IssueHighlighter';\r\nimport type { Scene, ReaderKnowledge, ContinuityIssue } from '../../shared/types';\r\nimport useRewriteStore from '../features/rewrite/stores/rewriteStore';\r\nimport RewriteEditor from '../features/rewrite/components/RewriteEditor';\r\n\r\nexport interface SceneViewerHandle {\r\n  scrollToIssue(sceneId: string, issue: ContinuityIssue): void;\r\n}\r\n\r\n// Helper: focused reader context builder\r\nconst buildReaderContext = (previousScenes: Scene[]): ReaderKnowledge => {\r\n  const context: ReaderKnowledge = {\r\n    knownCharacters: new Set<string>(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n\r\n  previousScenes.forEach((scene) => {\r\n    scene.characters?.forEach((char) => context.knownCharacters.add(char));\r\n    scene.timeMarkers?.forEach((marker) => {\r\n      context.establishedTimeline.push({ label: marker });\r\n    });\r\n    scene.locationMarkers?.forEach((loc) => {\r\n      context.establishedSettings.push({ name: loc });\r\n    });\r\n    if (Array.isArray((scene as any).plotMarkers)) {\r\n      (scene as any).plotMarkers.forEach((p: string) => {\r\n        context.revealedPlotPoints.push(p);\r\n      });\r\n    }\r\n  });\r\n\r\n  return context;\r\n};\r\n\r\nconst SceneViewer = forwardRef<SceneViewerHandle>((_props, ref) => {\r\n  const { getSelectedScene, manuscript } = useManuscriptStore();\r\n  const selectedScene = getSelectedScene();\r\n  const analysis = selectedScene?.continuityAnalysis;\r\n\r\n  // Rewrite workflow integration\r\n  const { generateRewrite, hasRewrite, isRewriting, currentRewriteSceneId } = useRewriteStore();\r\n  const [showRewriteEditor, setShowRewriteEditor] = useState(false);\r\n\r\n  // Generate rewrite via store and open the editor\r\n  const handleGenerateRewrite = async () => {\r\n    if (!selectedScene || !analysis?.issues) return;\r\n    await generateRewrite(selectedScene.id);\r\n    setShowRewriteEditor(true);\r\n  };\r\n\r\n  // Is this specific scene currently generating?\r\n  const isGeneratingForThisScene = isRewriting && currentRewriteSceneId === selectedScene?.id;\r\n\r\n  const { buildHighlightsForScene, getScrollTarget } = useIssueHighlighting();\r\n\r\n  const spans = useMemo(() => {\r\n    if (!selectedScene) return [];\r\n    return buildHighlightsForScene(selectedScene.id);\r\n  }, [selectedScene, buildHighlightsForScene]);\r\n\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n\r\n  useImperativeHandle(ref, () => ({\r\n    scrollToIssue(sceneId: string, issue: ContinuityIssue) {\r\n      const root = containerRef.current;\r\n      if (!root) return;\r\n\r\n      const anchorId = getScrollTarget(sceneId, issue);\r\n      const escapeAttr = (s: string) => s.replace(/\"/g, '\\\\\"');\r\n\r\n      let target: HTMLElement | null =\r\n        (root.querySelector(`[id=\"${escapeAttr(anchorId)}\"]`) as HTMLElement | null) ??\r\n        (root.querySelector(`[data-issue-id=\"${escapeAttr(anchorId)}\"]`) as HTMLElement | null);\r\n\r\n      if (!target) {\r\n        const startIdx = Array.isArray(issue.textSpan) ? Number(issue.textSpan?.[0] ?? 0) : 0;\r\n        const candidates = Array.from(root.querySelectorAll<HTMLElement>('[data-start][data-end]'));\r\n        let best: { el: HTMLElement; dist: number } | null = null;\r\n        for (const el of candidates) {\r\n          const a = Number(el.getAttribute('data-start') ?? '0');\r\n          const b = Number(el.getAttribute('data-end') ?? '0');\r\n          const contains = a <= startIdx && startIdx < b;\r\n          const dist = contains ? 0 : Math.min(Math.abs(startIdx - a), Math.abs(startIdx - b));\r\n          if (!best || dist < best.dist || (dist === best.dist && a <= startIdx)) {\r\n            best = { el, dist };\r\n            if (dist === 0) break;\r\n          }\r\n        }\r\n        target = best?.el ?? null;\r\n      }\r\n\r\n      if (target) {\r\n        try {\r\n          target.scrollIntoView({ behavior: 'smooth', block: 'center' });\r\n        } catch {\r\n          // no-op if scrollIntoView options unsupported\r\n          target.scrollIntoView();\r\n        }\r\n        // transient flash to draw attention\r\n        target.classList.add('ring-2', 'ring-indigo-500', 'transition-shadow');\r\n        setTimeout(() => {\r\n          target.classList.remove('ring-2', 'ring-indigo-500', 'transition-shadow');\r\n        }, 1200);\r\n      }\r\n    },\r\n  }));\r\n\r\n  if (!selectedScene) {\r\n    return (\r\n      <div className=\"h-full flex items-center justify-center text-gray-500\">\r\n        <div className=\"text-center\">\r\n          <div className=\"mx-auto h-12 w-12 text-gray-400 mb-4\">\r\n            <svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\r\n            </svg>\r\n          </div>\r\n          <p>Select a scene to view its content</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"h-full flex flex-col\">\r\n      {/* Scene Header */}\r\n      <div className=\"p-4 border-b border-gray-200 bg-gray-50\">\r\n        <div className=\"flex items-center justify-between\">\r\n          <div>\r\n            <h3 className=\"text-lg font-semibold text-gray-900\">\r\n              Scene {selectedScene.position + 1}\r\n            </h3>\r\n            <div className=\"flex items-center gap-4 text-sm text-gray-600 mt-1\">\r\n              <span>{selectedScene.wordCount} words</span>\r\n              {selectedScene.hasBeenMoved && (\r\n                <span className=\"inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800\">\r\n                  Moved from position {selectedScene.originalPosition + 1}\r\n                </span>\r\n              )}\r\n              <span\r\n                className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${\r\n                  selectedScene.rewriteStatus === 'pending'\r\n                    ? 'bg-gray-100 text-gray-800'\r\n                    : selectedScene.rewriteStatus === 'generated'\r\n                    ? 'bg-blue-100 text-blue-800'\r\n                    : selectedScene.rewriteStatus === 'approved'\r\n                    ? 'bg-green-100 text-green-800'\r\n                    : 'bg-red-100 text-red-800'\r\n                }`}\r\n              >\r\n                {selectedScene.rewriteStatus}\r\n              </span>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Scene Content */}\r\n      <div ref={containerRef} className=\"flex-1 overflow-auto p-4\">\r\n        <div className=\"prose max-w-none\">\r\n          <IssueHighlighter\r\n            content={selectedScene.currentRewrite || selectedScene.text}\r\n            spans={spans}\r\n            className=\"whitespace-pre-wrap text-gray-900 leading-relaxed\"\r\n          />\r\n        </div>\r\n      </div>\r\n\r\n      {/* Scene Actions */}\r\n      <div className=\"p-4 border-t border-gray-200 bg-gray-50\">\r\n        <div className=\"flex justify-between items-center\">\r\n          <div className=\"text-sm text-gray-600\">\r\n            {selectedScene.hasBeenMoved ? (\r\n              <span>This scene has been moved and may need rewriting</span>\r\n            ) : (\r\n              <span>Scene is in its original position</span>\r\n            )}\r\n          </div>\r\n          <div className=\"flex gap-2\">\r\n            {selectedScene.hasBeenMoved && ((analysis?.issues?.length ?? 0) > 0) && (\r\n              <>\r\n                {!hasRewrite(selectedScene.id) ? (\r\n                  <button\r\n                    onClick={handleGenerateRewrite}\r\n                    disabled={isGeneratingForThisScene}\r\n                    className={`px-3 py-1 text-sm font-medium rounded-md focus:outline-none focus:ring-2 ${\r\n                      isGeneratingForThisScene\r\n                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\r\n                        : 'text-green-700 bg-green-100 hover:bg-green-200 focus:ring-green-500'\r\n                    }`}\r\n                  >\r\n                    {isGeneratingForThisScene ? 'Generating...' : 'Generate Rewrite'}\r\n                  </button>\r\n                ) : (\r\n                  <>\r\n                    <button\r\n                      onClick={() => setShowRewriteEditor(true)}\r\n                      className=\"px-3 py-1 text-sm font-medium text-blue-700 bg-blue-100 rounded-md hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                    >\r\n                      View Rewrite\r\n                    </button>\r\n                    <button\r\n                      onClick={handleGenerateRewrite}\r\n                      disabled={isGeneratingForThisScene}\r\n                      className=\"px-3 py-1 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500\"\r\n                    >\r\n                      Regenerate\r\n                    </button>\r\n                  </>\r\n                )}\r\n              </>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Rewrite Editor Modal */}\r\n      {showRewriteEditor && selectedScene && (\r\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n          <div className=\"bg-white rounded-lg shadow-xl w-full max-w-6xl h-5/6 flex flex-col\">\r\n            <RewriteEditor\r\n              scene={selectedScene}\r\n              onClose={() => setShowRewriteEditor(false)}\r\n            />\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default SceneViewer;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\__tests__\\DetectorIntegration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'buildReader' is defined but never used. Allowed unused vars must match /^_/u.","line":44,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport PronounDetector from '../detectors/PronounDetector';\r\nimport TimelineDetector from '../detectors/TimelineDetector';\r\nimport CharacterDetector from '../detectors/CharacterDetector';\r\nimport PlotContextDetector from '../detectors/PlotContextDetector';\r\nimport EngagementDetector from '../detectors/EngagementDetector';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { ValidationPipeline } from '../../../../services/ai/validation/ValidationPipeline';\r\n\r\ntype AnalyzeReq = Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\nfunction buildScene(overrides?: Partial<Scene>): Scene {\r\n  const base: Scene = {\r\n    id: 's1',\r\n    text: 'Alice looked at Bob. They went home together.',\r\n    wordCount: 7,\r\n    position: 3,\r\n    originalPosition: 1,\r\n    characters: ['Alice', 'Bob'],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: true,\r\n    rewriteStatus: 'pending',\r\n  };\r\n  return { ...base, ...(overrides ?? {}) } as Scene;\r\n}\r\n\r\nfunction buildPrev(n = 2): Scene[] {\r\n  return Array.from({ length: n }).map((_, i) => ({\r\n    id: `p${i + 1}`,\r\n    text: `Prev ${i + 1} text with Alice and Bob context.`,\r\n    wordCount: 6,\r\n    position: i,\r\n    originalPosition: i,\r\n    characters: ['Alice'],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending',\r\n  })) as Scene[];\r\n}\r\n\r\nfunction buildReader(): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(['Alice']),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\nfunction makeManagerStub(recorded: AnalyzeReq[]) {\r\n  const stub: Pick<AIServiceManager, 'analyzeContinuity'> = {\r\n    analyzeContinuity: vi.fn(async (req: AnalyzeReq) => {\r\n      recorded.push(req);\r\n      const issues: ContinuityIssue[] = []; // return empty to keep mapping deterministic\r\n      return {\r\n        issues,\r\n        metadata: {\r\n          modelUsed: (req as any).__modelId ?? 'mock',\r\n          provider: 'openai',\r\n          costEstimate: 0,\r\n          durationMs: 1,\r\n          confidence: 0.6,\r\n          cached: false,\r\n        },\r\n      };\r\n    }) as any,\r\n  };\r\n  return stub as AIServiceManager;\r\n}\r\n\r\ndescribe('Detector integration - AnalysisRequest enrichment and consensus adapter', () => {\r\n  beforeEach(() => {\r\n    vi.restoreAllMocks();\r\n  });\r\n\r\n  it('non-critical pronoun request: single analyze call with enriched fields', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new PronounDetector();\r\n\r\n    const scene = buildScene({ position: 7 } as any); // no critical flag\r\n    const prev = buildPrev(3);\r\n    await det.detect(scene, prev, manager);\r\n\r\n    // One AI call expected (enrichment path uses single-run)\r\n    expect(calls.length).toBe(1);\r\n    const req = calls[0] as any;\r\n\r\n    // Required enriched fields presence\r\n    expect(req).toBeTruthy();\r\n    expect(req.scene).toBeTruthy();\r\n    expect(req.readerContext).toBeTruthy();\r\n    expect(req.previousScenes).toBeTruthy();\r\n\r\n    // taskType/detector label\r\n    expect(req.taskType).toBe('pronoun');\r\n    expect(req.detector).toBe('pronoun');\r\n\r\n    // sceneText and newPosition meta added (local-only)\r\n    expect(typeof req.sceneText).toBe('string');\r\n    expect(req.sceneText).toContain('Alice looked at Bob');\r\n\r\n    expect(typeof req.newPosition).toBe('number');\r\n    expect(req.newPosition).toBe(7);\r\n\r\n    // previousScenes truncated/compacted upstream but is an array\r\n    expect(Array.isArray(req.previousScenes)).toBe(true);\r\n\r\n    // readerContext knownCharacters is a Set\r\n    expect(req.readerContext.knownCharacters instanceof Set).toBe(true);\r\n  });\r\n\r\n  it('critical pronoun request: consensus path calls analyze twice with distinct modelId', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new PronounDetector();\r\n\r\n    const scene = buildScene({ position: 4 } as any);\r\n    (scene as any).critical = true; // signal critical\r\n    const prev = buildPrev(2);\r\n\r\n    // Spy on reconcile to ensure consensus path engaged\r\n    const spyRecon = vi.spyOn(ValidationPipeline, 'reconcile');\r\n\r\n    await det.detect(scene, prev, manager);\r\n\r\n    // Two calls expected (consensus with default 2 candidates)\r\n    expect(calls.length).toBe(2);\r\n\r\n    const modelIds = new Set((calls.map((r: any) => r.__modelId).filter(Boolean)));\r\n    expect(modelIds.size).toBeGreaterThanOrEqual(2); // distinct per candidate\r\n\r\n    // Each call still carries enriched fields\r\n    for (const req of calls as any[]) {\r\n      expect(req.taskType).toBe('pronoun');\r\n      expect(typeof req.sceneText).toBe('string');\r\n    }\r\n\r\n    expect(spyRecon).toHaveBeenCalledTimes(1);\r\n  });\r\n\r\n  it('timeline detector honors enrichment and consensus flags', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new TimelineDetector();\r\n\r\n    // Provide clear temporal markers so localDetection will produce targets (and trigger AI)\r\n    const scene = buildScene({\r\n      text: 'Next morning, the sky cleared. Later that day, rain returned. Meanwhile, plans were made.',\r\n    } as any);\r\n    (scene as any).critical = true;\r\n    const prev = buildPrev(1);\r\n\r\n    await det.detect(scene, prev, manager);\r\n    expect(calls.length).toBe(2);\r\n    for (const req of calls as any[]) {\r\n      expect(req.taskType).toBe('timeline');\r\n      expect(typeof req.sceneText).toBe('string');\r\n    }\r\n  });\r\n\r\n  it('character detector single-run when not critical', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new CharacterDetector();\r\n\r\n    const scene = buildScene({ text: 'Eve met Mallory. \"Sis,\" she said.' } as any);\r\n    const prev = buildPrev(2);\r\n\r\n    await det.detect(scene, prev, manager);\r\n    // Could be 0 or 1 depending on targets; we assert at most one (no consensus)\r\n    expect(calls.length).toBeLessThanOrEqual(1);\r\n    if (calls.length === 1) {\r\n      const req = calls[0] as any;\r\n      expect(req.taskType).toBe('character');\r\n    }\r\n  });\r\n\r\n  it('plot/engagement detectors set proper taskType and pass enriched meta', async () => {\r\n    const callsPlot: AnalyzeReq[] = [];\r\n    const callsEng: AnalyzeReq[] = [];\r\n    const managerPlot = makeManagerStub(callsPlot);\r\n    const managerEng = makeManagerStub(callsEng);\r\n\r\n    const plot = new PlotContextDetector();\r\n    const engage = new EngagementDetector();\r\n\r\n    const scenePlot = buildScene({ text: 'The incident shocked the town. What happened would change everything.' } as any);\r\n    const sceneEng = buildScene({ text: 'It was the best of times, it was the worst of times. Dialogue starts. \"Hello.\"' } as any);\r\n\r\n    await plot.detect(scenePlot, buildPrev(2), managerPlot);\r\n    await engage.detect(sceneEng, buildPrev(1), managerEng);\r\n\r\n    if (callsPlot.length > 0) {\r\n      expect((callsPlot[0] as any).taskType).toBe('plot');\r\n      expect(typeof (callsPlot[0] as any).sceneText).toBe('string');\r\n    }\r\n    if (callsEng.length > 0) {\r\n      expect((callsEng[0] as any).taskType).toBe('engagement');\r\n      expect(typeof (callsEng[0] as any).sceneText).toBe('string');\r\n    }\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\AnalysisProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\IssueHighlighter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\IssueItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SEVERITY_ORDER' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport type { ContinuityIssue } from '../../../../shared/types';\r\n\r\nexport interface IssueItemProps {\r\n  issue: ContinuityIssue;\r\n  sceneId: string;\r\n  sceneTitle?: string;\r\n  scenePosition?: number;\r\n  onShowInScene?: (issue: ContinuityIssue, sceneId: string) => void;\r\n  onDismiss?: (issue: ContinuityIssue, sceneId: string) => void;\r\n  className?: string;\r\n}\r\n\r\nconst SEVERITY_ORDER: Record<'must-fix' | 'should-fix' | 'consider', number> = {\r\n  'must-fix': 3,\r\n  'should-fix': 2,\r\n  'consider': 1,\r\n} as const;\r\n\r\nconst SEVERITY_LABEL: Record<'must-fix' | 'should-fix' | 'consider', string> = {\r\n  'must-fix': 'MUST FIX',\r\n  'should-fix': 'SHOULD FIX',\r\n  'consider': 'CONSIDER',\r\n} as const;\r\n\r\nconst SEVERITY_CLASS: Record<'must-fix' | 'should-fix' | 'consider', string> = {\r\n  'must-fix': 'bg-red-500/20 text-red-700 dark:text-red-200 border border-red-500/30',\r\n  'should-fix': 'bg-amber-500/20 text-amber-800 dark:text-amber-200 border border-amber-500/30',\r\n  'consider': 'bg-blue-500/20 text-blue-700 dark:text-blue-200 border border-blue-500/30',\r\n} as const;\r\n\r\ntype IssueKind = 'pronoun' | 'timeline' | 'character' | 'plot' | 'engagement' | 'context';\r\n\r\nconst TYPE_ICON: Record<IssueKind, string> = {\r\n  pronoun: '📝',\r\n  timeline: '⏱️',\r\n  character: '🧑',\r\n  plot: '🧩',\r\n  engagement: '✨',\r\n  context: '🧩', // treat unknown/context like plot for display\r\n} as const;\r\n\r\nconst TYPE_LABEL: Record<IssueKind, string> = {\r\n  pronoun: 'pronoun',\r\n  timeline: 'timeline',\r\n  character: 'character',\r\n  plot: 'plot',\r\n  engagement: 'engagement',\r\n  context: 'context',\r\n} as const;\r\n\r\nfunction IssueItem(props: IssueItemProps) {\r\n  const { issue, sceneId, sceneTitle, scenePosition, onShowInScene, onDismiss, className } = props;\r\n\r\n  const severity: 'must-fix' | 'should-fix' | 'consider' =\r\n    (issue.severity as 'must-fix' | 'should-fix' | 'consider') ?? 'should-fix';\r\n\r\n  const typeKey: IssueKind =\r\n    (['pronoun', 'timeline', 'character', 'plot', 'engagement', 'context'] as IssueKind[]).includes(\r\n      issue.type as IssueKind\r\n    )\r\n      ? (issue.type as IssueKind)\r\n      : 'plot';\r\n\r\n  const icon = TYPE_ICON[typeKey];\r\n  const typeLabel = TYPE_LABEL[typeKey];\r\n\r\n  const handleShow = () => {\r\n    if (onShowInScene) onShowInScene(issue, sceneId);\r\n  };\r\n\r\n  const handleDismiss = () => {\r\n    if (onDismiss) onDismiss(issue, sceneId);\r\n  };\r\n\r\n  // Build context line exactly as specified, while avoiding awkward double spaces\r\n  const positionText = scenePosition != null ? String(scenePosition) : '';\r\n  const titleText = sceneTitle ?? sceneId;\r\n  const contextLine = `Scene ${positionText}: ${titleText} (moved)`;\r\n\r\n  return (\r\n    <div\r\n      className={[\r\n        'w-full rounded-md border border-gray-200 dark:border-gray-700 bg-white/60 dark:bg-gray-900/40 p-3 shadow-sm',\r\n        className,\r\n      ]\r\n        .filter(Boolean)\r\n        .join(' ')}\r\n      data-severity={severity}\r\n      data-type={typeLabel}\r\n      aria-label={`Issue ${typeLabel} ${SEVERITY_LABEL[severity]}`}\r\n    >\r\n      <div className=\"flex items-start justify-between gap-2\">\r\n        <div className=\"flex items-center gap-2\">\r\n          <span className=\"text-base\" aria-hidden=\"true\">{icon}</span>\r\n          <span className={['text-[10px] leading-4 px-2 py-0.5 rounded-full uppercase tracking-wide font-semibold', SEVERITY_CLASS[severity]].join(' ')}>\r\n            {SEVERITY_LABEL[severity]}\r\n          </span>\r\n        </div>\r\n\r\n        <div className=\"flex items-center gap-2\">\r\n          {onShowInScene ? (\r\n            <button\r\n              type=\"button\"\r\n              onClick={handleShow}\r\n              className=\"text-xs px-2 py-1 rounded border border-indigo-300 dark:border-indigo-700 text-indigo-700 dark:text-indigo-200 hover:bg-indigo-50 dark:hover:bg-indigo-900/40 transition\"\r\n            >\r\n              Show in Scene\r\n            </button>\r\n          ) : null}\r\n          {onDismiss ? (\r\n            <button\r\n              type=\"button\"\r\n              onClick={handleDismiss}\r\n              className=\"text-xs px-2 py-1 rounded border border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-800 transition\"\r\n            >\r\n              Dismiss\r\n            </button>\r\n          ) : null}\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"mt-2 text-sm text-gray-900 dark:text-gray-100\">\r\n        <div className=\"font-medium\">{typeLabel}</div>\r\n        <div className=\"mt-1\">{issue.description}</div>\r\n        {issue.suggestedFix ? (\r\n          <div className=\"mt-1 text-gray-700 dark:text-gray-300\">\r\n            <span className=\"font-medium\">Fix:</span> {issue.suggestedFix}\r\n          </div>\r\n        ) : null}\r\n        <div className=\"mt-2 text-xs text-gray-600 dark:text-gray-400\">{contextLine}</div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default React.memo(IssueItem);","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\IssuePanel.tsx","messages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useManuscriptStore\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":33,"column":22,"nodeType":"Identifier","endLine":33,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useAnalysis\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":44,"column":7,"nodeType":"Identifier","endLine":44,"endColumn":18},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":47,"column":23,"nodeType":"Identifier","endLine":47,"endColumn":30},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":52,"column":25,"nodeType":"Identifier","endLine":52,"endColumn":32},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":55,"column":18,"nodeType":"Identifier","endLine":55,"endColumn":25},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":58,"column":22,"nodeType":"Identifier","endLine":58,"endColumn":29},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":76,"column":31,"nodeType":"Identifier","endLine":76,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":81,"column":24,"nodeType":"Identifier","endLine":81,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":88,"column":25,"nodeType":"Identifier","endLine":88,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":92,"column":29,"nodeType":"Identifier","endLine":92,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":99,"column":30,"nodeType":"Identifier","endLine":99,"endColumn":41}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo } from 'react';\r\nimport type { ContinuityIssue } from '../../../../shared/types';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useAnalysis from '../hooks/useAnalysis';\r\nimport AnalysisProgress from './AnalysisProgress';\r\nimport IssueItem from './IssueItem';\r\n\r\nexport interface IssuePanelProps {\r\n  isOpen?: boolean;\r\n  onClose?: () => void;\r\n  className?: string;\r\n  onShowInScene?: (sceneId: string, issue: ContinuityIssue) => void;\r\n}\r\n\r\ntype IssueKind = 'pronoun' | 'timeline' | 'character' | 'plot' | 'engagement';\r\n\r\nconst TYPE_LABELS: Record<IssueKind, string> = {\r\n  pronoun: 'Pronoun',\r\n  timeline: 'Timeline',\r\n  character: 'Character',\r\n  plot: 'Plot',\r\n  engagement: 'Engagement',\r\n} as const;\r\n\r\nfunction IssuePanel(props: IssuePanelProps) {\r\n  const { isOpen = true, onClose, className, onShowInScene } = props;\r\n\r\n  // Collapsed placeholder (parent manages layout space)\r\n  if (isOpen === false) {\r\n    return <div className={className} />;\r\n  }\r\n\r\n  const manuscript = useManuscriptStore((s) => s.manuscript);\r\n\r\n  const {\r\n    analyzeMovedScenes,\r\n    getSceneIssues,\r\n    getIssueCountsByType,\r\n    clearIssues,\r\n    toggleIssueType,\r\n    isAnalyzing,\r\n    progress,\r\n    selectedIssueTypes,\r\n  } = useAnalysis();\r\n\r\n  // Moved scenes (ids and map for context)\r\n  const movedScenes = useMemo(() => {\r\n    const scenes = manuscript?.scenes ?? [];\r\n    return scenes.filter((s) => s.hasBeenMoved === true);\r\n  }, [manuscript]);\r\n\r\n  const movedSceneIds = useMemo(() => movedScenes.map((s) => s.id), [movedScenes]);\r\n\r\n  // Counts by type (respects selectedIssueTypes inside hook implementation)\r\n  const counts = useMemo(() => getIssueCountsByType(movedSceneIds), [getIssueCountsByType, movedSceneIds]);\r\n\r\n  // Flat list of issues across moved scenes (grouping optional per subtask; provide scene metadata to items)\r\n  const flatIssues = useMemo(() => {\r\n    const items: Array<{ sceneId: string; issue: ContinuityIssue; sceneTitle?: string; scenePosition?: number }> = [];\r\n    for (const scene of movedScenes) {\r\n      const sceneIssues = getSceneIssues(scene.id);\r\n      if (!sceneIssues || sceneIssues.length === 0) continue;\r\n      for (const issue of sceneIssues) {\r\n        items.push({\r\n          sceneId: scene.id,\r\n          issue,\r\n          // Title/name may not exist on Scene type; fall back to id. Position is available.\r\n          sceneTitle: (scene as unknown as { title?: string; name?: string }).title ?? (scene as unknown as { title?: string; name?: string }).name ?? scene.id,\r\n          scenePosition: scene.position,\r\n        });\r\n      }\r\n    }\r\n    return items;\r\n  }, [movedScenes, getSceneIssues]);\r\n\r\n  const totalFilteredIssues = useMemo(\r\n    () => Object.values(counts).reduce((acc, n) => acc + n, 0),\r\n    [counts]\r\n  );\r\n\r\n  const handleToggle = useCallback(\r\n    (type: IssueKind) => {\r\n      toggleIssueType(type);\r\n    },\r\n    [toggleIssueType]\r\n  );\r\n\r\n  const handleAnalyze = useCallback(() => {\r\n    void analyzeMovedScenes();\r\n  }, [analyzeMovedScenes]);\r\n\r\n  const handleShowInScene = useCallback(\r\n    (issue: ContinuityIssue, sceneId: string) => {\r\n      if (onShowInScene) onShowInScene(sceneId, issue);\r\n    },\r\n    [onShowInScene]\r\n  );\r\n\r\n  const handleDismissIssue = useCallback(\r\n    (issue: ContinuityIssue, sceneId: string) => {\r\n      // Subtask scope: simple dismissal clears all issues for the scene.\r\n      clearIssues(sceneId);\r\n    },\r\n    [clearIssues]\r\n  );\r\n\r\n  const Pill = ({ type }: { type: IssueKind }) => {\r\n    const active = selectedIssueTypes.has(type);\r\n    const count = counts[type] ?? 0;\r\n    return (\r\n      <button\r\n        type=\"button\"\r\n        onClick={() => handleToggle(type)}\r\n        className={[\r\n          'text-xs px-2 py-1 rounded-full border transition',\r\n          active\r\n            ? 'bg-indigo-600 text-white border-indigo-600'\r\n            : 'bg-white/60 dark:bg-gray-900/40 text-gray-800 dark:text-gray-200 border-gray-300 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800',\r\n        ].join(' ')}\r\n        aria-pressed={active}\r\n        aria-label={`${TYPE_LABELS[type]} issues`}\r\n      >\r\n        <span>{TYPE_LABELS[type]}</span>\r\n        <span\r\n          className={[\r\n            'ml-2 inline-flex items-center justify-center min-w-[1.25rem] h-5 px-1 rounded-full',\r\n            active ? 'bg-white/20 text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200',\r\n          ].join(' ')}\r\n        >\r\n          {count}\r\n        </span>\r\n      </button>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div className={['w-full rounded-lg border border-gray-200 dark:border-gray-700 bg-white/70 dark:bg-gray-900/40', className].filter(Boolean).join(' ')}>\r\n      {/* Header */}\r\n      <div className=\"flex items-center justify-between p-3 border-b border-gray-200 dark:border-gray-700\">\r\n        <div className=\"flex items-center gap-2\">\r\n          <h2 className=\"text-sm font-semibold text-gray-900 dark:text-gray-100\">Issues Found in Moved Scenes</h2>\r\n        </div>\r\n        <div className=\"flex items-center gap-2\">\r\n          <button\r\n            type=\"button\"\r\n            onClick={handleAnalyze}\r\n            className=\"text-xs px-3 py-1.5 rounded-md bg-indigo-600 text-white hover:bg-indigo-700 transition\"\r\n          >\r\n            Analyze Moved Scenes\r\n          </button>\r\n          {onClose ? (\r\n            <button\r\n              type=\"button\"\r\n              onClick={onClose}\r\n              className=\"text-xs px-2 py-1 rounded-md border border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-800\"\r\n              aria-label=\"Close issues panel\"\r\n              title=\"Close\"\r\n            >\r\n              ×\r\n            </button>\r\n          ) : null}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Progress */}\r\n      <div className=\"p-3\">\r\n        <AnalysisProgress isAnalyzing={isAnalyzing} progress={progress} />\r\n      </div>\r\n\r\n      {/* Filters */}\r\n      <div className=\"px-3 pb-2\">\r\n        <div className=\"flex flex-wrap gap-2\">\r\n          {(['pronoun', 'timeline', 'character', 'plot', 'engagement'] as IssueKind[]).map((t) => (\r\n            <Pill key={t} type={t} />\r\n          ))}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Body */}\r\n      <div className=\"p-3\">\r\n        {totalFilteredIssues === 0 && !isAnalyzing && progress?.total > 0 ? (\r\n          <div className=\"text-sm text-gray-600 dark:text-gray-300\">No issues found in moved scenes</div>\r\n        ) : (\r\n          <div className=\"flex flex-col gap-3\">\r\n            {flatIssues.map(({ sceneId, issue, sceneTitle, scenePosition }) => (\r\n              <IssueItem\r\n                key={`${sceneId}-${issue.type}-${issue.textSpan?.[0] ?? 0}-${issue.textSpan?.[1] ?? 0}-${issue.description}`}\r\n                issue={issue}\r\n                sceneId={sceneId}\r\n                sceneTitle={sceneTitle}\r\n                scenePosition={scenePosition}\r\n                onShowInScene={handleShowInScene}\r\n                onDismiss={handleDismissIssue}\r\n              />\r\n            ))}\r\n            {flatIssues.length === 0 && isAnalyzing ? (\r\n              <div className=\"text-sm text-gray-600 dark:text-gray-300\">Analyzing moved scenes…</div>\r\n            ) : null}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default IssuePanel;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\BaseDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\CharacterDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'assessFirstAppearanceIssues' is defined but never used. Allowed unused vars must match /^_/u.","line":380,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":380,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'assessRelationshipAssumptions' is defined but never used. Allowed unused vars must match /^_/u.","line":404,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":404,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'assessPronounBeforeNaming' is defined but never used. Allowed unused vars must match /^_/u.","line":435,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":435,"endColumn":35}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\n/**\r\n * Character continuity detector (Detector 2 - Phase 2):\r\n * - Local NLP via compromise (safe) + regex fallback\r\n * - Previous character registry caching and alias handling\r\n * - Immediate local issues for missing/weak intros and relationship assumptions\r\n * - Selective AI validation (analysisType \"consistency\") for adequacy/ambiguity\r\n */\r\n\r\n// ---------- Internal & exported types ----------\r\nexport interface NameOccurrence {\r\n  name: string;\r\n  start: number;\r\n  end: number;\r\n  sentenceIndex: number;\r\n  isFull: boolean;\r\n  isFirstOnly: boolean;\r\n  hasApposition: boolean;\r\n  nickname?: string;\r\n}\r\n\r\nexport interface PreviousRegistry {\r\n  canonical: Set<string>;\r\n  aliases: Map<string, Set<string>>; // key: canonical, value: alias set\r\n}\r\n\r\nexport interface CharacterDetectionTarget {\r\n  characterName: string;\r\n  aliasNames: string[];\r\n  firstOccurrence: [number, number];\r\n  sentenceText: string;\r\n  context: string;\r\n  prevRegistry: { canonical: string[]; aliases: string[] };\r\n  relationshipTerms: string[];\r\n  sentenceIndex: number;\r\n}\r\n\r\n// ---------- Module state ----------\r\nconst registryCache: Map<string, PreviousRegistry> = new Map();\r\n\r\n// ---------- Small utilities (kept <= 40 lines) ----------\r\nfunction escapeRegExp(s: string): string {\r\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n\r\nfunction signature(previous: readonly Scene[]): string {\r\n  return previous.map(s => s.id).join('|');\r\n}\r\n\r\nfunction splitSentences(text: string): { text: string; start: number; end: number }[] {\r\n  const out: { text: string; start: number; end: number }[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      const seg = text.slice(m.index, m.index + m[0].length);\r\n      out.push({ text: seg.trim(), start: m.index, end: m.index + m[0].length });\r\n    }\r\n  } catch {/* noop */}\r\n  if (out.length === 0) out.push({ text, start: 0, end: text.length });\r\n  return out;\r\n}\r\n\r\nfunction toLowerSet(iter: Iterable<string>): Set<string> {\r\n  const s = new Set<string>();\r\n  for (const v of iter) s.add(v.toLowerCase());\r\n  return s;\r\n}\r\n\r\nfunction appositionAfter(text: string, end: number): boolean {\r\n  const seg = text.slice(end, Math.min(text.length, end + 40));\r\n  return /(,\\s*(the|a|an)\\s+[a-z-]{2,})|(\\s+who\\s+)/i.test(seg);\r\n}\r\n\r\nfunction contextSnippet(text: string, start: number, end: number, radius = 120): string {\r\n  const s = Math.max(0, start - radius);\r\n  const e = Math.min(text.length, end + radius);\r\n  return text.slice(s, e).trim();\r\n}\r\n\r\nfunction flattenAliases(reg: PreviousRegistry): Set<string> {\r\n  const flat = new Set<string>();\r\n  for (const set of reg.aliases.values()) for (const a of set) flat.add(a);\r\n  return flat;\r\n}\r\n\r\nfunction firstLastTokens(full: string): { first?: string; last?: string } {\r\n  const parts = full.split(/\\s+/).filter(Boolean);\r\n  return { first: parts[0], last: parts.length > 1 ? parts[parts.length - 1] : undefined };\r\n}\r\n\r\nfunction titleStripped(name: string): string {\r\n  return name.replace(/\\b(?:Dr|Mr|Mrs|Ms|Miss)\\.\\s*/g, '').trim();\r\n}\r\n\r\nconst REL_TERMS = [\r\n  'as usual','like before','as she told him','as he told her','back at it','you know',\r\n  'sis','bro','honey','dear','sweetie','buddy','pal'\r\n];\r\n\r\nconst PRONOUNS = ['he','she','him','her','his','hers','they','them','their','theirs'];\r\n\r\nconst NAME_FALLBACK_RE = /\\b(?:Dr|Mr|Mrs|Ms|Miss)\\.\\s+[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?|\\b([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?)\\b/g;\r\n\r\nconst NAME_STOP = new Set([\r\n  'The','A','An','And','But','Or','If','Then','When','While','After','Before',\r\n  'Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday',\r\n  'January','February','March','April','May','June','July','August','September','October','November','December'\r\n]);\r\n\r\n// ---------- Required exports (testing hooks) ----------\r\nexport function buildPreviousRegistry(previousScenes: readonly Scene[]): PreviousRegistry {\r\n  const canonical = new Set<string>();\r\n  const aliases = new Map<string, Set<string>>();\r\n  const addAlias = (canon: string, a: string | undefined) => {\r\n    if (!a) return;\r\n    const key = canon;\r\n    const set = aliases.get(key) ?? new Set<string>();\r\n    set.add(a);\r\n    aliases.set(key, set);\r\n  };\r\n\r\n  for (const sc of previousScenes) {\r\n    let m: RegExpExecArray | null;\r\n    const text = sc.text ?? '';\r\n    while ((m = NAME_FALLBACK_RE.exec(text)) !== null) {\r\n      const raw = m[0].trim();\r\n      const nm = raw;\r\n      if (!nm) continue;\r\n      const stripped = titleStripped(nm);\r\n      const tok0 = stripped.split(/\\s+/)[0];\r\n      if (!tok0 || NAME_STOP.has(tok0)) continue;\r\n      canonical.add(stripped);\r\n      const { first, last } = firstLastTokens(stripped);\r\n      addAlias(stripped, first);\r\n      addAlias(stripped, last);\r\n    }\r\n    // nickname patterns: First \"Nick\" Last OR First (Nick) Last\r\n    const nickRe = /\\b([A-Z][a-z]+)\\s+(?:\"([^\"]+)\"|\\(([^)]+)\\))\\s+([A-Z][a-z]+)\\b/g;\r\n    let nm: RegExpExecArray | null;\r\n    while ((nm = nickRe.exec(text)) !== null) {\r\n      const canon = `${nm[1]} ${nm[4]}`;\r\n      canonical.add(canon);\r\n      const nick = (nm[2] ?? nm[3] ?? '').trim();\r\n      if (nick) addAlias(canon, nick);\r\n      addAlias(canon, nm[1]);\r\n      addAlias(canon, nm[4]);\r\n    }\r\n  }\r\n  return { canonical, aliases };\r\n}\r\n\r\nexport function extractSceneNames(sceneText: string): NameOccurrence[] {\r\n  const sentences = splitSentences(sceneText);\r\n  const seen = new Set<string>();\r\n  const out: NameOccurrence[] = [];\r\n  let m: RegExpExecArray | null;\r\n  while ((m = NAME_FALLBACK_RE.exec(sceneText)) !== null) {\r\n    const raw = m[0].trim();\r\n    const nm = raw;\r\n    if (!nm) continue;\r\n    const stripped = titleStripped(nm);\r\n    const tok0 = stripped.split(/\\s+/)[0];\r\n    if (!tok0 || NAME_STOP.has(tok0)) continue;\r\n    if (seen.has(stripped)) continue;\r\n    seen.add(stripped);\r\n    const start = m.index;\r\n    const end = start + m[0].length;\r\n    let si = sentences.findIndex(s => start >= s.start && start < s.end);\r\n    if (si < 0) si = 0;\r\n    const isFull = /\\s/.test(stripped);\r\n    const isFirstOnly = !isFull;\r\n    out.push({ name: stripped, start, end, sentenceIndex: si, isFull, isFirstOnly, hasApposition: appositionAfter(sceneText, end) });\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function findFirstMentionOffsets(name: string, sceneText: string, fromIndex?: number): [number, number] {\r\n  const nm = escapeRegExp(name);\r\n  const re = new RegExp(`\\\\b${nm}\\\\b`);\r\n  const idx = re.exec(sceneText.slice(fromIndex ?? 0))?.index;\r\n  if (idx === undefined) return [-1, -1];\r\n  const start = (fromIndex ?? 0) + idx;\r\n  return [start, start + name.length];\r\n}\r\n\r\nexport function detectRelationshipTerms(sentenceText: string): string[] {\r\n  const low = sentenceText.toLowerCase();\r\n  const found: string[] = [];\r\n  for (const t of REL_TERMS) {\r\n    if (low.includes(t)) found.push(t);\r\n  }\r\n  return found;\r\n}\r\n\r\nexport function prepareDetectionTargets(\r\n  names: readonly NameOccurrence[],\r\n  sceneText: string,\r\n  sentences: readonly { text: string; start: number; end: number }[],\r\n  reg: PreviousRegistry\r\n): CharacterDetectionTarget[] {\r\n  const cset = toLowerSet(reg.canonical);\r\n  const aset = toLowerSet(flattenAliases(reg));\r\n  const targets: CharacterDetectionTarget[] = [];\r\n  for (const n of names) {\r\n    const low = n.name.toLowerCase();\r\n    const known = n.isFull ? cset.has(low) : aset.has(low);\r\n    if (!known && (n.isFirstOnly || n.nickname) && !n.hasApposition) {\r\n      const sent = sentences[n.sentenceIndex]?.text ?? '';\r\n      targets.push({\r\n        characterName: n.name,\r\n        aliasNames: Array.from(new Set([firstLastTokens(n.name).first, firstLastTokens(n.name).last, n.nickname].filter(Boolean) as string[])),\r\n        firstOccurrence: [n.start, n.end],\r\n        sentenceText: sent,\r\n        context: contextSnippet(sceneText, n.start, n.end),\r\n        prevRegistry: {\r\n          canonical: Array.from(reg.canonical).slice(0, 6),\r\n          aliases: Array.from(flattenAliases(reg)).slice(0, 6),\r\n        },\r\n        relationshipTerms: detectRelationshipTerms(sent),\r\n        sentenceIndex: n.sentenceIndex,\r\n      });\r\n    }\r\n  }\r\n  return targets;\r\n}\r\n\r\n// ---------- Internal helpers for local analysis ----------\r\nfunction getOrBuildRegistry(previous: readonly Scene[]): PreviousRegistry {\r\n  const sig = signature(previous);\r\n  const cached = registryCache.get(sig);\r\n  if (cached) return cached;\r\n  const reg = buildPreviousRegistry(previous);\r\n  registryCache.set(sig, reg);\r\n  return reg;\r\n}\r\n\r\nfunction compileCurrentNamesWithCompromise(sceneText: string, doc: any | null): NameOccurrence[] {\r\n  if (!doc || typeof doc.people !== 'function') return extractSceneNames(sceneText);\r\n  try {\r\n    const arr: string[] = doc.people().out('array') ?? [];\r\n    const uniq = Array.from(new Set(arr.filter(s => s && typeof s === 'string').map(s => s.trim()).filter(Boolean)));\r\n    const sentences = splitSentences(sceneText);\r\n    const out: NameOccurrence[] = [];\r\n    for (const nm of uniq) {\r\n      const [start, end] = findFirstMentionOffsets(nm, sceneText);\r\n      if (start < 0) continue;\r\n      let si = sentences.findIndex(s => start >= s.start && start < s.end);\r\n      if (si < 0) si = 0;\r\n      const stripped = titleStripped(nm);\r\n      const isFull = /\\s/.test(stripped);\r\n      out.push({\r\n        name: stripped,\r\n        start,\r\n        end,\r\n        sentenceIndex: si,\r\n        isFull,\r\n        isFirstOnly: !isFull,\r\n        hasApposition: appositionAfter(sceneText, end),\r\n      });\r\n    }\r\n    return out.length ? out : extractSceneNames(sceneText);\r\n  } catch {\r\n    return extractSceneNames(sceneText);\r\n  }\r\n}\r\n\r\nfunction prevTextContainsRelation(previous: readonly Scene[], name: string, term: string): boolean {\r\n  const hay = previous.map(s => s.text || '').join('\\n').toLowerCase();\r\n  return hay.includes(name.toLowerCase()) && hay.includes(term.toLowerCase());\r\n}\r\n\r\nfunction findOpeningPronouns(sceneText: string, sentences: readonly { start: number; end: number }[], maxSentence = 2) {\r\n  const limitEnd = sentences[Math.min(maxSentence - 1, sentences.length - 1)]?.end ?? Math.min(sceneText.length, 240);\r\n  const text = sceneText.slice(0, limitEnd);\r\n  const re = new RegExp(`\\\\b(${PRONOUNS.join('|')})\\\\b`, 'gi');\r\n  const list: { pronoun: string; start: number; end: number }[] = [];\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text)) !== null) {\r\n    const s = m.index;\r\n    list.push({ pronoun: m[0].toLowerCase(), start: s, end: s + m[0].length });\r\n  }\r\n  return list;\r\n}\r\n\r\n// ---------- AI request/response helpers ----------\r\nfunction buildReaderContext(names: readonly string[]): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(names),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\nfunction registryKnownNames(reg: PreviousRegistry): string[] {\r\n  return Array.from(reg.canonical);\r\n}\r\n\r\nfunction buildAIHeader(scene: Scene, targets: readonly CharacterDetectionTarget[], reg: PreviousRegistry): string {\r\n  const lines: string[] = [];\r\n  lines.push('[[Character detection targets]]');\r\n  lines.push(`scene: id=${scene.id} pos=${scene.position}`);\r\n  const chosen = targets.slice(0, 8);\r\n  for (const c of chosen) {\r\n    const sent = (c.sentenceText || '').slice(0, 140).replace(/\\n+/g, ' ');\r\n    const aliases = c.aliasNames.slice(0, 4).join(', ') || 'none';\r\n    const rel = c.relationshipTerms.slice(0, 4).join(', ') || 'none';\r\n    lines.push(`- name=\"${c.characterName}\" span=[${c.firstOccurrence[0]},${c.firstOccurrence[1]}] sent=\"${sent}\" aliases=[${aliases}] rel=[${rel}]`);\r\n  }\r\n  lines.push('[[Previous registry summary]]');\r\n  lines.push(`canonical: ${Array.from(reg.canonical).slice(0, 8).join(' | ')}`);\r\n  lines.push(`aliases: ${Array.from(flattenAliases(reg)).slice(0, 10).join(' | ')}`);\r\n  lines.push('[[Scene excerpt]]');\r\n  return lines.join('\\n');\r\n}\r\n\r\nfunction buildSceneExcerpt(text: string, targets: readonly CharacterDetectionTarget[], maxLen = 1200): string {\r\n  if (!targets.length) return text.slice(0, maxLen);\r\n  const snippets: string[] = [];\r\n  const used: [number, number][] = [];\r\n  for (const c of targets) {\r\n    const [s, e] = c.firstOccurrence;\r\n    const snip = contextSnippet(text, s, e, 220);\r\n    if (!snip) continue;\r\n    snippets.push(snip);\r\n    used.push([s, e]);\r\n    const len = snippets.join('\\n---\\n').length;\r\n    if (len > maxLen) break;\r\n  }\r\n  const out = snippets.join('\\n---\\n');\r\n  return out.slice(0, maxLen);\r\n}\r\n\r\nfunction mapAICharacterIssues(\r\n  resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n  sceneText: string,\r\n  targets: readonly CharacterDetectionTarget[]\r\n): ContinuityIssue[] {\r\n  const byName = new Map<string, CharacterDetectionTarget>();\r\n  for (const c of targets) byName.set(c.characterName.toLowerCase(), c);\r\n  const out: ContinuityIssue[] = [];\r\n  for (const it of resp?.issues ?? []) {\r\n    if ((it.type ?? 'character') !== 'character') continue;\r\n    const hasSpan = Array.isArray(it.textSpan) && Number.isFinite(it.textSpan[0]) && Number.isFinite(it.textSpan[1]);\r\n    if (hasSpan) {\r\n      out.push({\r\n        type: 'character',\r\n        severity: it.severity ?? 'should-fix',\r\n        description: it.description ?? 'Character introduction/relationship adequacy issue',\r\n        textSpan: it.textSpan as [number, number],\r\n        suggestedFix: it.suggestedFix,\r\n      });\r\n      continue;\r\n    }\r\n    // Fallback: attach to detection target first occurrence by name if present\r\n    const key = (it.description ?? '').toLowerCase();\r\n    let chosen = null as CharacterDetectionTarget | null;\r\n    for (const [nm, c] of byName) {\r\n      if (key.includes(nm)) { chosen = c; break; }\r\n    }\r\n    chosen ??= targets[0] ?? null;\r\n    const span: [number, number] = chosen ? chosen.firstOccurrence : [0, Math.min(1, sceneText.length)];\r\n    out.push({\r\n      type: 'character',\r\n      severity: it.severity ?? 'should-fix',\r\n      description: it.description ?? `Character adequacy issue: ${chosen?.characterName ?? 'unknown'}`,\r\n      textSpan: span,\r\n      suggestedFix: it.suggestedFix,\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\n// ---------- Local assessment helpers (<= 40 lines each) ----------\r\nfunction assessFirstAppearanceIssues(\r\n  currentNames: readonly NameOccurrence[],\r\n  reg: PreviousRegistry\r\n): { issues: ContinuityIssue[]; unknownFirstMentions: number } {\r\n  const issues: ContinuityIssue[] = [];\r\n  let count = 0;\r\n  const canSet = toLowerSet(reg.canonical);\r\n  const aliSet = toLowerSet(flattenAliases(reg));\r\n  for (const n of currentNames) {\r\n    const low = n.name.toLowerCase();\r\n    const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n    if (!known && (n.isFirstOnly || n.nickname) && !n.hasApposition) {\r\n      count++;\r\n      issues.push({\r\n        type: 'character',\r\n        severity: n.sentenceIndex <= 1 ? 'must-fix' : 'should-fix',\r\n        description: `First mention \"${n.name}\" appears without introduction/background.`,\r\n        textSpan: [n.start, n.end],\r\n      });\r\n    }\r\n  }\r\n  return { issues, unknownFirstMentions: count };\r\n}\r\n\r\nfunction assessRelationshipAssumptions(\r\n  sentences: readonly { text: string; start: number; end: number }[],\r\n  currentNames: readonly NameOccurrence[],\r\n  previousScenes: readonly Scene[]\r\n): { issues: ContinuityIssue[]; relTermsFound: number } {\r\n  const issues: ContinuityIssue[] = [];\r\n  let relTermsFound = 0;\r\n  for (const sent of sentences) {\r\n    const terms = detectRelationshipTerms(sent.text);\r\n    if (!terms.length) continue;\r\n    const anyNameHere = currentNames.some(n => n.start >= sent.start && n.start < sent.end);\r\n    if (!anyNameHere) continue;\r\n    relTermsFound += terms.length;\r\n    const nameInSent = currentNames.find(n => n.start >= sent.start && n.start < sent.end)?.name;\r\n    const supported = nameInSent ? terms.some(t => prevTextContainsRelation(previousScenes, nameInSent, t)) : false;\r\n    if (!supported) {\r\n      const t0 = terms[0];\r\n      const off = sent.text.toLowerCase().indexOf(t0);\r\n      const begin = off >= 0 ? sent.start + off : sent.start;\r\n      const end = off >= 0 ? begin + t0.length : Math.min(sent.end, begin + 4);\r\n      issues.push({\r\n        type: 'character',\r\n        severity: 'should-fix',\r\n        description: `Relationship assumption \"${t0}\" with ${nameInSent ?? 'a character'} may lack prior support.`,\r\n        textSpan: [begin, end],\r\n      });\r\n    }\r\n  }\r\n  return { issues, relTermsFound };\r\n}\r\n\r\nfunction assessPronounBeforeNaming(\r\n  sceneText: string,\r\n  sentences: readonly { start: number; end: number }[],\r\n  currentNames: readonly NameOccurrence[],\r\n  reg: PreviousRegistry\r\n): ContinuityIssue[] {\r\n  const issues: ContinuityIssue[] = [];\r\n  const canSet = toLowerSet(reg.canonical);\r\n  const aliSet = toLowerSet(flattenAliases(reg));\r\n  const openingPronouns = findOpeningPronouns(sceneText, sentences, 2);\r\n  if (!openingPronouns.length) return issues;\r\n  const earliestUnknown = currentNames\r\n    .filter(n => {\r\n      const low = n.name.toLowerCase();\r\n      const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n      return !known;\r\n    })\r\n    .sort((a, b) => a.sentenceIndex - b.sentenceIndex)[0];\r\n  if (earliestUnknown && earliestUnknown.sentenceIndex >= 2) {\r\n    const p0 = openingPronouns[0];\r\n    issues.push({\r\n      type: 'character',\r\n      severity: 'should-fix',\r\n      description: `Early pronoun reference precedes first naming of a new character \"${earliestUnknown.name}\".`,\r\n      textSpan: [p0.start, p0.end],\r\n    });\r\n  }\r\n  return issues;\r\n}\r\n// ---------- Detector implementation ----------\r\nexport default class CharacterDetector extends BaseDetector<CharacterDetectionTarget> {\r\n  public readonly detectorType = 'character' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<CharacterDetectionTarget>> {\r\n    if (!scene?.text || typeof scene.text !== 'string' || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n\r\n    const doc = await this.safeNLP(scene.text);\r\n    const sentences = splitSentences(scene.text);\r\n    const currentNames = compileCurrentNamesWithCompromise(scene.text, doc);\r\n    const reg = getOrBuildRegistry(previousScenes);\r\n    const canSet = toLowerSet(reg.canonical);\r\n    const aliSet = toLowerSet(flattenAliases(reg));\r\n\r\n    let unknownFirstMentions = 0;\r\n    let relTermsFound = 0;\r\n    const issues: ContinuityIssue[] = [];\r\n\r\n    // First-appearance without intro\r\n    for (const n of currentNames) {\r\n      const low = n.name.toLowerCase();\r\n      const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n      if (!known && (n.isFirstOnly || n.nickname) && !n.hasApposition) {\r\n        unknownFirstMentions++;\r\n        const sev: ContinuityIssue['severity'] = n.sentenceIndex <= 1 ? 'must-fix' : 'should-fix';\r\n        issues.push({\r\n          type: 'character',\r\n          severity: sev,\r\n          description: `First mention \"${n.name}\" appears without introduction/background.`,\r\n          textSpan: [n.start, n.end],\r\n        });\r\n      }\r\n    }\r\n\r\n    // Relationship assumptions\r\n    for (const sent of sentences) {\r\n      const terms = detectRelationshipTerms(sent.text);\r\n      if (!terms.length) continue;\r\n      const anyNameHere = currentNames.some(n => n.start >= sent.start && n.start < sent.end);\r\n      if (!anyNameHere) continue;\r\n      relTermsFound += terms.length;\r\n      // If no evidence in previous scenes, flag should-fix\r\n      const nameInSent = currentNames.find(n => n.start >= sent.start && n.start < sent.end)?.name;\r\n      const supported = nameInSent ? terms.some(t => prevTextContainsRelation(previousScenes, nameInSent, t)) : false;\r\n      if (!supported) {\r\n        const t0 = terms[0];\r\n        const off = sent.text.toLowerCase().indexOf(t0);\r\n        const begin = off >= 0 ? sent.start + off : sent.start;\r\n        const end = off >= 0 ? begin + t0.length : Math.min(sent.end, begin + 4);\r\n        issues.push({\r\n          type: 'character',\r\n          severity: 'should-fix',\r\n          description: `Relationship assumption \"${t0}\" with ${nameInSent ?? 'a character'} may lack prior support.`,\r\n          textSpan: [begin, end],\r\n        });\r\n      }\r\n    }\r\n\r\n    // Pronouns before naming (approximate)\r\n    const openingPronouns = findOpeningPronouns(scene.text, sentences, 2);\r\n    if (openingPronouns.length) {\r\n      const earliestUnknown = currentNames\r\n        .filter(n => {\r\n          const low = n.name.toLowerCase();\r\n          const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n          return !known;\r\n        })\r\n        .sort((a, b) => a.sentenceIndex - b.sentenceIndex)[0];\r\n      if (earliestUnknown && earliestUnknown.sentenceIndex >= 2) {\r\n        const p0 = openingPronouns[0];\r\n        issues.push({\r\n          type: 'character',\r\n          severity: 'should-fix',\r\n          description: `Early pronoun reference precedes first naming of a new character \"${earliestUnknown.name}\".`,\r\n          textSpan: [p0.start, p0.end],\r\n        });\r\n      }\r\n    }\r\n\r\n    const targets = prepareDetectionTargets(currentNames, scene.text, sentences, reg);\r\n    console.debug('[CharacterDetector] names:', currentNames.length, 'unknownFirst:', unknownFirstMentions, 'relTerms:', relTermsFound, 'targets:', targets.length);\r\n\r\n    return {\r\n      issues,\r\n      requiresAI: targets.length > 0,\r\n      targets,\r\n      stats: {\r\n        namesFound: currentNames.length,\r\n        unknownFirstMentions,\r\n        relTermsFound,\r\n        targets: targets.length,\r\n      },\r\n    };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly CharacterDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n    try {\r\n      const reg = getOrBuildRegistry(previousScenes);\r\n      const header = buildAIHeader(scene, targets, reg);\r\n      const excerpt = buildSceneExcerpt(scene.text, targets, 1200);\r\n      const lastPrev = previousScenes.slice(-1).map(s => ({ ...s, text: (s.text ?? '').slice(0, 800) }));\r\n      const baseReq = {\r\n        scene: { ...scene, text: `${header}\\n\\n${excerpt}` },\r\n        previousScenes: lastPrev as Scene[],\r\n        analysisType: 'consistency' as const,\r\n        readerContext: buildReaderContext(registryKnownNames(reg)),\r\n      } as Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\n      const enriched = enrichAnalysisRequest(baseReq as any, {\r\n        scene,\r\n        detectorType: 'character',\r\n        flags: { critical: Boolean((scene as any)?.critical) },\r\n      });\r\n\r\n      console.debug('[CharacterDetector] invoking AI (consistency) for targets:', targets.length);\r\n      const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n\r\n      const out = mapAICharacterIssues({ issues }, scene.text, targets);\r\n      console.debug('[CharacterDetector] AI returned character issues:', out.length);\r\n      return out;\r\n    } catch (err) {\r\n      console.debug('[CharacterDetector] AI analyzeContinuity failed; degrading to local-only.', err);\r\n      return [];\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\EngagementDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":104,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":104,"endColumn":40}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\ninterface OpeningStats {\r\n  tokenCount150: number;\r\n  avgSentenceLen: number;\r\n  dialogueRatio: number;\r\n  namedEntities: number;\r\n  adverbs: number;\r\n  adjectives: number;\r\n  uniqueProperNouns2: number;\r\n}\r\n\r\ninterface PreviousSummary {\r\n  characters: string[];\r\n  keyTerms: string[];\r\n}\r\n\r\ninterface EngagementDetectionTarget {\r\n  hookLine: string;\r\n  firstSentences: string[];\r\n  contextWindow: string;\r\n  openingStats: OpeningStats;\r\n  previousSummary: PreviousSummary;\r\n}\r\n\r\nconst ADJ_WORDS = new Set([\r\n  'new','young','old','small','large','little','long','short','great','good','bad','happy','sad','dark','bright','cold','warm','quiet','loud','sudden','slow','fast','early'\r\n]);\r\n\r\nexport function splitSentences(text: string): { start: number; end: number; text: string }[] {\r\n  const out: { start: number; end: number; text: string }[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      const seg = text.slice(m.index, m.index + m[0].length);\r\n      out.push({ start: m.index, end: m.index + m[0].length, text: seg.trim() });\r\n    }\r\n  } catch { /* noop */ }\r\n  if (out.length === 0) out.push({ start: 0, end: text.length, text });\r\n  return out;\r\n}\r\n\r\nexport function extractHookLine(text: string): string {\r\n  const sents = splitSentences(text);\r\n  const first = sents.find(s => s.text.trim().length > 0)?.text ?? '';\r\n  return first.trim().slice(0, 200);\r\n}\r\n\r\nfunction uniqueProperInSentences(text: string, sents: readonly { start: number; end: number }[], count = 2): number {\r\n  const take = sents.slice(0, Math.max(0, Math.min(count, sents.length)));\r\n  const set = new Set<string>();\r\n  for (const s of take) {\r\n    const seg = text.slice(s.start, s.end);\r\n    const m = seg.match(/\\b[A-Z][a-z]+\\b/g) ?? [];\r\n    m.forEach((t, idx) => { if (idx > 0) set.add(t); });\r\n  }\r\n  return set.size;\r\n}\r\n\r\nexport function computeOpeningStats(\r\n  text: string,\r\n  firstSentenceSpans: readonly { start: number; end: number; text: string }[],\r\n  nlpDocOrNull: any | null\r\n): OpeningStats {\r\n  const words = (text || '').trim().split(/\\s+/).filter(Boolean);\r\n  const head = words.slice(0, 150).join(' ');\r\n  const tokenCount150 = Math.min(words.length, 150);\r\n  const avgSentenceLen = (() => {\r\n    const consider = firstSentenceSpans.slice(0, Math.min(3, firstSentenceSpans.length));\r\n    if (!consider.length) return 0;\r\n    const totals = consider.map(s => (s.text.split(/\\s+/).filter(Boolean).length));\r\n    return Math.round((totals.reduce((a, b) => a + b, 0) / consider.length) * 10) / 10;\r\n  })();\r\n  const dialogueRatio = (() => {\r\n    const lines = head.split(/\\r?\\n/).filter(l => l.trim().length > 0);\r\n    if (!lines.length) return 0;\r\n    const dlg = lines.filter(l => /^[\"“]/.test(l.trim()) || /\\bsaid\\b/i.test(l) || /\\.\\.\\./.test(l));\r\n    return Math.round((dlg.length / lines.length) * 100) / 100;\r\n  })();\r\n  const namedEntities = (() => {\r\n    try { return Array.isArray(nlpDocOrNull?.people?.().out?.('array')) ? (nlpDocOrNull.people().out('array') as string[]).length : (head.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+\\b/g) ?? []).length; }\r\n    catch { return (head.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+\\b/g) ?? []).length; }\r\n  })();\r\n  const adverbs = (head.match(/\\b\\w+ly\\b/g) ?? []).length;\r\n  const adjectives = (() => {\r\n    try { const n = nlpDocOrNull?.adjectives?.()?.out?.('array'); if (Array.isArray(n)) return n.length; } catch {/*noop*/}\r\n    const toks = head.toLowerCase().match(/\\b[a-z]{3,}\\b/g) ?? [];\r\n    return toks.reduce((c, w) => c + (ADJ_WORDS.has(w) ? 1 : 0), 0);\r\n  })();\r\n  const uniqueProperNouns2 = uniqueProperInSentences(text, firstSentenceSpans, 2);\r\n  return { tokenCount150, avgSentenceLen, dialogueRatio, namedEntities, adverbs, adjectives, uniqueProperNouns2 };\r\n}\r\n\r\nexport function summarizePreviousContext(previousScenes: readonly Scene[]): PreviousSummary {\r\n  const joined = previousScenes.map(s => s.text || '').join('\\n').slice(0, 5000);\r\n  const characters = (() => {\r\n    try {\r\n      // Attempt compromise if available\r\n       \r\n      const mod = require('compromise');\r\n      const nlp = (mod?.default ?? mod) as any;\r\n      const doc = typeof nlp === 'function' ? nlp(joined) : null;\r\n      const arr: string[] = doc?.people?.()?.out?.('array') ?? [];\r\n      const uniq = Array.from(new Set(arr.map(s => String(s).trim()).filter(Boolean)));\r\n      return uniq.slice(0, 6);\r\n    } catch {\r\n      const m = joined.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+\\b/g) ?? [];\r\n      const uniq = Array.from(new Set(m));\r\n      return uniq.slice(0, 6);\r\n    }\r\n  })();\r\n  const keyTerms = (() => {\r\n    const caps = (joined.match(/\\b[A-Z][a-z]+\\b/g) ?? []).map(s => s.trim());\r\n    const stop = new Set(['The','A','An','And','But','Or','If','Then','When','While','After','Before']);\r\n    const freq = new Map<string, number>();\r\n    for (const t of caps) {\r\n      if (stop.has(t)) continue;\r\n      freq.set(t, (freq.get(t) ?? 0) + 1);\r\n    }\r\n    return Array.from(freq.entries()).sort((a,b)=>b[1]-a[1]).slice(0,5).map(e=>e[0]);\r\n  })();\r\n  return { characters, keyTerms };\r\n}\r\n\r\nexport function buildEngagementDetectionTarget(\r\n  scene: Scene,\r\n  previousScenes: readonly Scene[],\r\n  stats: OpeningStats,\r\n  sentences: readonly { start: number; end: number; text: string }[]\r\n): EngagementDetectionTarget {\r\n  const hookLine = extractHookLine(scene.text || '');\r\n  const firstSentences = sentences.slice(0, 3).map(s => s.text.trim());\r\n  const contextWindow = (scene.text || '').slice(0, 900);\r\n  const previousSummary = summarizePreviousContext(previousScenes);\r\n  return { hookLine, firstSentences, contextWindow, openingStats: stats, previousSummary };\r\n}\r\n\r\nfunction findHookSpan(sceneText: string, hookLine: string): [number, number] {\r\n  const trimmed = (hookLine || '').trim();\r\n  if (!trimmed) return [0, Math.min(sceneText.length, 1)];\r\n  const idx = sceneText.indexOf(trimmed);\r\n  if (idx >= 0) return [idx, idx + trimmed.length];\r\n  return [0, Math.min(sceneText.length, Math.max(1, trimmed.length))];\r\n}\r\n\r\nfunction deriveSeverity(desc?: string): ContinuityIssue['severity'] {\r\n  const d = (desc || '').toLowerCase();\r\n  if (/(no|weak)\\s+hook|no\\s+conflict|los(e|ing)\\s+reader|very\\s+slow\\s+pacing/.test(d)) return 'must-fix';\r\n  if (/moderate|somewhat\\s+slow|dense\\s+exposition|confusing\\s+load|could\\s+be\\s+tighter/.test(d)) return 'should-fix';\r\n  return 'consider';\r\n}\r\n\r\nfunction mapAIEngagementIssues(\r\n  resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n  sceneText: string,\r\n  hookLine: string\r\n): ContinuityIssue[] {\r\n  const out: ContinuityIssue[] = [];\r\n  const fallbackSpan = findHookSpan(sceneText, hookLine);\r\n  for (const it of resp?.issues ?? []) {\r\n    const hasSpan = Array.isArray(it.textSpan) && Number.isFinite(it.textSpan[0]) && Number.isFinite(it.textSpan[1]);\r\n    out.push({\r\n      type: 'engagement',\r\n      severity: (it.severity as any) || deriveSeverity(it.description),\r\n      description: it.description ?? 'Engagement issue detected in opening.',\r\n      textSpan: (hasSpan ? (it.textSpan as [number, number]) : fallbackSpan),\r\n      suggestedFix: it.suggestedFix\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction buildReaderContextFromSummary(sum: PreviousSummary) {\r\n  return {\r\n    knownCharacters: new Set(sum.characters),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: []\r\n  };\r\n}\r\n\r\nfunction buildAIHeader(scene: Scene, cand: EngagementDetectionTarget): string {\r\n  const s = cand.openingStats;\r\n  const parts: string[] = [];\r\n  parts.push('[[Engagement assessment request]]');\r\n  parts.push(`scene: id=${scene.id} pos=${scene.position}`);\r\n  parts.push(`hook: \"${cand.hookLine.slice(0, 160).replace(/\\n+/g, ' ')}\"`);\r\n  parts.push(`openingStats: token150=${s.tokenCount150} avgSentLen=${s.avgSentenceLen} dialogRatio=${s.dialogueRatio} ents=${s.namedEntities} adv=${s.adverbs} adj=${s.adjectives} proper2=${s.uniqueProperNouns2}`);\r\n  parts.push('Assess:');\r\n  parts.push('- Opening hook clarity/strength');\r\n  parts.push('- Early tension/conflict presence');\r\n  parts.push('- Pacing in first ~700–900 chars');\r\n  parts.push('- Character introduction load and clarity');\r\n  const chars = cand.previousSummary.characters.join(', ');\r\n  const terms = cand.previousSummary.keyTerms.join(', ');\r\n  parts.push(`prevContext: chars=[${chars}] key=[${terms}]`);\r\n  return parts.join('\\n');\r\n}\r\n\r\nexport default class EngagementDetector extends BaseDetector<EngagementDetectionTarget> {\r\n  public readonly detectorType = 'engagement' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<EngagementDetectionTarget>> {\r\n    if (!scene?.text || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n    const doc = await this.safeNLP(scene.text);\r\n    const sentences = splitSentences(scene.text);\r\n    const stats = computeOpeningStats(scene.text, sentences, doc);\r\n    const target = buildEngagementDetectionTarget(scene, previousScenes, stats, sentences);\r\n    const targets = target.hookLine ? [target] : [];\r\n    console.debug('[EngagementDetector] stats/target:', { stats, hasTarget: targets.length > 0 });\r\n    return {\r\n      issues: [],\r\n      requiresAI: targets.length > 0,\r\n      targets,\r\n      stats: stats as unknown as Record<string, number>\r\n    };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly EngagementDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n    const cand = targets[0];\r\n    try {\r\n      const header = buildAIHeader(scene, cand);\r\n      const body: string[] = [];\r\n      body.push('[[First sentences]]');\r\n      for (const s of cand.firstSentences) body.push(`- ${s}`);\r\n      body.push('[[Scene context (~900 chars)]]');\r\n      body.push(cand.contextWindow);\r\n      const textPayload = `${header}\\n\\n${body.join('\\n')}`;\r\n      const lastPrev = previousScenes.slice(-1).map(s => ({ ...s, text: (s.text ?? '').slice(0, 600) }));\r\n      const baseReq = {\r\n        scene: { ...scene, text: textPayload },\r\n        previousScenes: lastPrev as Scene[],\r\n        analysisType: 'full' as const,\r\n        readerContext: buildReaderContextFromSummary(cand.previousSummary)\r\n      } as Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\n      const enriched = enrichAnalysisRequest(baseReq as any, {\r\n        scene,\r\n        detectorType: 'engagement',\r\n        flags: { critical: Boolean((scene as any)?.critical) },\r\n      });\r\n\r\n      console.debug('[EngagementDetector] invoking AI (full) for detection targets');\r\n      const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n\r\n      const out = mapAIEngagementIssues({ issues }, scene.text, cand.hookLine);\r\n      console.debug('[EngagementDetector] AI returned engagement issues:', out.length);\r\n      return out;\r\n    } catch (err) {\r\n      console.debug('[EngagementDetector] AI analyzeContinuity failed; returning empty.', err);\r\n      return [];\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\IssueAggregator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\PlotContextDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\PronounDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\TimelineDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sceneText' is defined but never used. Allowed unused args must match /^_/u.","line":372,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":372,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\n// ---------- Types (exported testing hooks) ----------\r\nexport interface SentenceSpan { text: string; start: number; end: number }\r\n\r\nexport interface BasicMarker {\r\n  text: string;\r\n  start: number;\r\n  end: number;\r\n  sentenceIndex: number;\r\n}\r\n\r\ntype MarkerCategory =\r\n  | 'relative'\r\n  | 'absolute'\r\n  | 'time'\r\n  | 'season'\r\n  | 'weekday'\r\n  | 'holiday'\r\n  | 'sequence'\r\n  | 'month';\r\n\r\ninterface TemporalMarker extends BasicMarker {\r\n  category: MarkerCategory;\r\n  normalized?: string;\r\n  deltaDays?: number | null;\r\n  anchor?: 'morning' | 'afternoon' | 'evening' | 'night' | 'day';\r\n}\r\n\r\nexport interface PreviousTimelineRegistry {\r\n  lastAnchor: string | null;\r\n  lastDayOffset: number | null; // approximate cumulative day offset\r\n  seasons: Set<string>; // e.g., winter, summer\r\n  months: Set<string>; // e.g., january\r\n  recentSequences: string[]; // e.g., then, after that\r\n  hasMeanwhile: boolean;\r\n}\r\n\r\nexport interface TimelineDetectionTarget {\r\n  markerText: string;\r\n  sentenceText: string;\r\n  context: string;\r\n  start: number;\r\n  end: number;\r\n  prevSummary: { lastAnchor: string | null; lastDayOffset: number | null; seasons: string[]; months: string[] };\r\n  otherMarkers: string[];\r\n  sentenceIndex: number;\r\n}\r\n\r\n// ---------- Constants ----------\r\nconst MONTHS = [\r\n  'january','february','march','april','may','june','july','august','september','october','november','december'\r\n];\r\nconst WEEKDAYS = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];\r\nconst SEASONS = ['spring','summer','fall','autumn','winter'];\r\nconst HOLIDAYS = ['christmas','new year','new year\\'s','easter','thanksgiving','halloween','hanukkah','ramadan','diwali'];\r\nconst TIME_OF_DAY = ['dawn','morning','noon','afternoon','dusk','evening','midnight','night','tonight'];\r\nconst SEQUENCE_TERMS = ['then','after that','later that day','soon after','meanwhile','at the same time','moments later'];\r\n\r\nconst RELATIVE_TERMS = [\r\n  'next day','the following day','tomorrow','yesterday','earlier that day','that night','tonight',\r\n  'the previous night','next morning','this morning','last night','later that day'\r\n];\r\n\r\nconst WEATHER_SEASONAL = ['snow','blizzard','sleet','heatwave','scorching','sweltering','icy','frost','hail'];\r\n\r\n// ---------- Module cache ----------\r\nconst registryCache: Map<string, PreviousTimelineRegistry> = new Map();\r\n\r\n// ---------- Small utilities (&#x2264; 40 lines) ----------\r\nfunction sig(previous: readonly Scene[]): string {\r\n  return previous.map(s => s.id).join('|');\r\n}\r\n\r\nfunction clamp(n: number, a: number, b: number): number {\r\n  return Math.max(a, Math.min(b, n));\r\n}\r\n\r\nfunction snippet(text: string, start: number, end: number, r = 120): string {\r\n  const s = clamp(start - r, 0, text.length);\r\n  const e = clamp(end + r, 0, text.length);\r\n  return text.slice(s, e).trim();\r\n}\r\n\r\nfunction monthToSeason(month: string): string | null {\r\n  const m = month.toLowerCase();\r\n  if (['december','january','february'].includes(m)) return 'winter';\r\n  if (['march','april','may'].includes(m)) return 'spring';\r\n  if (['june','july','august'].includes(m)) return 'summer';\r\n  if (['september','october','november'].includes(m)) return 'fall';\r\n  return null;\r\n}\r\n\r\nexport function computeRelativeDelta(phrase: string): number | null {\r\n  const low = phrase.toLowerCase();\r\n  const numMatch = /(\\d+)\\s+(day|week|month|year)s?\\s+(later|earlier|before|after)/i.exec(low);\r\n  if (numMatch) {\r\n    const n = parseInt(numMatch[1], 10);\r\n    const unit = numMatch[2];\r\n    const dir = numMatch[3];\r\n    const mult = unit === 'day' ? 1 : unit === 'week' ? 7 : unit === 'month' ? 30 : 365;\r\n    const sign = (dir === 'later' || dir === 'after') ? 1 : -1;\r\n    return sign * n * mult;\r\n  }\r\n  if (/\\b(next day|the following day|tomorrow|next morning)\\b/i.test(low)) return 1;\r\n  if (/\\b(previous day|yesterday|the previous night|last night)\\b/i.test(low)) return -1;\r\n  if (/\\b(earlier that day|that night|tonight|this morning|later that day)\\b/i.test(low)) return 0;\r\n  return null;\r\n}\r\n\r\nfunction anchorFromPhrase(phrase: string): TemporalMarker['anchor'] | undefined {\r\n  const low = phrase.toLowerCase();\r\n  if (low.includes('morning') || low.includes('dawn') || low.includes('this morning') || low.includes('next morning')) return 'morning';\r\n  if (low.includes('afternoon') || low.includes('noon')) return 'afternoon';\r\n  if (low.includes('evening') || low.includes('dusk')) return 'evening';\r\n  if (low.includes('night') || low.includes('midnight') || low.includes('tonight') || low.includes('last night')) return 'night';\r\n  return undefined;\r\n}\r\n\r\nexport function splitSentences(text: string): SentenceSpan[] {\r\n  const spans: SentenceSpan[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|\\n+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      const raw = text.slice(m.index, m.index + m[0].length);\r\n      spans.push({ text: raw.trim(), start: m.index, end: m.index + m[0].length });\r\n    }\r\n  } catch { /* noop */ }\r\n  if (spans.length === 0) spans.push({ text: text, start: 0, end: text.length });\r\n  return spans;\r\n}\r\n\r\nfunction sentenceIndexFor(pos: number, sentences: readonly SentenceSpan[]): number {\r\n  let lo = 0, hi = sentences.length - 1, ans = 0;\r\n  while (lo <= hi) {\r\n    const mid = (lo + hi) >> 1;\r\n    const s = sentences[mid];\r\n    if (pos < s.start) hi = mid - 1;\r\n    else if (pos >= s.end) lo = mid + 1;\r\n    else { ans = mid; break; }\r\n  }\r\n  return ans;\r\n}\r\n\r\n// ---------- Marker extraction (compromise + regex) ----------\r\nfunction pushMatch(\r\n  arr: TemporalMarker[],\r\n  text: string,\r\n  start: number,\r\n  end: number,\r\n  sentences: readonly SentenceSpan[],\r\n  category: MarkerCategory\r\n): void {\r\n  const si = sentenceIndexFor(start, sentences);\r\n  const phrase = text.slice(start, end);\r\n  arr.push({\r\n    text: phrase,\r\n    start,\r\n    end,\r\n    sentenceIndex: si,\r\n    category,\r\n    deltaDays: category === 'relative' ? computeRelativeDelta(phrase) : null,\r\n    anchor: category === 'relative' || category === 'time' ? anchorFromPhrase(phrase) : undefined,\r\n  });\r\n}\r\n\r\nfunction regexFindAll(text: string, re: RegExp, sentences: readonly SentenceSpan[], cat: MarkerCategory, out: TemporalMarker[]) {\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text)) !== null) {\r\n    const s = m.index;\r\n    const e = s + m[0].length;\r\n    pushMatch(out, text, s, e, sentences, cat);\r\n  }\r\n}\r\n\r\nfunction extractWithCompromise(doc: any | null, text: string, sentences: readonly SentenceSpan[]): TemporalMarker[] {\r\n  const out: TemporalMarker[] = [];\r\n  if (!doc) return out;\r\n  try {\r\n    const toArr = (sel: any): string[] => (sel && typeof sel.out === 'function') ? (sel.out('array') ?? []) : [];\r\n    const datePhrases: string[] = toArr(doc.match ? doc.match('#Date') : null).concat(toArr(doc.dates ? doc.dates() : null));\r\n    const timePhrases: string[] = toArr(doc.match ? doc.match('#Time') : null);\r\n    const seen = new Set<string>();\r\n    const addStrings = (phrases: string[], cat: MarkerCategory) => {\r\n      for (const p of phrases) {\r\n        const phrase = (p || '').toString().trim();\r\n        if (!phrase) continue;\r\n        if (seen.has(`${cat}|${phrase}`)) continue;\r\n        seen.add(`${cat}|${phrase}`);\r\n        // search within each sentence to avoid duping earlier matches\r\n        for (const s of sentences) {\r\n          const relIdx = s.text.indexOf(phrase);\r\n          if (relIdx >= 0) {\r\n            const start = s.start + relIdx;\r\n            const end = start + phrase.length;\r\n            pushMatch(out, text, start, end, sentences, cat);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    addStrings(datePhrases, 'absolute');\r\n    addStrings(timePhrases, 'time');\r\n    return out;\r\n  } catch {\r\n    return out;\r\n  }\r\n}\r\n\r\nexport function extractTemporalMarkers(\r\n  sceneText: string,\r\n  doc: any | null = null\r\n): { markers: BasicMarker[]; sentences: SentenceSpan[] } {\r\n  if (!sceneText || typeof sceneText !== 'string') return { markers: [], sentences: [{ text: '', start: 0, end: 0 }] };\r\n  const sentences = splitSentences(sceneText);\r\n  const tmp: TemporalMarker[] = [];\r\n  // Compromise-based\r\n  const comp = extractWithCompromise(doc, sceneText, sentences);\r\n  tmp.push(...comp);\r\n  // Regex-based relative amounts\r\n  regexFindAll(sceneText, /\\b(\\d+)\\s+(?:day|week|month|year)s?\\s+(?:later|earlier|before|after)\\b/gi, sentences, 'relative', tmp);\r\n  // Simple relative terms\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + RELATIVE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'relative', tmp);\r\n  // Sequence terms\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + SEQUENCE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'sequence', tmp);\r\n  // Absolute months, weekdays, seasons, holidays, time-of-day, weather\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + MONTHS.join('|') + ')\\\\b', 'gi'), sentences, 'month', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + WEEKDAYS.join('|') + ')\\\\b', 'gi'), sentences, 'weekday', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + SEASONS.join('|') + ')\\\\b', 'gi'), sentences, 'season', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + HOLIDAYS.join('|') + ')\\\\b', 'gi'), sentences, 'holiday', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + TIME_OF_DAY.join('|') + ')\\\\b', 'gi'), sentences, 'time', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + WEATHER_SEASONAL.join('|') + ')\\\\b', 'gi'), sentences, 'season', tmp);\r\n  // Return as BasicMarker list (testing contract)\r\n  const basics: BasicMarker[] = tmp.map(m => ({ text: m.text, start: m.start, end: m.end, sentenceIndex: m.sentenceIndex }));\r\n  return { markers: basics, sentences };\r\n}\r\n\r\n// ---------- Previous registry builder + caching ----------\r\nfunction getOrBuildRegistry(previous: readonly Scene[]): PreviousTimelineRegistry {\r\n  const s = sig(previous);\r\n  const c = registryCache.get(s);\r\n  if (c) return c;\r\n  const reg = buildPreviousTimelineRegistry(previous);\r\n  registryCache.set(s, reg);\r\n  return reg;\r\n}\r\n\r\nexport function buildPreviousTimelineRegistry(previousScenes: readonly Scene[]): PreviousTimelineRegistry {\r\n  const seasons = new Set<string>();\r\n  const months = new Set<string>();\r\n  const recentSequences: string[] = [];\r\n  let lastAnchor: string | null = null;\r\n  let cumOffset = 0;\r\n  let hasMeanwhile = false;\r\n\r\n  for (const sc of previousScenes) {\r\n    const text = sc.text ?? '';\r\n    const sentences = splitSentences(text);\r\n    const markers = extractWithCompromise(null, text, sentences);\r\n    // Regex fallback markers too\r\n    const all: TemporalMarker[] = [];\r\n    all.push(...markers);\r\n    regexFindAll(text, /\\b(\\d+)\\s+(?:day|week|month|year)s?\\s+(?:later|earlier|before|after)\\b/gi, sentences, 'relative', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + RELATIVE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'relative', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + SEQUENCE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'sequence', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + MONTHS.join('|') + ')\\\\b', 'gi'), sentences, 'month', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + SEASONS.join('|') + ')\\\\b', 'gi'), sentences, 'season', all);\r\n    for (const m of all) {\r\n      if (m.category === 'relative' && m.deltaDays != null) {\r\n        cumOffset += m.deltaDays;\r\n        if (m.anchor) lastAnchor = m.anchor;\r\n      }\r\n      if (m.category === 'time' && m.anchor) lastAnchor = m.anchor;\r\n      if (m.category === 'season') seasons.add(m.text.toLowerCase().replace('autumn', 'fall'));\r\n      if (m.category === 'month') {\r\n        const mon = m.text.toLowerCase();\r\n        months.add(mon);\r\n        const seas = monthToSeason(mon);\r\n        if (seas) seasons.add(seas);\r\n      }\r\n      if (m.category === 'sequence') {\r\n        const low = m.text.toLowerCase();\r\n        recentSequences.push(low);\r\n        if (low.includes('meanwhile') || low.includes('at the same time')) hasMeanwhile = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    lastAnchor,\r\n    lastDayOffset: Number.isNaN(cumOffset) ? null : cumOffset,\r\n    seasons,\r\n    months,\r\n    recentSequences: recentSequences.slice(-20),\r\n    hasMeanwhile,\r\n  };\r\n}\r\n\r\n// ---------- Detection target assembly (exported) ----------\r\nexport function assembleTimelineDetectionTargets(\r\n  markers: readonly BasicMarker[],\r\n  sceneText: string,\r\n  sentences: readonly SentenceSpan[],\r\n  reg: PreviousTimelineRegistry\r\n): TimelineDetectionTarget[] {\r\n  const lowMarkers = markers.map(m => ({ ...m, low: m.text.toLowerCase() }));\r\n  const otherTexts = (skipIdx: number) =>\r\n    lowMarkers.filter((_, i) => i !== skipIdx).slice(0, 6).map(mm => mm.text);\r\n\r\n  const targets: TimelineDetectionTarget[] = [];\r\n  const hasMeanwhile = lowMarkers.some(m => m.low.includes('meanwhile') || m.low.includes('at the same time'));\r\n  const relativeCount = lowMarkers.filter(m => /\\b(day|week|month|year|morning|night|yesterday|tomorrow|earlier|later)\\b/.test(m.low)).length;\r\n\r\n  for (let i = 0; i < lowMarkers.length; i++) {\r\n    const m = lowMarkers[i];\r\n    const isAmbiguousSeason =\r\n      (SEASONS.some(s => m.low.includes(s)) && reg.months.size > 0) ||\r\n      (MONTHS.some(mon => m.low.includes(mon)) && reg.seasons.size > 0);\r\n\r\n    const triggers =\r\n      hasMeanwhile ||\r\n      relativeCount >= 2 ||\r\n      isAmbiguousSeason ||\r\n      /\\bearlier that day\\b/.test(m.low);\r\n\r\n    if (!triggers) continue;\r\n\r\n    const sent = sentences[m.sentenceIndex]?.text ?? '';\r\n    targets.push({\r\n      markerText: m.text,\r\n      sentenceText: sent,\r\n      context: snippet(sceneText, m.start, m.end),\r\n      start: m.start,\r\n      end: m.end,\r\n      prevSummary: {\r\n        lastAnchor: reg.lastAnchor,\r\n        lastDayOffset: reg.lastDayOffset,\r\n        seasons: Array.from(reg.seasons).slice(0, 6),\r\n        months: Array.from(reg.months).slice(0, 6),\r\n      },\r\n      otherMarkers: otherTexts(i),\r\n      sentenceIndex: m.sentenceIndex,\r\n    });\r\n  }\r\n  return targets;\r\n}\r\n\r\n// ---------- Local conflict detection ----------\r\nfunction seasonBucketSet(markers: readonly BasicMarker[]): Set<string> {\r\n  const set = new Set<string>();\r\n  for (const m of markers) {\r\n    const low = m.text.toLowerCase();\r\n    for (const s of SEASONS) if (low.includes(s)) set.add(s === 'autumn' ? 'fall' : s);\r\n    for (const mon of MONTHS) if (low.includes(mon)) {\r\n      const sb = monthToSeason(mon); if (sb) set.add(sb);\r\n    }\r\n    for (const w of WEATHER_SEASONAL) if (low.includes(w)) {\r\n      if (['snow','blizzard','sleet','icy','frost','hail'].some(x => low.includes(x))) set.add('winter');\r\n      if (['heatwave','scorching','sweltering'].some(x => low.includes(x))) set.add('summer');\r\n    }\r\n  }\r\n  return set;\r\n}\r\n\r\nfunction detectTimelineIssues(\r\n  markers: readonly BasicMarker[],\r\n  reg: PreviousTimelineRegistry,\r\n  sceneText: string\r\n): ContinuityIssue[] {\r\n  const issues: ContinuityIssue[] = [];\r\n  const lowMarks = markers.map(m => ({ ...m, low: m.text.toLowerCase() }));\r\n  const hasEarlierToday = lowMarks.some(m => m.low.includes('earlier that day'));\r\n  const hasNextMorning = lowMarks.some(m => m.low.includes('next morning'));\r\n  const hasMultiDayJump = lowMarks.some(m => /(\\d+)\\s+(day|week|month|year)s?\\s+(later|after)/.test(m.low));\r\n  const curSeasons = seasonBucketSet(markers);\r\n\r\n  // Hard contradiction: \"earlier that day\" but previous indicates we're past same-day context\r\n  if (hasEarlierToday && (reg.lastDayOffset !== null && reg.lastDayOffset > 0)) {\r\n    const m = lowMarks.find(x => x.low.includes('earlier that day'))!;\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'must-fix',\r\n      description: 'Temporal rewind: \"earlier that day\" after prior scenes advanced beyond same-day.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  // Likely gap: large jump while recent threads suggest simultaneity\r\n  if (reg.hasMeanwhile && hasMultiDayJump) {\r\n    const m = lowMarks.find(x => /(\\d+)\\s+(day|week|month|year)s?\\s+(later|after)/.test(x.low))!;\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'should-fix',\r\n      description: 'Potential gap: multi-day jump despite ongoing \"meanwhile\" threads in prior scenes.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  // Soft contradiction: \"next morning\" after cumulative offset suggests longer gap context\r\n  if (hasNextMorning && (reg.lastDayOffset !== null && reg.lastDayOffset >= 2)) {\r\n    const m = lowMarks.find(x => x.low.includes('next morning'))!;\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'should-fix',\r\n      description: 'Possible misalignment: \"next morning\" but earlier scenes imply a multi-day gap.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  // Seasonal inconsistency\r\n  const prevSeasons = new Set(Array.from(reg.seasons));\r\n  const winterPrev = prevSeasons.has('winter');\r\n  const summerPrev = prevSeasons.has('summer');\r\n  const winterCur = curSeasons.has('winter');\r\n  const summerCur = curSeasons.has('summer');\r\n\r\n  if ((winterPrev && summerCur) || (summerPrev && winterCur)) {\r\n    const m = lowMarks.find(x => seasonBucketSet([x]).size > 0) ?? lowMarks[0];\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'should-fix',\r\n      description: 'Seasonal inconsistency: prior scenes indicate different season without transition.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  } else if (curSeasons.size && prevSeasons.size && Array.from(curSeasons).some(s => !prevSeasons.has(s))) {\r\n    const m = lowMarks.find(x => seasonBucketSet([x]).size > 0) ?? lowMarks[0];\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'consider',\r\n      description: 'Seasonal drift detected; consider adding transition context.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n// ---------- AI request helpers ----------\r\nfunction buildReaderContextMinimal(): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\nfunction buildAIHeader(scene: Scene, targets: readonly TimelineDetectionTarget[], reg: PreviousTimelineRegistry): string {\r\n  const lines: string[] = [];\r\n  lines.push('[[Timeline detection targets]]');\r\n  lines.push(`scene: id=${scene.id} pos=${scene.position}`);\r\n  for (const c of targets.slice(0, 8)) {\r\n    const sent = (c.sentenceText || '').slice(0, 140).replace(/\\n+/g, ' ');\r\n    const others = c.otherMarkers.slice(0, 6).join(' | ') || 'none';\r\n    lines.push(`- marker=\"${c.markerText}\" span=[${c.start},${c.end}] sent=\"${sent}\" localMarkers=[${others}]`);\r\n  }\r\n  lines.push('[[Previous registry]]');\r\n  lines.push(`lastAnchor=${reg.lastAnchor ?? 'none'} lastDayOffset=${reg.lastDayOffset ?? 'n/a'}`);\r\n  lines.push(`seasons: ${Array.from(reg.seasons).slice(0, 8).join(' | ')}`);\r\n  lines.push(`months: ${Array.from(reg.months).slice(0, 8).join(' | ')}`);\r\n  lines.push('[[Scene excerpt]]');\r\n  return lines.join('\\n');\r\n}\r\n\r\nfunction buildSceneExcerptAroundTargets(text: string, targets: readonly TimelineDetectionTarget[], maxLen = 1200): string {\r\n  if (!targets.length) return text.slice(0, maxLen);\r\n  const parts: string[] = [];\r\n  for (const c of targets) {\r\n    parts.push(snippet(text, c.start, c.end, 220));\r\n    const len = parts.join('\\n---\\n').length;\r\n    if (len > maxLen) break;\r\n  }\r\n  return parts.join('\\n---\\n').slice(0, maxLen);\r\n}\r\n\r\nfunction mapAITimelineIssues(\r\n  resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n  sceneText: string,\r\n  targets: readonly TimelineDetectionTarget[]\r\n): ContinuityIssue[] {\r\n  const out: ContinuityIssue[] = [];\r\n  const byMarker = new Map<string, TimelineDetectionTarget>();\r\n  for (const c of targets) byMarker.set(c.markerText.toLowerCase(), c);\r\n \r\n  for (const it of resp?.issues ?? []) {\r\n    if ((it.type ?? 'timeline') !== 'timeline') continue;\r\n    const hasSpan = Array.isArray(it.textSpan) && Number.isFinite(it.textSpan[0]) && Number.isFinite(it.textSpan[1]);\r\n    if (hasSpan) {\r\n      out.push({\r\n        type: 'timeline',\r\n        severity: it.severity ?? 'should-fix',\r\n        description: it.description ?? 'Timeline consistency issue',\r\n        textSpan: it.textSpan as [number, number],\r\n        suggestedFix: it.suggestedFix,\r\n      });\r\n      continue;\r\n    }\r\n    // Fallback to closest detection target by marker mention\r\n    const key = (it.description ?? '').toLowerCase();\r\n    let chosen: TimelineDetectionTarget | undefined;\r\n    for (const [mk, c] of byMarker) { if (key.includes(mk)) { chosen = c; break; } }\r\n    chosen ??= targets[0];\r\n    const span: [number, number] = chosen ? [chosen.start, chosen.end] : [0, Math.min(1, sceneText.length)];\r\n    out.push({\r\n      type: 'timeline',\r\n      severity: it.severity ?? 'should-fix',\r\n      description: it.description ?? `Timeline issue near \"${chosen?.markerText ?? 'marker'}\"`,\r\n      textSpan: span,\r\n      suggestedFix: it.suggestedFix,\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\n// ---------- Detector implementation ----------\r\nexport default class TimelineDetector extends BaseDetector<TimelineDetectionTarget> {\r\n  public readonly detectorType = 'timeline' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<TimelineDetectionTarget>> {\r\n    if (!scene?.text || typeof scene.text !== 'string' || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n \r\n    const doc = await this.safeNLP(scene.text);\r\n    if (!doc) console.debug('[TimelineDetector] compromise not available, using regex-only fallback.');\r\n    const sentences = splitSentences(scene.text);\r\n    const extracted = extractTemporalMarkers(scene.text, doc);\r\n    const basicMarkers = extracted.markers;\r\n    const reg = getOrBuildRegistry(previousScenes);\r\n \r\n    if (basicMarkers.length === 0 && reg.seasons.size === 0 && reg.months.size === 0 && reg.lastDayOffset === null) {\r\n      console.debug('[TimelineDetector] Fast path: no markers and empty registry.');\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n \r\n    const issues = detectTimelineIssues(basicMarkers, reg, scene.text);\r\n    const targets = assembleTimelineDetectionTargets(basicMarkers, scene.text, sentences, reg);\r\n \r\n    console.debug(\r\n      '[TimelineDetector] markers:',\r\n      basicMarkers.length,\r\n      'issues:',\r\n      issues.length,\r\n      'targets:',\r\n      targets.length,\r\n      'reg[lastAnchor,lastDayOffset,seasons,months]:',\r\n      reg.lastAnchor,\r\n      reg.lastDayOffset,\r\n      Array.from(reg.seasons).join(','),\r\n      Array.from(reg.months).join(',')\r\n    );\r\n \r\n    return {\r\n      issues,\r\n      requiresAI: targets.length > 0,\r\n      targets,\r\n      stats: {\r\n        markers: basicMarkers.length,\r\n        seasonsCurrent: seasonBucketSet(basicMarkers).size,\r\n        hasMeanwhilePrev: reg.hasMeanwhile ? 1 : 0,\r\n        targets: targets.length,\r\n      },\r\n    };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly TimelineDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n    try {\r\n      const reg = getOrBuildRegistry(previousScenes);\r\n      const header = buildAIHeader(scene, targets, reg);\r\n      const excerpt = buildSceneExcerptAroundTargets(scene.text, targets, 1200);\r\n      const prevExcerpt = previousScenes.length\r\n        ? [{ ...previousScenes[previousScenes.length - 1], text: (previousScenes[previousScenes.length - 1].text ?? '').slice(0, 700) }]\r\n        : [];\r\n\r\n      const baseReq = {\r\n        scene: { ...scene, text: `${header}\\n\\n${excerpt}` },\r\n        previousScenes: prevExcerpt as Scene[],\r\n        analysisType: 'consistency' as const,\r\n        readerContext: buildReaderContextMinimal(),\r\n      } as Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\n      const enriched = enrichAnalysisRequest(baseReq as any, {\r\n        scene,\r\n        detectorType: 'timeline',\r\n        flags: { critical: Boolean((scene as any)?.critical) },\r\n      });\r\n\r\n      console.debug('[TimelineDetector] invoking AI (consistency) for targets:', targets.length);\r\n      const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n\r\n      const out = mapAITimelineIssues({ issues }, scene.text, targets);\r\n      console.debug('[TimelineDetector] AI returned timeline issues:', out.length);\r\n      return out;\r\n    } catch (err) {\r\n      console.debug('[TimelineDetector] AI analyzeContinuity failed; degrading to local-only.', err);\r\n      return [];\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\hooks\\useAnalysis.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\hooks\\useIssueHighlighting.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\services\\ContinuityAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\stores\\analysisStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\export\\__tests__\\ExportDialog.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\export\\components\\ExportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\reorder\\SceneReorderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\RewriteProgress.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\RewriteStats.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\batchStore.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'vi' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, beforeEach, expect, vi } from 'vitest';\r\nimport useRewriteStore from '../stores/rewriteStore';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport type { Manuscript, Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport type { BatchRewriteProgress, BatchRewriteOptions } from '../../../../services/rewrite/RewriteOrchestrator';\r\nimport type { RewriteResult } from '../../../../services/rewrite/SceneRewriter';\r\n\r\nfunction buildIssue(): ContinuityIssue {\r\n  return {\r\n    type: 'pronoun',\r\n    severity: 'must-fix',\r\n    description: 'Ambiguous pronoun reference',\r\n    textSpan: [0, 5],\r\n    suggestedFix: 'Clarify subject'\r\n  };\r\n}\r\n\r\nfunction buildScene(id: string, position: number): Scene {\r\n  const readerContext: ReaderKnowledge = {\r\n    knownCharacters: new Set(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: []\r\n  };\r\n\r\n  return {\r\n    id,\r\n    text: `Original ${id}`,\r\n    wordCount: 2,\r\n    position,\r\n    originalPosition: position,\r\n    characters: [],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: true,\r\n    rewriteStatus: 'pending',\r\n    continuityAnalysis: {\r\n      issues: [buildIssue()],\r\n      timestamp: Date.now(),\r\n      modelUsed: 'test',\r\n      confidence: 0.9,\r\n      readerContext\r\n    }\r\n  };\r\n}\r\n\r\nfunction buildManuscript(ids: string[]): Manuscript {\r\n  const scenes = ids.map((id, idx) => buildScene(id, idx));\r\n  return {\r\n    id: 'm-batch',\r\n    title: 'Batch Manuscript',\r\n    scenes,\r\n    originalOrder: scenes.map(s => s.id),\r\n    currentOrder: scenes.map(s => s.id)\r\n  };\r\n}\r\n\r\nclass OrchestratorFake {\r\n  cancelled = false;\r\n\r\n  cancelBatch() {\r\n    this.cancelled = true;\r\n  }\r\n\r\n  async rewriteMovedScenes(\r\n    manuscript: Pick<Manuscript, 'scenes' | 'currentOrder'>,\r\n    options: BatchRewriteOptions = {}\r\n  ): Promise<BatchRewriteProgress> {\r\n    const sceneIds = manuscript.currentOrder;\r\n\r\n    const progress: BatchRewriteProgress = {\r\n      totalScenes: sceneIds.length,\r\n      completedScenes: 0,\r\n      phase: 'preparing',\r\n      message: 'Preparing batch rewrite...',\r\n      results: new Map(),\r\n      errors: new Map()\r\n    };\r\n\r\n    options.progressCallback?.(progress);\r\n\r\n    // Simulate sequential processing\r\n    for (const id of sceneIds) {\r\n      if (this.cancelled) {\r\n        progress.phase = 'error';\r\n        progress.message = 'Batch rewrite cancelled';\r\n        break;\r\n      }\r\n\r\n      progress.currentSceneId = id;\r\n      progress.currentSceneTitle = manuscript.scenes.find(s => s.id === id)?.text.split('\\n')[0];\r\n      progress.phase = 'rewriting';\r\n      progress.message = `Rewriting scene ${progress.completedScenes + 1} of ${progress.totalScenes}`;\r\n      options.progressCallback?.(progress);\r\n\r\n      // Simulate result\r\n      const result: RewriteResult = {\r\n        success: true,\r\n        rewrittenText: `Rewritten ${id}`,\r\n        issuesAddressed: manuscript.scenes.find(s => s.id === id)?.continuityAnalysis?.issues ?? [],\r\n        changesExplanation: `Fixed issues in ${id}`,\r\n        preservedElements: [],\r\n        diffData: [],\r\n        modelUsed: 'fake-model'\r\n      };\r\n      progress.results.set(id, result);\r\n      progress.completedScenes += 1;\r\n      options.progressCallback?.(progress);\r\n    }\r\n\r\n    if (!this.cancelled) {\r\n      progress.phase = 'complete';\r\n      progress.message = `Successfully rewrote ${progress.results.size} scenes`;\r\n    }\r\n\r\n    return progress;\r\n  }\r\n}\r\n\r\ndescribe('Rewrite Store — batch operations', () => {\r\n  beforeEach(() => {\r\n    // Reset manuscript\r\n    const manuscript = buildManuscript(['s1', 's2', 's3']);\r\n    useManuscriptStore.setState({\r\n      manuscript,\r\n      selectedSceneId: manuscript.scenes[0].id,\r\n      isLoading: false,\r\n      error: null\r\n    });\r\n\r\n    // Reset rewrite store state\r\n    useRewriteStore.setState({\r\n      isRewriting: false,\r\n      currentRewriteSceneId: undefined,\r\n      rewriteProgress: { stage: 'idle', message: '' },\r\n      sceneRewrites: new Map(),\r\n      activeEdits: new Map(),\r\n      diffCache: new Map(),\r\n      batchProgress: undefined,\r\n      isBatchRewriting: false,\r\n      batchOrchestrator: undefined,\r\n      showHistory: new Map(),\r\n    } as any);\r\n  });\r\n\r\n  it('startBatchRewrite updates progress and stores per-scene results', async () => {\r\n    const orchestrator = new OrchestratorFake();\r\n    // Inject orchestrator into store\r\n    useRewriteStore.setState({ batchOrchestrator: orchestrator } as any);\r\n\r\n    const { startBatchRewrite } = useRewriteStore.getState();\r\n\r\n    await startBatchRewrite({ skipIfNoIssues: false });\r\n\r\n    const state = useRewriteStore.getState();\r\n    expect(state.isBatchRewriting).toBe(false);\r\n    expect(state.batchProgress?.phase).toBe('complete');\r\n    expect(state.batchProgress?.results.size).toBe(3);\r\n\r\n    // Rewrites map should contain ONE rewrite per scene (replace behavior)\r\n    for (const id of ['s1', 's2', 's3']) {\r\n      expect(state.sceneRewrites.has(id)).toBe(true);\r\n      const history = state.sceneRewrites.get(id)!;\r\n      expect(history.length).toBe(1);\r\n      expect(history[0].rewrittenText).toBe(`Rewritten ${id}`);\r\n    }\r\n\r\n    // Manuscript scenes should be marked generated with currentRewrite populated\r\n    const manuscript = useManuscriptStore.getState().manuscript!;\r\n    for (const id of manuscript.currentOrder) {\r\n      const scene = manuscript.scenes.find(s => s.id === id)!;\r\n      expect(scene.rewriteStatus).toBe('generated');\r\n      expect(scene.currentRewrite).toBe(`Rewritten ${id}`);\r\n    }\r\n  });\r\n\r\n  it('cancelBatchRewrite calls orchestrator.cancelBatch and marks state cancelled', async () => {\r\n    const orchestrator = new OrchestratorFake();\r\n    useRewriteStore.setState({ batchOrchestrator: orchestrator } as any);\r\n\r\n    const { startBatchRewrite, cancelBatchRewrite } = useRewriteStore.getState();\r\n\r\n    // Start but immediately cancel; our fake will pick up the cancelled flag\r\n    const startPromise = startBatchRewrite({ skipIfNoIssues: false });\r\n    cancelBatchRewrite();\r\n    await startPromise;\r\n\r\n    const state = useRewriteStore.getState();\r\n    expect(orchestrator.cancelled).toBe(true);\r\n    expect(state.isBatchRewriting).toBe(false);\r\n    expect(state.batchProgress?.phase).toBe('error');\r\n    expect(state.batchProgress?.message).toContain('cancelled');\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\rewriteStore.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\ChangeExplanation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\DiffViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteEditor.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'editedText', 'isEditing', 'latestRewrite?.rewrittenText', and 'loadRewriteForEdit'. Either include them or remove the dependency array.","line":46,"column":6,"nodeType":"ArrayExpression","endLine":46,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [editedText, isEditMode, isEditing, latestRewrite?.rewrittenText, loadRewriteForEdit, scene.id]","fix":{"range":[1481,1503],"text":"[editedText, isEditMode, isEditing, latestRewrite?.rewrittenText, loadRewriteForEdit, scene.id]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteHistory.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewritePanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ChangeExplanation' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useMemo } from 'react';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useRewriteStore from '../stores/rewriteStore';\r\nimport RewriteProgress from './RewriteProgress';\r\nimport RewriteHistory from './RewriteHistory';\r\nimport ChangeExplanation from './ChangeExplanation';\r\nimport type { Scene } from '../../../../shared/types';\r\n\r\ninterface RewritePanelProps {\r\n  className?: string;\r\n}\r\n\r\nconst RewritePanel: React.FC<RewritePanelProps> = ({ className = '' }) => {\r\n  const manuscript = useManuscriptStore(state => state.manuscript);\r\n  const [selectedTab, setSelectedTab] = useState<'overview' | 'batch' | 'history'>('overview');\r\n  \r\n  const {\r\n    sceneRewrites,\r\n    isBatchRewriting,\r\n    batchProgress,\r\n    startBatchRewrite,\r\n    cancelBatchRewrite,\r\n    clearAllRewrites,\r\n  } = useRewriteStore();\r\n  \r\n  // Calculate statistics\r\n  const stats = useMemo(() => {\r\n    if (!manuscript) return null;\r\n    \r\n    const movedScenes = manuscript.scenes.filter(s => s.hasBeenMoved);\r\n    const scenesWithIssues = movedScenes.filter(s =>\r\n      (s.continuityAnalysis?.issues?.length ?? 0) > 0\r\n    );\r\n    const scenesWithRewrites = Array.from(sceneRewrites.keys());\r\n    const appliedRewrites = manuscript.scenes.filter(s => s.rewriteStatus === 'approved');\r\n    \r\n    return {\r\n      moved: movedScenes.length,\r\n      withIssues: scenesWithIssues.length,\r\n      rewritten: scenesWithRewrites.length,\r\n      applied: appliedRewrites.length\r\n    };\r\n  }, [manuscript, sceneRewrites]);\r\n  \r\n  const handleStartBatch = useCallback(async () => {\r\n    await startBatchRewrite({\r\n      skipIfNoIssues: true\r\n    });\r\n  }, [startBatchRewrite]);\r\n  \r\n  if (!manuscript || !stats) {\r\n    return (\r\n      <div className={`p-4 text-center text-gray-500 ${className}`}>\r\n        Load a manuscript to begin rewriting\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  return (\r\n    <div className={`flex flex-col h-full ${className}`}>\r\n      {/* Header with tabs */}\r\n      <div className=\"bg-white border-b border-gray-200\">\r\n        <div className=\"px-4 pt-4\">\r\n          <h2 className=\"text-lg font-semibold text-gray-900\">\r\n            Rewrite Management\r\n          </h2>\r\n        </div>\r\n        <div className=\"flex mt-4\">\r\n          <button\r\n            onClick={() => setSelectedTab('overview')}\r\n            className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${\r\n              selectedTab === 'overview'\r\n                ? 'text-blue-600 border-blue-600'\r\n                : 'text-gray-600 border-transparent hover:text-gray-900'\r\n            }`}\r\n          >\r\n            Overview\r\n          </button>\r\n          <button\r\n            onClick={() => setSelectedTab('batch')}\r\n            className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${\r\n              selectedTab === 'batch'\r\n                ? 'text-blue-600 border-blue-600'\r\n                : 'text-gray-600 border-transparent hover:text-gray-900'\r\n            }`}\r\n          >\r\n            Batch Process\r\n          </button>\r\n          <button\r\n            onClick={() => setSelectedTab('history')}\r\n            className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${\r\n              selectedTab === 'history'\r\n                ? 'text-blue-600 border-blue-600'\r\n                : 'text-gray-600 border-transparent hover:text-gray-900'\r\n            }`}\r\n          >\r\n            History\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      {/* Content */}\r\n      <div className=\"flex-1 overflow-auto\">\r\n        {selectedTab === 'overview' && (\r\n          <div className=\"p-4\">\r\n            {/* Statistics Cards */}\r\n            <div className=\"grid grid-cols-2 gap-4 mb-6\">\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-gray-900\">{stats.moved}</div>\r\n                <div className=\"text-sm text-gray-600\">Moved Scenes</div>\r\n              </div>\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-amber-600\">{stats.withIssues}</div>\r\n                <div className=\"text-sm text-gray-600\">Need Rewriting</div>\r\n              </div>\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-blue-600\">{stats.rewritten}</div>\r\n                <div className=\"text-sm text-gray-600\">Rewrites Ready</div>\r\n              </div>\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-green-600\">{stats.applied}</div>\r\n                <div className=\"text-sm text-gray-600\">Applied</div>\r\n              </div>\r\n            </div>\r\n            \r\n            {/* Scene List with Status */}\r\n            <div className=\"bg-white rounded-lg border border-gray-200\">\r\n              <div className=\"px-4 py-3 border-b border-gray-200\">\r\n                <h3 className=\"text-sm font-semibold text-gray-900\">\r\n                  Scenes Requiring Attention\r\n                </h3>\r\n              </div>\r\n              <div className=\"divide-y divide-gray-200\">\r\n                {manuscript.scenes\r\n                  .filter(scene => scene.hasBeenMoved && ((scene.continuityAnalysis?.issues?.length ?? 0) > 0))\r\n                  .map(scene => (\r\n                    <SceneRewriteStatus key={scene.id} scene={scene} />\r\n                  ))}\r\n                {stats.withIssues === 0 && (\r\n                  <div className=\"px-4 py-8 text-center text-gray-500\">\r\n                    No scenes require rewriting\r\n                  </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n            \r\n            {/* Quick Actions */}\r\n            <div className=\"mt-6 flex gap-3\">\r\n              <button\r\n                onClick={handleStartBatch}\r\n                disabled={stats.withIssues === 0 || isBatchRewriting}\r\n                className=\"px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed\"\r\n              >\r\n                Rewrite All ({stats.withIssues} scenes)\r\n              </button>\r\n              {stats.rewritten > 0 && (\r\n                <button\r\n                  onClick={clearAllRewrites}\r\n                  className=\"px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50\"\r\n                >\r\n                  Clear All Rewrites\r\n                </button>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n        \r\n        {selectedTab === 'batch' && (\r\n          <div className=\"p-4\">\r\n            <RewriteProgress\r\n              progress={batchProgress}\r\n              isRunning={isBatchRewriting}\r\n              onCancel={cancelBatchRewrite}\r\n              onStart={handleStartBatch}\r\n            />\r\n          </div>\r\n        )}\r\n        \r\n        {selectedTab === 'history' && (\r\n          <div className=\"p-4\">\r\n            <RewriteHistory\r\n              sceneRewrites={sceneRewrites}\r\n              manuscript={manuscript}\r\n            />\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Sub-component for scene status in overview\r\nconst SceneRewriteStatus: React.FC<{ scene: Scene }> = ({ scene }) => {\r\n  const { hasRewrite, generateRewrite } = useRewriteStore();\r\n  const hasRewriteReady = hasRewrite(scene.id);\r\n  const issueCount = scene.continuityAnalysis?.issues?.length || 0;\r\n  \r\n  return (\r\n    <div className=\"px-4 py-3 flex items-center justify-between hover:bg-gray-50\">\r\n      <div>\r\n        <div className=\"text-sm font-medium text-gray-900\">\r\n          Scene {scene.position + 1}\r\n        </div>\r\n        <div className=\"text-xs text-gray-600 mt-1\">\r\n          {issueCount} issue{issueCount !== 1 ? 's' : ''} to fix\r\n        </div>\r\n      </div>\r\n      <div className=\"flex items-center gap-2\">\r\n        {scene.rewriteStatus === 'approved' && (\r\n          <span className=\"text-xs px-2 py-1 bg-green-100 text-green-800 rounded\">\r\n            Applied\r\n          </span>\r\n        )}\r\n        {hasRewriteReady && scene.rewriteStatus !== 'approved' && (\r\n          <span className=\"text-xs px-2 py-1 bg-blue-100 text-blue-800 rounded\">\r\n            Ready\r\n          </span>\r\n        )}\r\n        {!hasRewriteReady && (\r\n          <button\r\n            onClick={() => generateRewrite(scene.id)}\r\n            className=\"text-xs px-3 py-1 text-blue-600 hover:bg-blue-50 rounded\"\r\n          >\r\n            Generate\r\n          </button>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RewritePanel;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteStats.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'batchProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":10,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useRewriteStore from '../stores/rewriteStore';\r\nimport PerformanceOptimizer from '../../../../services/rewrite/PerformanceOptimizer';\r\n\r\nconst performanceOptimizer = new PerformanceOptimizer();\r\n\r\nconst RewriteStats: React.FC = () => {\r\n  const manuscript = useManuscriptStore(state => state.manuscript);\r\n  const { sceneRewrites, batchProgress } = useRewriteStore();\r\n\r\n  const stats = React.useMemo(() => {\r\n    if (!manuscript) return null;\r\n\r\n    const totalScenes = manuscript.scenes.length;\r\n    const movedScenes = manuscript.scenes.filter(s => s.hasBeenMoved).length;\r\n    const rewrittenScenes = Array.from(sceneRewrites.keys()).length;\r\n    const appliedRewrites = manuscript.scenes.filter(s => s.rewriteStatus === 'approved').length;\r\n\r\n    // Calculate issue resolution rate\r\n    let totalIssues = 0;\r\n    let resolvedIssues = 0;\r\n\r\n    manuscript.scenes.forEach(scene => {\r\n      const issues = scene.continuityAnalysis?.issues || [];\r\n      totalIssues += issues.length;\r\n\r\n      if (scene.rewriteStatus === 'approved') {\r\n        resolvedIssues += issues.length;\r\n      }\r\n    });\r\n\r\n    const resolutionRate = totalIssues > 0 ? (resolvedIssues / totalIssues) * 100 : 0;\r\n\r\n    return {\r\n      totalScenes,\r\n      movedScenes,\r\n      rewrittenScenes,\r\n      appliedRewrites,\r\n      totalIssues,\r\n      resolvedIssues,\r\n      resolutionRate\r\n    };\r\n  }, [manuscript, sceneRewrites]);\r\n\r\n  const metrics = performanceOptimizer.getMetrics();\r\n  const suggestions = performanceOptimizer.getSuggestions();\r\n\r\n  if (!stats) return null;\r\n\r\n  return (\r\n    <div className=\"p-4 space-y-4\">\r\n      {/* Main Stats */}\r\n      <div className=\"grid grid-cols-2 lg:grid-cols-4 gap-4\">\r\n        <StatCard\r\n          label=\"Scenes Moved\"\r\n          value={stats.movedScenes}\r\n          total={stats.totalScenes}\r\n          color=\"amber\"\r\n        />\r\n        <StatCard\r\n          label=\"Rewrites Ready\"\r\n          value={stats.rewrittenScenes}\r\n          total={stats.movedScenes}\r\n          color=\"blue\"\r\n        />\r\n        <StatCard\r\n          label=\"Applied\"\r\n          value={stats.appliedRewrites}\r\n          total={stats.rewrittenScenes}\r\n          color=\"green\"\r\n        />\r\n        <StatCard\r\n          label=\"Issues Fixed\"\r\n          value={`${stats.resolutionRate.toFixed(0)}%`}\r\n          subtitle={`${stats.resolvedIssues}/${stats.totalIssues}`}\r\n          color=\"purple\"\r\n        />\r\n      </div>\r\n\r\n      {/* Performance Metrics */}\r\n      {metrics.lastUpdated > 0 && (\r\n        <div className=\"bg-white rounded-lg border border-gray-200 p-4\">\r\n          <h3 className=\"text-sm font-semibold text-gray-700 mb-3\">\r\n            Performance\r\n          </h3>\r\n          <div className=\"grid grid-cols-2 gap-4 text-sm\">\r\n            <div>\r\n              <span className=\"text-gray-600\">Avg. Rewrite Time:</span>\r\n              <span className=\"ml-2 font-medium\">\r\n                {(metrics.avgRewriteTime / 1000).toFixed(1)}s\r\n              </span>\r\n            </div>\r\n            <div>\r\n              <span className=\"text-gray-600\">Cache Hit Rate:</span>\r\n              <span className=\"ml-2 font-medium\">\r\n                {(metrics.cacheHitRate * 100).toFixed(0)}%\r\n              </span>\r\n            </div>\r\n          </div>\r\n\r\n          {suggestions.length > 0 && (\r\n            <div className=\"mt-3 pt-3 border-t border-gray-100\">\r\n              <div className=\"text-xs text-gray-600\">Suggestions:</div>\r\n              <ul className=\"mt-1 space-y-1\">\r\n                {suggestions.map((suggestion, index) => (\r\n                  <li key={index} className=\"text-xs text-amber-600\">\r\n                    • {suggestion}\r\n                  </li>\r\n                ))}\r\n              </ul>\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\n// Helper component\r\nconst StatCard: React.FC<{\r\n  label: string;\r\n  value: string | number;\r\n  total?: number;\r\n  subtitle?: string;\r\n  color: 'amber' | 'blue' | 'green' | 'purple';\r\n}> = ({ label, value, total, subtitle, color }) => {\r\n  const colorClasses = {\r\n    amber: 'bg-amber-50 text-amber-600',\r\n    blue: 'bg-blue-50 text-blue-600',\r\n    green: 'bg-green-50 text-green-600',\r\n    purple: 'bg-purple-50 text-purple-600'\r\n  };\r\n\r\n  return (\r\n    <div className={`p-4 rounded-lg ${colorClasses[color]}`}>\r\n      <div className=\"text-2xl font-bold\">\r\n        {value}\r\n        {total !== undefined && (\r\n          <span className=\"text-sm font-normal opacity-75\">/{total}</span>\r\n        )}\r\n      </div>\r\n      <div className=\"text-sm mt-1\">{label}</div>\r\n      {subtitle && (\r\n        <div className=\"text-xs opacity-75 mt-1\">{subtitle}</div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RewriteStats;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\hooks\\useRewrite.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\stores\\rewriteStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\APIKeyForm.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'defaultModel' is defined but never used. Allowed unused args must match /^_/u.","line":48,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isApiKeyValid' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":16}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\n\r\ninterface ValidationErrors {\r\n  apiKey?: string;\r\n  model?: string;\r\n  baseUrl?: string;\r\n}\r\n\r\ninterface APIKeyFormProps {\r\n  apiKey: string;\r\n  model?: string;\r\n  baseUrl?: string;\r\n  disabled?: boolean;\r\n  isTesting?: boolean;\r\n  // New props\r\n  modelOptions: string[];\r\n  defaultModel: string;\r\n  validationErrors?: ValidationErrors;\r\n  isApiKeyValid?: boolean;\r\n\r\n  onApiKeyChange: (value: string) => void;\r\n  onModelChange: (value: string) => void;\r\n  onBaseUrlChange: (value: string) => void;\r\n  onTest: () => void;\r\n}\r\n\r\nconst inputClass =\r\n  'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';\r\n\r\nconst inputErrorClass =\r\n  'w-full px-3 py-2 border border-red-300 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500';\r\n\r\nconst primaryButtonClass =\r\n  'px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-60 disabled:cursor-not-allowed';\r\n\r\nconst neutralButtonClass =\r\n  'px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-60 disabled:cursor-not-allowed';\r\n\r\nconst errorTextClass = 'mt-1 text-xs text-red-600';\r\n\r\nconst APIKeyForm: React.FC<APIKeyFormProps> = ({\r\n  apiKey,\r\n  model,\r\n  baseUrl,\r\n  disabled,\r\n  isTesting,\r\n  modelOptions,\r\n  defaultModel,\r\n  validationErrors,\r\n  isApiKeyValid,\r\n  onApiKeyChange,\r\n  onModelChange,\r\n  onBaseUrlChange,\r\n  onTest,\r\n}) => {\r\n  const [showKey, setShowKey] = useState(false);\r\n\r\n  // Accessible IDs for errors\r\n  const apiKeyErrId = 'api-key-error';\r\n  const modelErrId = 'model-error';\r\n  const baseUrlErrId = 'base-url-error';\r\n\r\n  const apiKeyHasError = !!validationErrors?.apiKey;\r\n  const modelHasError = !!validationErrors?.model;\r\n  const baseUrlHasError = !!validationErrors?.baseUrl;\r\n\r\n  const testDisabled = !!disabled || !!isTesting || !!validationErrors?.apiKey;\r\n\r\n  return (\r\n    <div className=\"space-y-4\">\r\n      <div>\r\n        <label className=\"block text-sm font-medium text-gray-700 mb-1\" htmlFor=\"api-key-input\">\r\n          API Key\r\n        </label>\r\n        <div className=\"flex gap-2\">\r\n          <input\r\n            id=\"api-key-input\"\r\n            type={showKey ? 'text' : 'password'}\r\n            className={apiKeyHasError ? inputErrorClass : inputClass}\r\n            value={apiKey}\r\n            onChange={(e) => onApiKeyChange(e.target.value)}\r\n            placeholder=\"Enter API key\"\r\n            disabled={disabled}\r\n            autoComplete=\"off\"\r\n            aria-invalid={apiKeyHasError}\r\n            aria-describedby={apiKeyHasError ? apiKeyErrId : undefined}\r\n          />\r\n          <button\r\n            type=\"button\"\r\n            className={neutralButtonClass}\r\n            onClick={() => setShowKey((v) => !v)}\r\n            disabled={disabled}\r\n            aria-label={showKey ? 'Hide API key' : 'Show API key'}\r\n            title={showKey ? 'Hide' : 'Show'}\r\n          >\r\n            {showKey ? 'Hide' : 'Show'}\r\n          </button>\r\n        </div>\r\n        {apiKeyHasError ? <p id={apiKeyErrId} className={errorTextClass}>{validationErrors?.apiKey}</p> : null}\r\n      </div>\r\n\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\" htmlFor=\"model-select\">\r\n            Model\r\n          </label>\r\n          <select\r\n            id=\"model-select\"\r\n            className={modelHasError ? inputErrorClass : inputClass}\r\n            value={model ?? ''}\r\n            onChange={(e) => onModelChange(e.target.value)}\r\n            disabled={disabled}\r\n            aria-invalid={modelHasError}\r\n            aria-describedby={modelHasError ? modelErrId : undefined}\r\n          >\r\n            <option value=\"\">Select a model</option>\r\n            {modelOptions.map((opt) => (\r\n              <option key={opt} value={opt}>{opt}</option>\r\n            ))}\r\n          </select>\r\n          {modelHasError ? <p id={modelErrId} className={errorTextClass}>{validationErrors?.model}</p> : null}\r\n        </div>\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\" htmlFor=\"base-url-input\">\r\n            Base URL (optional)\r\n          </label>\r\n          <input\r\n            id=\"base-url-input\"\r\n            type=\"text\"\r\n            className={baseUrlHasError ? inputErrorClass : inputClass}\r\n            value={baseUrl ?? ''}\r\n            onChange={(e) => onBaseUrlChange(e.target.value)}\r\n            placeholder=\"https://api.example.com\"\r\n            disabled={disabled}\r\n            autoComplete=\"off\"\r\n            aria-invalid={baseUrlHasError}\r\n            aria-describedby={baseUrlHasError ? baseUrlErrId : undefined}\r\n          />\r\n          {baseUrlHasError ? <p id={baseUrlErrId} className={errorTextClass}>{validationErrors?.baseUrl}</p> : null}\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"flex justify-end\">\r\n        <button\r\n          type=\"button\"\r\n          className={primaryButtonClass}\r\n          onClick={onTest}\r\n          disabled={testDisabled}\r\n          aria-disabled={testDisabled}\r\n        >\r\n          {isTesting ? 'Testing…' : 'Test Connection'}\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default APIKeyForm;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\ProviderSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\SettingsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\hooks\\useAPIConfiguration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\stores\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\stores\\useSettingsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\src\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\stores\\historyStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\stores\\manuscriptStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\AIServiceManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\__tests__\\AIServiceManagerRouting.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":110,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":112,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":114,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":116,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":118,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":139,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":139,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":143,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":143,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":146,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":172,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":172,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":175,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":177,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":177,"endColumn":40}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, beforeEach, afterEach, expect, vi } from 'vitest';\r\nimport AIServiceManager from '../../ai/AIServiceManager';\r\nimport type { AnalysisRequest, AnalysisResponse, ProviderName } from '../../ai/types';\r\n\r\n// Minimal stub tracker with controllable per-model scores by taskType\r\nclass StubTracker {\r\n  private map = new Map<string, number>(); // key = modelId::taskType\r\n  private defaultBase = 0.7;\r\n\r\n  private key(modelId: string, taskType: string) {\r\n    return `${modelId}::${taskType}`;\r\n  }\r\n\r\n  public setScore(modelId: string, taskType: string, score: number) {\r\n    this.map.set(this.key(modelId, taskType), Math.max(0, Math.min(1, score)));\r\n  }\r\n\r\n  // No-op for tests\r\n  public recordResult() {}\r\n\r\n  public getMetrics() {\r\n    return {\r\n      avgConfidence: 0.7,\r\n      successRate: 0.7,\r\n      avgLatencyMs: 1000,\r\n      samples: 0,\r\n      lastUpdatedAt: null as number | null,\r\n    };\r\n  }\r\n\r\n  // Emulate penalty behavior similar to real tracker: multiply base by (1 - 0.3 * costWeight)\r\n  public score(modelId: string, taskType: string, opts?: { costWeight?: number; latencyWeight?: number; accuracyWeight?: number }) {\r\n    const base = this.map.get(this.key(modelId, taskType)) ?? this.defaultBase;\r\n    const costWeight = clamp01(opts?.costWeight ?? 0);\r\n    const penalty = 1 - 0.3 * costWeight;\r\n    return clamp01(base * penalty);\r\n  }\r\n}\r\n\r\nfunction clamp01(x: number) {\r\n  return x < 0 ? 0 : x > 1 ? 1 : x;\r\n}\r\n\r\nfunction makeSimpleRequest(): AnalysisRequest {\r\n  return {\r\n    analysisType: 'simple',\r\n    scene: {\r\n      id: 's1',\r\n      text: 'A short scene.',\r\n      wordCount: 3,\r\n      position: 1,\r\n      originalPosition: 1,\r\n      characters: ['Alice'],\r\n      timeMarkers: [],\r\n      locationMarkers: [],\r\n      hasBeenMoved: false,\r\n      rewriteStatus: 'pending',\r\n    } as any,\r\n    previousScenes: [],\r\n    readerContext: {\r\n      knownCharacters: new Set(['Alice']),\r\n      establishedTimeline: [],\r\n      revealedPlotPoints: [],\r\n      establishedSettings: [],\r\n    },\r\n  };\r\n}\r\n\r\nfunction makeResponse(model: string, provider: ProviderName, confidence: number, durationMs = 100): AnalysisResponse {\r\n  return {\r\n    issues: [],\r\n    metadata: {\r\n      modelUsed: model,\r\n      provider,\r\n      costEstimate: 0,\r\n      durationMs,\r\n      confidence,\r\n      cached: false,\r\n    },\r\n  };\r\n}\r\n\r\ndescribe('AIServiceManager adaptive routing', () => {\r\n  beforeEach(() => {\r\n    // fresh tracker per test\r\n    const tracker = new StubTracker();\r\n    (AIServiceManager as any).__setTestTracker(tracker);\r\n    // Stabilize epsilon-greedy selection to keep tests deterministic\r\n    vi.spyOn(Math, 'random').mockReturnValue(0.5);\r\n  });\r\n\r\n  afterEach(() => {\r\n    (AIServiceManager as any).__setTestTracker(null);\r\n    vi.restoreAllMocks();\r\n  });\r\n\r\n  it('selects the fast model (Claude 3.5 Haiku) for simple requests with neutral metrics', async () => {\r\n    const mgr = new AIServiceManager();\r\n    // Configure all providers (fake keys, no network thanks to stubs below)\r\n    mgr.configure({\r\n      claude: { apiKey: 'x' },\r\n      openai: { apiKey: 'y' },\r\n      gemini: { apiKey: 'z' },\r\n    });\r\n\r\n    const providers = (mgr as any).providers as Map<string, any>;\r\n    // Stub analyze for all configured models\r\n    providers.forEach((prov, id) => {\r\n      if (id === 'claude-3-5-haiku') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-3-5-haiku', 'anthropic', 0.85, 120));\r\n      } else if (id === 'claude-opus-4-1') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-opus-4-1', 'anthropic', 0.9, 300));\r\n      } else if (id === 'claude-sonnet-4') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-sonnet-4', 'anthropic', 0.82, 180));\r\n      } else if (id === 'gpt-5') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('gpt-5', 'openai', 0.8, 200));\r\n      } else if (id === 'gemini-2-5-pro') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('gemini-2-5-pro', 'google', 0.8, 220));\r\n      }\r\n    });\r\n\r\n    const req = makeSimpleRequest();\r\n    const res = await mgr.analyzeContinuity(req);\r\n    expect(res.metadata.modelUsed).toBe('claude-3-5-haiku');\r\n  });\r\n\r\n  it('escalates to strong tier when confidence below threshold', async () => {\r\n    const mgr = new AIServiceManager();\r\n    mgr.configure({\r\n      claude: { apiKey: 'x' },\r\n      openai: { apiKey: 'y' },\r\n      gemini: { apiKey: 'z' },\r\n    });\r\n\r\n    const providers = (mgr as any).providers as Map<string, any>;\r\n    // Force base fast model to low confidence to trigger escalation, strong to high confidence\r\n    providers.forEach((prov, id) => {\r\n      if (id === 'claude-3-5-haiku') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-3-5-haiku', 'anthropic', 0.5, 120)); // below 0.65 simple threshold\r\n      } else if (id === 'claude-opus-4-1') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-opus-4-1', 'anthropic', 0.9, 300));\r\n      } else if (!prov.analyze) {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse(id, 'openai', 0.8, 200));\r\n      } else {\r\n        // leave other stubs as-is or default\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse(id, 'openai', 0.8, 200));\r\n      }\r\n    });\r\n\r\n    const req = makeSimpleRequest(); // simple task triggers base fast; low confidence should escalate\r\n    const res = await mgr.analyzeContinuity(req);\r\n    expect(res.metadata.modelUsed).toBe('claude-opus-4-1');\r\n  });\r\n\r\n  it('prefers balanced GPT when tracker shows higher accuracy for the taskType despite higher cost', async () => {\r\n    // Install a tracker that boosts GPT specifically for 'simple'\r\n    const boostedTracker = new StubTracker();\r\n    boostedTracker.setScore('gpt-5', 'simple', 0.95);\r\n    boostedTracker.setScore('claude-3-5-haiku', 'simple', 0.8);\r\n    (AIServiceManager as any).__setTestTracker(boostedTracker);\r\n\r\n    const mgr = new AIServiceManager();\r\n    mgr.configure({\r\n      claude: { apiKey: 'x' },\r\n      openai: { apiKey: 'y' },\r\n      gemini: { apiKey: 'z' },\r\n    });\r\n\r\n    const providers = (mgr as any).providers as Map<string, any>;\r\n    providers.forEach((prov, id) => {\r\n      if (id === 'gpt-5') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('gpt-5', 'openai', 0.88, 190));\r\n      } else if (id === 'claude-3-5-haiku') {\r\n        // Good but slightly lower confidence, so selection should favor GPT given boosted tracker score\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-3-5-haiku', 'anthropic', 0.82, 130));\r\n      } else {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse(id, 'openai', 0.8, 200));\r\n      }\r\n    });\r\n\r\n    const req = makeSimpleRequest();\r\n    const res = await mgr.analyzeContinuity(req);\r\n    expect(res.metadata.modelUsed).toBe('gpt-5');\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\cache\\PromptCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\consensus\\ConsensusAdapter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ReaderKnowledge' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AnalysisType' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":44}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../shared/types';\r\nimport type { AnalysisRequest, AnalysisType } from '../types';\r\nimport AIServiceManager from '../AIServiceManager';\r\nimport { ValidationPipeline } from '../validation/ValidationPipeline';\r\n\r\n// Local mapping helpers (keep tiny and self-contained)\r\nfunction mapContinuityTypeToSchema(t: ContinuityIssue['type']): 'pronoun_reference' | 'timeline' | 'character_knowledge' | 'other' {\r\n  switch (t) {\r\n    case 'pronoun': return 'pronoun_reference';\r\n    case 'timeline': return 'timeline';\r\n    case 'character': return 'character_knowledge';\r\n    default: return 'other';\r\n  }\r\n}\r\n\r\nfunction mapSchemaTypeToContinuity(t: any): ContinuityIssue['type'] {\r\n  const s = String(t ?? '').toLowerCase();\r\n  if (s === 'pronoun_reference') return 'pronoun';\r\n  if (s === 'timeline') return 'timeline';\r\n  if (s === 'character_knowledge') return 'character';\r\n  // Prefer plot/context over engagement for generic \"other\"\r\n  return 'plot';\r\n}\r\n\r\nfunction mapContinuitySeverityToSchema(s: ContinuityIssue['severity']): 'low' | 'medium' | 'high' | 'critical' {\r\n  switch (s) {\r\n    case 'must-fix': return 'high';\r\n    case 'should-fix': return 'medium';\r\n    case 'consider': return 'low';\r\n  }\r\n}\r\n\r\nfunction mapSchemaSeverityToContinuity(s: any): ContinuityIssue['severity'] {\r\n  const v = String(s ?? '').toLowerCase();\r\n  if (v === 'critical' || v === 'high') return 'must-fix';\r\n  if (v === 'medium') return 'should-fix';\r\n  return 'consider';\r\n}\r\n\r\nfunction toPipelineIssues(issues: readonly ContinuityIssue[]) {\r\n  return (issues ?? []).map((it) => ({\r\n    type: mapContinuityTypeToSchema(it.type),\r\n    severity: mapContinuitySeverityToSchema(it.severity),\r\n    span: Array.isArray(it.textSpan) && it.textSpan.length === 2\r\n      ? { start_index: it.textSpan[0], end_index: it.textSpan[1] }\r\n      : null,\r\n    explanation: String(it.description ?? '').trim() || 'Issue detected',\r\n    evidence: [],\r\n    suggested_fix: String(it.suggestedFix ?? ''),\r\n    confidence: undefined as number | undefined,\r\n  }));\r\n}\r\n\r\nfunction fromPipelineIssues(pIssues: any[]): ContinuityIssue[] {\r\n  const out: ContinuityIssue[] = [];\r\n  for (const it of pIssues ?? []) {\r\n    const start = it?.span?.start_index;\r\n    const end = it?.span?.end_index;\r\n    const hasSpan = Number.isFinite(start) && Number.isFinite(end) && (end as number) >= (start as number);\r\n    out.push({\r\n      type: mapSchemaTypeToContinuity(it?.type),\r\n      severity: mapSchemaSeverityToContinuity(it?.severity),\r\n      description: String(it?.explanation ?? it?.suggested_fix ?? 'Issue detected'),\r\n      textSpan: hasSpan ? [start, end] as [number, number] : [0, 1],\r\n      suggestedFix: it?.suggested_fix ? String(it.suggested_fix) : undefined,\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\n// Default small candidate set (local-only; do not import provider registries)\r\nconst DEFAULT_CANDIDATES = ['gpt-5', 'claude-sonnet-4'];\r\n\r\nexport type ExtraFlags = { complex?: boolean; critical?: boolean };\r\n\r\nexport function enrichAnalysisRequest(\r\n  req: AnalysisRequest & Record<string, any>,\r\n  extras: {\r\n    scene: Scene;\r\n    detectorType: string; // stable taskType label (pronoun, timeline, character, plot, engagement, continuity_rewrite, etc.)\r\n    flags?: ExtraFlags;\r\n  }\r\n): AnalysisRequest & Record<string, any> {\r\n  const newPosition =\r\n    typeof (extras.scene as any)?.position === 'number'\r\n      ? (extras.scene as any).position\r\n      : typeof (extras.scene as any)?.index === 'number'\r\n      ? (extras.scene as any).index\r\n      : 0;\r\n\r\n  return Object.assign(req as any, {\r\n    // Stable routing/task labels (kept local; manager tolerates extra props)\r\n    taskType: extras.detectorType,\r\n    detector: extras.detectorType,\r\n    // Flags for heuristics/consensus selection (local only)\r\n    flags: { ...(req as any)?.flags, ...(extras.flags ?? {}) },\r\n    // Local meta (never part of PromptCache identity)\r\n    sceneText: String(extras.scene?.text ?? ''),\r\n    newPosition,\r\n  });\r\n}\r\n\r\n/**\r\n * Run continuity analysis with optional consensus for critical/high-stakes cases.\r\n * - Preserves PromptCache identity by leaving key fields unchanged.\r\n * - Injects __modelId into the req for each run so tests can assert distinct candidates.\r\n * - Returns an object with { issues } compatible with existing mapping utilities.\r\n */\r\nexport async function runAnalysisWithOptionalConsensus(\r\n  aiManager: AIServiceManager,\r\n  req: AnalysisRequest & Record<string, any>,\r\n  opts: {\r\n    critical?: boolean;\r\n    candidates?: string[];\r\n    consensusCount?: number;\r\n    acceptThreshold?: number;\r\n    humanReviewThreshold?: number;\r\n    maxModels?: number;\r\n  } = {}\r\n): Promise<{ issues: ContinuityIssue[] }> {\r\n  const critical = !!opts.critical;\r\n  if (!critical) {\r\n    const resp = await aiManager.analyzeContinuity(req);\r\n    return { issues: resp.issues ?? [] };\r\n  }\r\n\r\n  const candidates = (opts.candidates && opts.candidates.length > 0) ? Array.from(new Set(opts.candidates)) : DEFAULT_CANDIDATES.slice(0, 2);\r\n\r\n  const pipeline = new ValidationPipeline(\r\n    async (r, { modelId } = {}) => {\r\n      // Attach model id onto the request (local-only, tolerated by manager)\r\n      const r2 = { ...(r as any), __modelId: modelId };\r\n      const single = await aiManager.analyzeContinuity(r2 as any);\r\n      // Convert manager result issues (ContinuityIssue[]) to pipeline schema\r\n      const data = {\r\n        issues: toPipelineIssues(single.issues ?? []),\r\n        summary: '',\r\n        confidence: typeof single?.metadata?.confidence === 'number' ? single.metadata.confidence : 0,\r\n      };\r\n      return { data, modelId, latencyMs: typeof single?.metadata?.durationMs === 'number' ? single.metadata.durationMs : undefined };\r\n    },\r\n    {\r\n      defaultConsensusCount: opts.consensusCount ?? 2,\r\n      acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n      humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n      maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n    }\r\n  );\r\n\r\n  const { data } = await pipeline.runConsensus(req, {\r\n    candidates,\r\n    consensusCount: opts.consensusCount ?? 2,\r\n    acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n    humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n    maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n  });\r\n\r\n  return { issues: fromPipelineIssues((data as any)?.issues ?? []) };\r\n}\r\n\r\n/**\r\n * Specialized minimal adapter for rewrite flows:\r\n * - For consensus: runs two model attempts and treats the returned \"rewrite text\" as the pipeline summary.\r\n * - After consensus, uses merged summary as the chosen rewrite text.\r\n * - For single run: returns the original manager result.\r\n */\r\nexport async function runRewriteWithOptionalConsensus(\r\n  aiManager: AIServiceManager,\r\n  req: AnalysisRequest & Record<string, any>,\r\n  opts: {\r\n    critical?: boolean;\r\n    candidates?: string[];\r\n    consensusCount?: number;\r\n    acceptThreshold?: number;\r\n    humanReviewThreshold?: number;\r\n    maxModels?: number;\r\n  } = {}\r\n): Promise<any> {\r\n  const critical = !!opts.critical;\r\n  if (!critical) {\r\n    return aiManager.analyzeContinuity(req);\r\n  }\r\n\r\n  const candidates = (opts.candidates && opts.candidates.length > 0) ? Array.from(new Set(opts.candidates)) : DEFAULT_CANDIDATES.slice(0, 2);\r\n\r\n  const pipeline = new ValidationPipeline(\r\n    async (r, { modelId } = {}) => {\r\n      const r2 = { ...(r as any), __modelId: modelId };\r\n      const single = await aiManager.analyzeContinuity(r2 as any);\r\n      // Extract rewrite text from tolerant locations\r\n      const rewriteText =\r\n        (single as any)?.rewrittenText ??\r\n        (single as any)?.content?.[0]?.text ??\r\n        (single as any)?.text ??\r\n        '';\r\n      const data = {\r\n        issues: [],      // rewrite consensus reconciles on \"summary\" only\r\n        summary: String(rewriteText ?? ''),\r\n        confidence: typeof (single as any)?.metadata?.confidence === 'number' ? (single as any).metadata.confidence : 0.5,\r\n      };\r\n      return { data, modelId };\r\n    },\r\n    {\r\n      defaultConsensusCount: opts.consensusCount ?? 2,\r\n      acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n      humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n      maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n    }\r\n  );\r\n\r\n  const { data } = await pipeline.runConsensus(req, {\r\n    candidates,\r\n    consensusCount: opts.consensusCount ?? 2,\r\n    acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n    humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n    maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n  });\r\n\r\n  // Return a shape consumable by SceneRewriter.parseRewriteResponse\r\n  return { text: String((data as any)?.summary ?? '') };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\ModelPerformanceTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\Pricing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\RequestBatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\__tests__\\Pricing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\__tests__\\RequestBatcher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\ClaudePrompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\GeminiPrompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\OpenAIPrompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\__tests__\\ClaudePrompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\__tests__\\GeminiPrompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\__tests__\\OpenAIPrompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\BaseProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\ClaudeProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'costTierForModel' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":26},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":108,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":108,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3725,3725],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import BaseProvider from './BaseProvider';\r\nimport {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  ClaudeConfig,\r\n  ProviderError,\r\n  ProviderName,\r\n  ValidationError,\r\n} from '../types';\r\nimport { validateAndNormalize } from '../utils/ResponseValidator';\r\nimport { buildClaudePrompt } from '../prompts/ClaudePrompts';\r\nimport { estimateMessageTokens, estimateTokensForModel } from '../utils/Tokenizers';\r\nimport { estimateCost as estimateUsdCost } from '../optimization/Pricing';\r\n\r\nconst ANTHROPIC_VERSION = '2023-06-01';\r\n\r\nfunction costTierForModel(model: string | undefined): 'low' | 'medium' | 'high' {\r\n  const m = (model ?? '').toLowerCase();\r\n  if (m.includes('opus') || m.includes('o')) return 'high';\r\n  if (m.includes('sonnet') || m.includes('haiku') || m.includes('sonnet-4')) return 'medium';\r\n  return 'medium';\r\n}\r\n\r\n/**\r\n * Claude (Anthropic) provider implementation using Messages API.\r\n */\r\nexport class ClaudeProvider extends BaseProvider<ClaudeConfig> {\r\n  constructor(config: ClaudeConfig, breaker: import('../utils/CircuitBreaker').default) {\r\n    super('anthropic' as ProviderName, config, breaker);\r\n  }\r\n\r\n  /**\r\n   * Build Anthropic-specific prompt payload using XML-style template.\r\n   */\r\n  protected formatPrompt(req: AnalysisRequest): string {\r\n    const readerContext = req.readerContext;\r\n    const previousScenes = req.previousScenes;\r\n    const newPosition = req.scene.position;\r\n    const sceneText = req.scene.text;\r\n    return buildClaudePrompt(readerContext, previousScenes, newPosition, sceneText);\r\n  }\r\n\r\n  /**\r\n   * Execute continuity analysis via Anthropic Messages API.\r\n   */\r\n  public async analyze(req: AnalysisRequest): Promise<AnalysisResponse> {\r\n    if (!this.config.apiKey) {\r\n      throw new ProviderError('anthropic', 'Missing Anthropic API key in configuration');\r\n    }\r\n\r\n    const modelLabel = this.config.model ?? 'claude-sonnet-4';\r\n    const url =\r\n      this.config.baseUrl?.trim() ||\r\n      'https://api.anthropic.com/v1/messages';\r\n\r\n    // Enforce optional budgets by trimming older previousScenes\r\n    const budgeted = this.enforceInputBudget(req, modelLabel);\r\n    const effReq = budgeted.req;\r\n\r\n    const prompt = this.formatPrompt(effReq) as string;\r\n\r\n    const body = {\r\n      model: modelLabel,\r\n      system:\r\n        'You are a meticulous continuity analyst. Respond with ONLY valid JSON per the requested schema. No extra text.',\r\n      messages: [\r\n        {\r\n          role: 'user',\r\n          content: [{ type: 'text', text: prompt }],\r\n        },\r\n      ],\r\n      max_tokens: 2048,\r\n      temperature: 0.2,\r\n    };\r\n\r\n    // Pre-flight estimate of input tokens using simplified message view\r\n    let inputTokensEstimate = estimateMessageTokens(modelLabel, [\r\n      { role: 'system', content: body.system },\r\n      { role: 'user', content: prompt },\r\n    ]);\r\n\r\n    const headers: HeadersInit = {\r\n      'content-type': 'application/json',\r\n      'x-api-key': this.config.apiKey,\r\n      'anthropic-version': ANTHROPIC_VERSION,\r\n    };\r\n\r\n    const started = Date.now();\r\n    try {\r\n      const res = await this.fetchWithRetry(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body),\r\n      });\r\n\r\n      const raw = (await res.json()) as any;\r\n      const normalized = validateAndNormalize('anthropic', raw, modelLabel);\r\n\r\n      // Prefer provider usage when available\r\n      if (raw && raw.usage && Number.isFinite(raw.usage.input_tokens)) {\r\n        inputTokensEstimate = Math.max(0, Number(raw.usage.input_tokens));\r\n      }\r\n\r\n      // Output tokens: prefer usage, else estimate from first content text\r\n      let outputText = '';\r\n      try {\r\n        outputText = raw?.content?.[0]?.text ?? '';\r\n      } catch {}\r\n      let outputTokensEstimate =\r\n        raw && raw.usage && Number.isFinite(raw.usage.output_tokens)\r\n          ? Math.max(0, Number(raw.usage.output_tokens))\r\n          : estimateTokensForModel(modelLabel, String(outputText ?? ''));\r\n\r\n      const durationMs = Date.now() - started;\r\n\r\n      const costEstimate = this.estimateCostFromUsage(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      });\r\n\r\n      const breakdown = estimateUsdCost(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      }).breakdown;\r\n\r\n      const confidence = normalized.metadata.confidence ?? 0.5;\r\n\r\n      const meta: any = {\r\n        modelUsed: modelLabel,\r\n        provider: 'anthropic',\r\n        costEstimate,\r\n        durationMs,\r\n        confidence,\r\n        cached: false,\r\n      };\r\n      if (budgeted.meta) {\r\n        meta.trimmed = true;\r\n        meta.trimDetails = budgeted.meta;\r\n      }\r\n      meta.tokensInputEstimated = inputTokensEstimate;\r\n      meta.tokensOutputEstimated = outputTokensEstimate;\r\n      meta.costBreakdownUSD = breakdown;\r\n\r\n      const out: AnalysisResponse = {\r\n        issues: normalized.issues,\r\n        metadata: meta as AnalysisResponse['metadata'],\r\n      };\r\n\r\n      return out;\r\n    } catch (err) {\r\n      // TODO: Replace with production logger\r\n      console.log('[ClaudeProvider] analyze error:', err);\r\n      if (err instanceof ValidationError) {\r\n        throw err;\r\n      }\r\n      if (err && typeof err === 'object' && (err as Error).name === 'CircuitBreakerOpenError') {\r\n        throw err;\r\n      }\r\n      throw new ProviderError('anthropic', 'Claude analyze failed', { cause: err });\r\n    }\r\n  }\r\n}\r\n\r\nexport default ClaudeProvider;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\GeminiProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'costTierForModel' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":26},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":125,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":125,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4427,4427],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import BaseProvider from './BaseProvider';\r\nimport {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  GeminiConfig,\r\n  ProviderError,\r\n  ProviderName,\r\n  ValidationError,\r\n} from '../types';\r\nimport { validateAndNormalize } from '../utils/ResponseValidator';\r\nimport { buildGeminiPrompt } from '../prompts/GeminiPrompts';\r\nimport { estimateMessageTokens, estimateTokensForModel } from '../utils/Tokenizers';\r\nimport { estimateCost as estimateUsdCost } from '../optimization/Pricing';\r\n\r\nfunction buildGeminiUrl(model: string, apiKey: string, baseUrl?: string): string {\r\n  if (baseUrl && baseUrl.trim().length > 0) {\r\n    // Expect caller to include model + api key if they override baseUrl\r\n    return baseUrl;\r\n  }\r\n  const encodedModel = encodeURIComponent(model);\r\n  return `https://generativelanguage.googleapis.com/v1beta/models/${encodedModel}:generateContent?key=${encodeURIComponent(\r\n    apiKey\r\n  )}`;\r\n}\r\n\r\nfunction costTierForModel(model: string | undefined): 'low' | 'medium' | 'high' {\r\n  const m = (model ?? '').toLowerCase();\r\n  if (m.includes('pro')) return 'low';\r\n  if (m.includes('flash') || m.includes('lite')) return 'low';\r\n  return 'medium';\r\n}\r\n\r\n/**\r\n * Google Gemini provider implementation using generateContent API.\r\n */\r\nexport class GeminiProvider extends BaseProvider<GeminiConfig> {\r\n  constructor(config: GeminiConfig, breaker: import('../utils/CircuitBreaker').default) {\r\n    super('google' as ProviderName, config, breaker);\r\n  }\r\n\r\n  /**\r\n   * Build Gemini-specific content structure with instruction and parts.\r\n   */\r\n  protected formatPrompt(req: AnalysisRequest): { instruction: string; parts: Array<{ text: string }> } {\r\n    const readerContext = req.readerContext;\r\n    const previousScenes = req.previousScenes;\r\n    const newPosition = req.scene.position;\r\n    const sceneText = req.scene.text;\r\n    const genreStyle = (req as any).genreStyle ?? (req.scene as any)?.genreStyle ?? undefined;\r\n\r\n    return buildGeminiPrompt({\r\n      readerContext,\r\n      previousScenes,\r\n      newPosition,\r\n      sceneText,\r\n      genreStyle,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute continuity analysis via Gemini generateContent.\r\n   */\r\n  public async analyze(req: AnalysisRequest): Promise<AnalysisResponse> {\r\n    if (!this.config.apiKey) {\r\n      throw new ProviderError('google', 'Missing Google API key in configuration');\r\n    }\r\n\r\n    const modelLabel = this.config.model ?? 'gemini-2-5-pro';\r\n    const url = buildGeminiUrl(modelLabel, this.config.apiKey, this.config.baseUrl);\r\n\r\n    // Enforce optional input budgets (trim oldest previousScenes)\r\n    const budgeted = this.enforceInputBudget(req, modelLabel);\r\n    const effReq = budgeted.req;\r\n\r\n    const { instruction, parts } = this.formatPrompt(effReq) as { instruction: string; parts: Array<{ text: string }> };\r\n\r\n    const body = {\r\n      systemInstruction: {\r\n        role: 'system',\r\n        parts: [{ text: instruction }],\r\n      },\r\n      contents: [\r\n        {\r\n          role: 'user',\r\n          parts,\r\n        },\r\n      ],\r\n      generationConfig: {\r\n        temperature: 0.2,\r\n        // Prefer JSON-only responses if supported by the API\r\n        response_mime_type: 'application/json',\r\n      },\r\n    };\r\n\r\n    // Pre-flight estimate of input tokens using simplified message view\r\n    let inputTokensEstimate = estimateMessageTokens(modelLabel, [\r\n      { role: 'system', content: instruction },\r\n      { role: 'user', content: parts.map((p) => p.text ?? '').join('\\n') },\r\n    ]);\r\n\r\n    const headers: HeadersInit = {\r\n      'content-type': 'application/json',\r\n    };\r\n\r\n    const started = Date.now();\r\n    try {\r\n      const res = await this.fetchWithRetry(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body),\r\n      });\r\n\r\n      const raw = (await res.json()) as any;\r\n      const normalized = validateAndNormalize('google', raw, modelLabel);\r\n\r\n      // Gemini v1beta responses may not include token usage in public API.\r\n      // If present in future, prefer it; else heuristic on text length.\r\n      // Attempt to extract output text\r\n      let outputText = '';\r\n      try {\r\n        const firstCandidate = raw?.candidates?.[0];\r\n        const partsOut = firstCandidate?.content?.parts ?? [];\r\n        const withText = partsOut.find((p: { text?: string }) => typeof p.text === 'string' && ((p.text?.length ?? 0) > 0));\r\n        outputText = withText?.text ?? '';\r\n      } catch {}\r\n\r\n      // Token usage fields if they appear in future:\r\n      const usageIn = Number(raw?.usageMetadata?.promptTokenCount);\r\n      const usageOut = Number(raw?.usageMetadata?.candidatesTokenCount);\r\n      if (Number.isFinite(usageIn)) inputTokensEstimate = Math.max(0, usageIn);\r\n\r\n      const outputTokensEstimate = Number.isFinite(usageOut)\r\n        ? Math.max(0, usageOut)\r\n        : estimateTokensForModel(modelLabel, String(outputText ?? ''));\r\n\r\n      const durationMs = Date.now() - started;\r\n\r\n      const costEstimate = this.estimateCostFromUsage(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      });\r\n\r\n      const breakdown = estimateUsdCost(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      }).breakdown;\r\n\r\n      const confidence = normalized.metadata.confidence ?? 0.5;\r\n\r\n      const meta: any = {\r\n        modelUsed: modelLabel,\r\n        provider: 'google',\r\n        costEstimate,\r\n        durationMs,\r\n        confidence,\r\n        cached: false,\r\n      };\r\n      if (budgeted.meta) {\r\n        meta.trimmed = true;\r\n        meta.trimDetails = budgeted.meta;\r\n      }\r\n      meta.tokensInputEstimated = inputTokensEstimate;\r\n      meta.tokensOutputEstimated = outputTokensEstimate;\r\n      meta.costBreakdownUSD = breakdown;\r\n\r\n      const out: AnalysisResponse = {\r\n        issues: normalized.issues,\r\n        metadata: meta as AnalysisResponse['metadata'],\r\n      };\r\n\r\n      return out;\r\n    } catch (err) {\r\n      // TODO: Replace with production logger\r\n      console.log('[GeminiProvider] analyze error:', err);\r\n      if (err instanceof ValidationError) {\r\n        throw err;\r\n      }\r\n      if (err && typeof err === 'object' && (err as Error).name === 'CircuitBreakerOpenError') {\r\n        throw err;\r\n      }\r\n      throw new ProviderError('google', 'Gemini analyze failed', { cause: err });\r\n    }\r\n  }\r\n}\r\n\r\nexport default GeminiProvider;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\OpenAIProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'costTierForModel' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":26},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":106,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":106,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3761,3761],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import BaseProvider from './BaseProvider';\r\nimport {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  OpenAIConfig,\r\n  ProviderError,\r\n  ProviderName,\r\n  ValidationError,\r\n} from '../types';\r\nimport { validateAndNormalize } from '../utils/ResponseValidator';\r\nimport { buildOpenAIPrompt, getOpenAIResponseFormat } from '../prompts/OpenAIPrompts';\r\nimport { estimateMessageTokens, estimateTokensForModel } from '../utils/Tokenizers';\r\nimport { estimateCost as estimateUsdCost } from '../optimization/Pricing';\r\n\r\nfunction costTierForModel(model: string | undefined): 'low' | 'medium' | 'high' {\r\n  const m = (model ?? '').toLowerCase();\r\n  if (m.includes('gpt-5')) return 'low';\r\n  if (m.includes('o1') || m.includes('o3') || m.includes('gpt-4')) return 'high';\r\n  return 'medium';\r\n}\r\n\r\n/**\r\n * OpenAI Chat Completions provider implementation.\r\n */\r\nexport class OpenAIProvider extends BaseProvider<OpenAIConfig> {\r\n  constructor(config: OpenAIConfig, breaker: import('../utils/CircuitBreaker').default) {\r\n    super('openai' as ProviderName, config, breaker);\r\n  }\r\n\r\n  /**\r\n   * Build OpenAI-specific structured messages using templates.\r\n   */\r\n  protected formatPrompt(req: AnalysisRequest): { system: string; user: string } {\r\n    const readerContext = req.readerContext;\r\n    const previousScenes = req.previousScenes;\r\n    const newPosition = req.scene.position;\r\n    const sceneText = req.scene.text;\r\n    // Optional, mapped locally without type changes\r\n    const genreStyle = (req as any).genreStyle ?? (req.scene as any)?.genreStyle ?? undefined;\r\n\r\n    return buildOpenAIPrompt({\r\n      readerContext,\r\n      previousScenes,\r\n      newPosition,\r\n      sceneText,\r\n      genreStyle,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute continuity analysis via OpenAI chat.completions.\r\n   */\r\n  public async analyze(req: AnalysisRequest): Promise<AnalysisResponse> {\r\n    if (!this.config.apiKey) {\r\n      throw new ProviderError('openai', 'Missing OpenAI API key in configuration');\r\n    }\r\n\r\n    const modelLabel = this.config.model ?? 'gpt-5';\r\n    const url = this.config.baseUrl?.trim() || 'https://api.openai.com/v1/chat/completions';\r\n\r\n    // Enforce optional budgets (soft trimming oldest previousScenes)\r\n    const budgeted = this.enforceInputBudget(req, modelLabel);\r\n    const effReq = budgeted.req;\r\n\r\n    const { system, user } = this.formatPrompt(effReq) as { system: string; user: string };\r\n\r\n    const body = {\r\n      model: modelLabel,\r\n      messages: [\r\n        { role: 'system', content: system },\r\n        { role: 'user', content: user },\r\n      ],\r\n      temperature: 0.2,\r\n      response_format: getOpenAIResponseFormat(),\r\n      // We avoid streaming to keep simpler validation path\r\n    };\r\n\r\n    // Pre-flight input token estimate from actual payload\r\n    let inputTokensEstimate = estimateMessageTokens(modelLabel, body.messages as Array<{ role?: string; content: string }>);\r\n\r\n    const headers: HeadersInit = {\r\n      'content-type': 'application/json',\r\n      authorization: `Bearer ${this.config.apiKey}`,\r\n    };\r\n\r\n    const started = Date.now();\r\n    try {\r\n      const res = await this.fetchWithRetry(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body),\r\n      });\r\n\r\n      const raw = (await res.json()) as any;\r\n      const normalized = validateAndNormalize('openai', raw, modelLabel);\r\n\r\n      // Prefer provider-reported usage when present\r\n      if (raw && raw.usage && Number.isFinite(raw.usage.prompt_tokens)) {\r\n        inputTokensEstimate = Math.max(0, Number(raw.usage.prompt_tokens));\r\n      }\r\n\r\n      // Estimate output tokens from model content if usage missing\r\n      let outputText = '';\r\n      try {\r\n        outputText = raw?.choices?.[0]?.message?.content ?? '';\r\n      } catch {}\r\n      let outputTokensEstimate =\r\n        raw && raw.usage && Number.isFinite(raw.usage.completion_tokens)\r\n          ? Math.max(0, Number(raw.usage.completion_tokens))\r\n          : estimateTokensForModel(modelLabel, String(outputText ?? ''));\r\n\r\n      const durationMs = Date.now() - started;\r\n\r\n      const costEstimate = this.estimateCostFromUsage(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      });\r\n\r\n      const breakdown = estimateUsdCost(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      }).breakdown;\r\n\r\n      const confidence = normalized.metadata.confidence ?? 0.5;\r\n\r\n      // Build metadata with optional local fields via widening cast to avoid breaking public types\r\n      const meta: any = {\r\n        modelUsed: modelLabel,\r\n        provider: 'openai',\r\n        costEstimate,\r\n        durationMs,\r\n        confidence,\r\n        cached: false,\r\n      };\r\n      if (budgeted.meta) {\r\n        meta.trimmed = true;\r\n        meta.trimDetails = budgeted.meta;\r\n      }\r\n      meta.tokensInputEstimated = inputTokensEstimate;\r\n      meta.tokensOutputEstimated = outputTokensEstimate;\r\n      meta.costBreakdownUSD = breakdown;\r\n\r\n      const out: AnalysisResponse = {\r\n        issues: normalized.issues,\r\n        // Cast to satisfy AnalysisResponse without altering public type\r\n        metadata: meta as AnalysisResponse['metadata'],\r\n      };\r\n\r\n      return out;\r\n    } catch (err) {\r\n      // TODO: Replace with production logger\r\n      console.log('[OpenAIProvider] analyze error:', err);\r\n      if (err instanceof ValidationError) {\r\n        throw err;\r\n      }\r\n      if (err && typeof err === 'object' && (err as Error).name === 'CircuitBreakerOpenError') {\r\n        throw err;\r\n      }\r\n      throw new ProviderError('openai', 'OpenAI analyze failed', { cause: err });\r\n    }\r\n  }\r\n}\r\n\r\nexport default OpenAIProvider;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\__tests__\\ProviderBudgets.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\schemas\\ResponseSchemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\schemas\\__tests__\\ResponseSchemas.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":76,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":76,"endColumn":30,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[1762,1814],"text":"type ClaudeConfig = BaseProviderConfig"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":81,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":81,"endColumn":30,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[1870,1922],"text":"type OpenAIConfig = BaseProviderConfig"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":86,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":86,"endColumn":30,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[1987,2039],"text":"type GeminiConfig = BaseProviderConfig"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI service shared types for continuity analysis\r\n// Strict TypeScript compatible\r\n\r\nimport { Scene, ContinuityIssue, ReaderKnowledge } from '../../shared/types';\r\n\r\n/**\r\n * Provider identifiers supported by this AI subsystem.\r\n */\r\nexport type ProviderName = 'anthropic' | 'openai' | 'google';\r\n\r\n/**\r\n * Describes a model's strengths and operational constraints for routing.\r\n */\r\nexport interface ModelCapabilities {\r\n  model: string;\r\n  provider: ProviderName;\r\n  strengths: Array<\r\n    | 'narrative-flow'\r\n    | 'character-voice'\r\n    | 'complex-reasoning'\r\n    | 'deep-analysis'\r\n    | 'instruction-following'\r\n    | 'validation'\r\n    | 'full-manuscript'\r\n    | 'bulk-analysis'\r\n  >;\r\n  costTier: 'low' | 'medium' | 'high';\r\n  maxTokens?: number;\r\n}\r\n\r\n/**\r\n * Variants of analysis the system can perform.\r\n */\r\nexport type AnalysisType = 'simple' | 'consistency' | 'complex' | 'full';\r\n\r\n/**\r\n * Request payload for continuity analysis.\r\n */\r\nexport interface AnalysisRequest {\r\n  scene: Scene;\r\n  previousScenes: Scene[];\r\n  analysisType: AnalysisType;\r\n  readerContext: ReaderKnowledge;\r\n}\r\n\r\n/**\r\n * Normalized response from any provider after validation.\r\n */\r\nexport interface AnalysisResponse {\r\n  issues: ContinuityIssue[];\r\n  metadata: {\r\n    modelUsed: string;\r\n    provider: ProviderName;\r\n    costEstimate: number;\r\n    durationMs: number;\r\n    confidence: number;\r\n    cached: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Base configuration for providers.\r\n * TODO: Integrate Electron safeStorage for apiKey handling in production.\r\n */\r\nexport interface BaseProviderConfig {\r\n  apiKey: string;\r\n  model?: string;\r\n  timeoutMs?: number;\r\n  rateLimitPerMin?: number;\r\n  baseUrl?: string;\r\n}\r\n\r\n/**\r\n * Claude (Anthropic) provider configuration.\r\n */\r\nexport interface ClaudeConfig extends BaseProviderConfig {}\r\n\r\n/**\r\n * OpenAI provider configuration.\r\n */\r\nexport interface OpenAIConfig extends BaseProviderConfig {}\r\n\r\n/**\r\n * Gemini (Google) provider configuration.\r\n */\r\nexport interface GeminiConfig extends BaseProviderConfig {}\r\n\r\n/**\r\n * Base error for provider-related failures.\r\n */\r\nexport class ProviderError extends Error {\r\n  public readonly provider: ProviderName;\r\n  public readonly status?: number;\r\n  public readonly isRetriable: boolean;\r\n  public readonly causeOriginal?: unknown;\r\n\r\n  constructor(\r\n    provider: ProviderName,\r\n    message: string,\r\n    options?: { status?: number; cause?: unknown; retriable?: boolean }\r\n  ) {\r\n    super(message);\r\n    this.name = 'ProviderError';\r\n    this.provider = provider;\r\n    this.status = options?.status;\r\n    this.isRetriable = Boolean(options?.retriable);\r\n    this.causeOriginal = options?.cause;\r\n  }\r\n}\r\n\r\n/**\r\n * Specialized error for rate limit exceedance (HTTP 429, etc).\r\n */\r\nexport class RateLimitError extends Error {\r\n  public readonly provider: ProviderName;\r\n\r\n  constructor(provider: ProviderName, message = 'Rate limit exceeded') {\r\n    super(message);\r\n    this.name = 'RateLimitError';\r\n    this.provider = provider;\r\n  }\r\n}\r\n\r\n/**\r\n * Schema or shape validation failure for provider outputs.\r\n */\r\nexport class ValidationError extends Error {\r\n  public readonly provider: ProviderName;\r\n\r\n  constructor(provider: ProviderName, message = 'Response validation failed') {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n    this.provider = provider;\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown when a provider's circuit breaker is OPEN.\r\n */\r\nexport class CircuitBreakerOpenError extends Error {\r\n  public readonly provider: string;\r\n\r\n  constructor(provider: string, message = 'Circuit breaker open') {\r\n    super(message);\r\n    this.name = 'CircuitBreakerOpenError';\r\n    this.provider = provider;\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown when a provider call times out.\r\n */\r\nexport class TimeoutError extends Error {\r\n  public readonly provider: ProviderName;\r\n  public readonly timeoutMs: number;\r\n\r\n  constructor(provider: ProviderName, timeoutMs: number, message?: string) {\r\n    super(message ?? `Request timed out after ${timeoutMs}ms`);\r\n    this.name = 'TimeoutError';\r\n    this.provider = provider;\r\n    this.timeoutMs = timeoutMs;\r\n  }\r\n}\r\n// Extend AnalysisRequest to support custom prompts for rewriting\r\nexport interface AnalysisRequestExtension {\r\n  customPrompt?: string;\r\n  isRewriteRequest?: boolean;\r\n  preserveElements?: string[];\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\CircuitBreaker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\ResponseValidator.ts","messages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":450,"column":20,"nodeType":"Literal","messageId":"unexpected","endLine":450,"endColumn":38},{"ruleId":"no-redeclare","severity":2,"message":"'validateAndNormalize' is already defined.","line":747,"column":17,"nodeType":"Identifier","messageId":"redeclared","endLine":747,"endColumn":37},{"ruleId":"no-redeclare","severity":2,"message":"'validateAndNormalize' is already defined.","line":753,"column":17,"nodeType":"Identifier","messageId":"redeclared","endLine":753,"endColumn":37}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AnalysisResponse as AppAnalysisResponse, ProviderName, ValidationError } from '../types';\r\nimport type { ContinuityIssue } from '../../../shared/types';\r\nimport { z } from 'zod';\r\nimport {\r\n  AnalysisResponseSchema as AnalysisResponseZodSchema,\r\n  type AnalysisResponse as ModelAnalysisResponse,\r\n  IssueTypeEnum,\r\n  SeverityEnum,\r\n} from '../schemas/ResponseSchemas';\r\n\r\n/**\r\n * Minimal parser interface compatible with previous .parse(...) usage.\r\n * Each schema function returns an object with a parse method that throws on invalid input.\r\n */\r\ntype Parser<T> = {\r\n  parse(value: unknown): T;\r\n};\r\n\r\n// ------------ Internal helpers and type guards (legacy compatibility) ------------\r\n\r\nconst ISSUE_TYPES = ['pronoun', 'timeline', 'character', 'plot', 'context', 'engagement'] as const;\r\nconst ISSUE_SEVERITIES = ['must-fix', 'should-fix', 'consider'] as const;\r\n\r\nfunction isObject(v: unknown): v is Record<string, unknown> {\r\n  return v !== null && typeof v === 'object';\r\n}\r\nfunction isString(v: unknown): v is string {\r\n  return typeof v === 'string';\r\n}\r\nfunction isBoolean(v: unknown): v is boolean {\r\n  return typeof v === 'boolean';\r\n}\r\nfunction isNumberFinite(v: unknown): v is number {\r\n  return typeof v === 'number' && Number.isFinite(v);\r\n}\r\nfunction isIntegerNonNegative(v: unknown): v is number {\r\n  return isNumberFinite(v) && Number.isInteger(v) && v >= 0;\r\n}\r\nfunction isProviderName(v: unknown): v is ProviderName {\r\n  return v === 'anthropic' || v === 'openai' || v === 'google';\r\n}\r\n\r\nfunction isTextSpan(v: unknown): v is [number, number] {\r\n  return (\r\n    Array.isArray(v) &&\r\n    v.length === 2 &&\r\n    isIntegerNonNegative(v[0]) &&\r\n    isIntegerNonNegative(v[1]) &&\r\n    v[0] <= v[1]\r\n  );\r\n}\r\n\r\n/**\r\n * Runtime guard for ContinuityIssue (legacy ContinuityIssue used across app).\r\n */\r\nfunction isContinuityIssue(v: unknown): v is ContinuityIssue {\r\n  if (!isObject(v)) return false;\r\n  const type = (v as Record<string, unknown>).type;\r\n  const severity = (v as Record<string, unknown>).severity;\r\n  const description = (v as Record<string, unknown>).description;\r\n  const textSpan = (v as Record<string, unknown>).textSpan;\r\n  const suggestedFix = (v as Record<string, unknown>).suggestedFix;\r\n\r\n  if (!(isString(type) && (ISSUE_TYPES as readonly string[]).includes(type))) return false;\r\n  if (!(isString(severity) && (ISSUE_SEVERITIES as readonly string[]).includes(severity))) return false;\r\n  if (!isString(description)) return false;\r\n  if (!isTextSpan(textSpan)) return false;\r\n  if (suggestedFix !== undefined && !isString(suggestedFix)) return false;\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Validates and narrows the optional metadata block for normalized responses.\r\n * Returns undefined if input is undefined. Throws detailed Error on invalid inputs.\r\n */\r\nfunction validateNormalizedMetadata(\r\n  meta: unknown\r\n):\r\n  | {\r\n      modelUsed?: string;\r\n      provider?: ProviderName;\r\n      costEstimate?: number;\r\n      durationMs?: number;\r\n      confidence?: number;\r\n      cached?: boolean;\r\n    }\r\n  | undefined {\r\n  if (meta === undefined) return undefined;\r\n  if (!isObject(meta)) throw new Error(\"Invalid normalized response: 'metadata' must be an object\");\r\n\r\n  const out: {\r\n    modelUsed?: string;\r\n    provider?: ProviderName;\r\n    costEstimate?: number;\r\n    durationMs?: number;\r\n    confidence?: number;\r\n    cached?: boolean;\r\n  } = {};\r\n\r\n  if ((meta as Record<string, unknown>).modelUsed !== undefined) {\r\n    if (!isString((meta as Record<string, unknown>).modelUsed))\r\n      throw new Error(\"Invalid normalized response: 'metadata.modelUsed' must be a string\");\r\n    out.modelUsed = (meta as Record<string, unknown>).modelUsed as string;\r\n  }\r\n  if ((meta as Record<string, unknown>).provider !== undefined) {\r\n    if (!isProviderName((meta as Record<string, unknown>).provider))\r\n      throw new Error(\r\n        \"Invalid normalized response: 'metadata.provider' must be 'anthropic' | 'openai' | 'google'\"\r\n      );\r\n    out.provider = (meta as Record<string, unknown>).provider as ProviderName;\r\n  }\r\n  if ((meta as Record<string, unknown>).costEstimate !== undefined) {\r\n    if (!isNumberFinite((meta as Record<string, unknown>).costEstimate))\r\n      throw new Error(\"Invalid normalized response: 'metadata.costEstimate' must be a finite number\");\r\n    out.costEstimate = (meta as Record<string, unknown>).costEstimate as number;\r\n  }\r\n  if ((meta as Record<string, unknown>).durationMs !== undefined) {\r\n    if (!isNumberFinite((meta as Record<string, unknown>).durationMs))\r\n      throw new Error(\"Invalid normalized response: 'metadata.durationMs' must be a finite number\");\r\n    out.durationMs = (meta as Record<string, unknown>).durationMs as number;\r\n  }\r\n  if ((meta as Record<string, unknown>).confidence !== undefined) {\r\n    const c = (meta as Record<string, unknown>).confidence;\r\n    if (!isNumberFinite(c) || (c as number) < 0 || (c as number) > 1) {\r\n      throw new Error(\"Invalid normalized response: 'metadata.confidence' must be a number in [0,1]\");\r\n    }\r\n    out.confidence = c as number;\r\n  }\r\n  if ((meta as Record<string, unknown>).cached !== undefined) {\r\n    if (!isBoolean((meta as Record<string, unknown>).cached))\r\n      throw new Error(\"Invalid normalized response: 'metadata.cached' must be a boolean\");\r\n    out.cached = (meta as Record<string, unknown>).cached as boolean;\r\n  }\r\n  return out;\r\n}\r\n\r\n// ------------ Raw provider response shapes and guards (envelopes) ------------\r\n\r\ninterface OpenAIChatMessage {\r\n  role?: string;\r\n  content: string;\r\n}\r\ninterface OpenAIChoice {\r\n  index?: number;\r\n  message: OpenAIChatMessage;\r\n  finish_reason?: string;\r\n}\r\ninterface OpenAIChatResponse {\r\n  id?: string;\r\n  object?: string;\r\n  choices: OpenAIChoice[];\r\n  usage?: {\r\n    prompt_tokens?: number;\r\n    completion_tokens?: number;\r\n    total_tokens?: number;\r\n  };\r\n}\r\n\r\nfunction isOpenAIChatResponse(v: unknown): v is OpenAIChatResponse {\r\n  if (!isObject(v)) return false;\r\n  const choices = (v as Record<string, unknown>).choices;\r\n  if (!Array.isArray(choices) || choices.length < 1) return false;\r\n\r\n  const first = choices[0];\r\n  if (!isObject(first)) return false;\r\n  const message = (first as Record<string, unknown>).message;\r\n  if (!isObject(message)) return false;\r\n  const content = (message as Record<string, unknown>).content;\r\n  if (!isString(content)) return false;\r\n\r\n  return true;\r\n}\r\n\r\ninterface AnthropicContentItem {\r\n  type?: string;\r\n  text: string;\r\n}\r\ninterface AnthropicResponse {\r\n  id?: string;\r\n  type?: string;\r\n  role?: string;\r\n  model?: string;\r\n  content: AnthropicContentItem[];\r\n  usage?: {\r\n    input_tokens?: number;\r\n    output_tokens?: number;\r\n  };\r\n}\r\n\r\nfunction isAnthropicResponse(v: unknown): v is AnthropicResponse {\r\n  if (!isObject(v)) return false;\r\n  const content = (v as Record<string, unknown>).content;\r\n  if (!Array.isArray(content) || content.length < 1) return false;\r\n  const first = content[0];\r\n  if (!isObject(first)) return false;\r\n  const text = (first as Record<string, unknown>).text;\r\n  if (!isString(text)) return false;\r\n  return true;\r\n}\r\n\r\ninterface GeminiPart {\r\n  text?: string;\r\n}\r\ninterface GeminiContent {\r\n  role?: string;\r\n  parts: GeminiPart[];\r\n}\r\ninterface GeminiCandidate {\r\n  content: GeminiContent;\r\n  finishReason?: string;\r\n}\r\ninterface GeminiResponse {\r\n  candidates: GeminiCandidate[];\r\n  promptFeedback?: unknown;\r\n}\r\n\r\nfunction isGeminiResponse(v: unknown): v is GeminiResponse {\r\n  if (!isObject(v)) return false;\r\n  const candidates = (v as Record<string, unknown>).candidates;\r\n  if (!Array.isArray(candidates) || candidates.length < 1) return false;\r\n  const first = candidates[0];\r\n  if (!isObject(first)) return false;\r\n  const content = (first as Record<string, unknown>).content;\r\n  if (!isObject(content)) return false;\r\n  const parts = (content as Record<string, unknown>).parts;\r\n  if (!Array.isArray(parts) || parts.length < 1) return false;\r\n  // Not all parts must have text, but structure must exist\r\n  return true;\r\n}\r\n\r\n// ------------ Raw provider \"schema\" factories (public API compatible) ------------\r\n\r\n/**\r\n * OpenAI chat.completions \"schema\" returning a parser with .parse(raw).\r\n * Ensures choices[0].message.content is a string.\r\n */\r\nexport function openAIChatSchema(): Parser<OpenAIChatResponse> {\r\n  return {\r\n    parse(raw: unknown): OpenAIChatResponse {\r\n      if (!isOpenAIChatResponse(raw)) {\r\n        throw new Error('Invalid OpenAI chat response: expected choices[0].message.content as string');\r\n      }\r\n      return raw;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Anthropic Messages API \"schema\" returning a parser with .parse(raw).\r\n * Ensures content[0].text is a string.\r\n */\r\nexport function anthropicSchema(): Parser<AnthropicResponse> {\r\n  return {\r\n    parse(raw: unknown): AnthropicResponse {\r\n      if (!isAnthropicResponse(raw)) {\r\n        throw new Error('Invalid Anthropic response: expected content[0].text as string');\r\n      }\r\n      return raw;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Google Gemini generateContent \"schema\" returning a parser with .parse(raw).\r\n * Ensures candidates[0].content.parts exists; later we find a part with non-empty text.\r\n */\r\nexport function geminiSchema(): Parser<GeminiResponse> {\r\n  return {\r\n    parse(raw: unknown): GeminiResponse {\r\n      if (!isGeminiResponse(raw)) {\r\n        throw new Error('Invalid Gemini response: expected candidates[0].content.parts array');\r\n      }\r\n      return raw;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Legacy normalized response \"schema\" for ContinuityIssue[] (kept for compatibility).\r\n * Public export maintained to avoid breaking external imports.\r\n */\r\nexport function normalizedResponseSchema(): Parser<{\r\n  issues: ContinuityIssue[];\r\n  metadata?:\r\n    | {\r\n        modelUsed?: string;\r\n        provider?: ProviderName;\r\n        costEstimate?: number;\r\n        durationMs?: number;\r\n        confidence?: number;\r\n        cached?: boolean;\r\n      }\r\n    | undefined;\r\n}> {\r\n  return {\r\n    parse(\r\n      raw: unknown\r\n    ): {\r\n      issues: ContinuityIssue[];\r\n      metadata?:\r\n        | {\r\n            modelUsed?: string;\r\n            provider?: ProviderName;\r\n            costEstimate?: number;\r\n            durationMs?: number;\r\n            confidence?: number;\r\n            cached?: boolean;\r\n          }\r\n        | undefined;\r\n    } {\r\n      if (!isObject(raw)) {\r\n        throw new Error('Invalid normalized response: expected an object');\r\n      }\r\n\r\n      const issuesRaw = (raw as Record<string, unknown>).issues;\r\n      let issues: ContinuityIssue[] = [];\r\n      if (issuesRaw === undefined) {\r\n        issues = [];\r\n      } else {\r\n        if (!Array.isArray(issuesRaw)) {\r\n          throw new Error(\"Invalid normalized response: 'issues' must be an array\");\r\n        }\r\n        issuesRaw.forEach((item, idx) => {\r\n          if (!isContinuityIssue(item)) {\r\n            // Provide a precise messaging on failure\r\n            throw new Error(`Invalid ContinuityIssue at index ${idx}`);\r\n          }\r\n        });\r\n        issues = issuesRaw as ContinuityIssue[];\r\n      }\r\n\r\n      const metadata = validateNormalizedMetadata((raw as Record<string, unknown>).metadata);\r\n\r\n      return { issues, metadata };\r\n    },\r\n  };\r\n}\r\n\r\n// ------------ Utilities: JSON extraction and sanitization ------------\r\n\r\n/**\r\n * Extract the first JSON object from arbitrary text using bracket counting.\r\n * Handles nested braces and ignores braces inside strings.\r\n */\r\nexport function extractJsonFromText(text: string): string {\r\n  // Strip code fences if present\r\n  const fenceMatch = text.match(/```(?:json)?\\s*([\\s\\S]*?)```/i);\r\n  if (fenceMatch) {\r\n    text = fenceMatch[1];\r\n  }\r\n\r\n  let start = -1;\r\n  let depth = 0;\r\n  let inString: false | '\"' | \"'\" = false;\r\n  let escape = false;\r\n\r\n  for (let i = 0; i < text.length; i++) {\r\n    const ch = text[i];\r\n\r\n    if (inString) {\r\n      if (escape) {\r\n        escape = false;\r\n      } else if (ch === '\\\\') {\r\n        escape = true;\r\n      } else if (ch === inString) {\r\n        inString = false;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (ch === '\"' || ch === \"'\") {\r\n      inString = ch as '\"' | \"'\";\r\n      continue;\r\n    }\r\n\r\n    if (ch === '{') {\r\n      if (depth === 0) start = i;\r\n      depth++;\r\n    } else if (ch === '}') {\r\n      depth--;\r\n      if (depth === 0 && start !== -1) {\r\n        return text.slice(start, i + 1);\r\n      }\r\n    }\r\n  }\r\n  // Fallback: trim and try if entire string looks like JSON\r\n  const trimmed = text.trim();\r\n  if (trimmed.startsWith('{') && trimmed.endsWith('}')) return trimmed;\r\n  throw new Error('No JSON object found in text');\r\n}\r\n\r\nfunction stripBOM(s: string): string {\r\n  return s.charCodeAt(0) === 0xfeff ? s.slice(1) : s;\r\n}\r\nfunction replaceSmartQuotes(s: string): string {\r\n  return s\r\n    .replace(/[\\u2018\\u2019\\u201A\\u201B]/g, \"'\")\r\n    .replace(/[\\u201C\\u201D\\u201E\\u201F]/g, '\"');\r\n}\r\nfunction removeComments(s: string): string {\r\n  // Remove //... and /* ... */\r\n  return s.replace(/\\/\\/[^\\n\\r]*|\\/\\*[\\s\\S]*?\\*\\//g, '');\r\n}\r\nfunction removeTrailingCommas(s: string): string {\r\n  // Remove trailing commas before } or ]\r\n  return s.replace(/,(\\s*[}\\]])/g, '$1');\r\n}\r\nfunction fixSingleQuotedKeysAndStrings(s: string): string {\r\n  // 'key': value  -> \"key\": value\r\n  s = s.replace(/([{,\\s])'([A-Za-z0-9_]+)'\\s*:/g, '$1\"$2\":');\r\n  // :\"value'like\" -> conservative conversion for single-quoted string values\r\n  s = s.replace(/:\\s*'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'/g, ': \"$1\"');\r\n  return s;\r\n}\r\nfunction quoteUnquotedKeys(s: string): string {\r\n  // { key: ... , another_key: ... } -> quote keys\r\n  return s.replace(/([{,\\s])([A-Za-z_][A-Za-z0-9_]*)\\s*:/g, '$1\"$2\":');\r\n}\r\nfunction sanitizeJsonLike(s: string, { quoteKeys = false }: { quoteKeys?: boolean } = {}): string {\r\n  let out = stripBOM(s);\r\n  out = replaceSmartQuotes(out);\r\n  out = removeComments(out);\r\n  out = removeTrailingCommas(out);\r\n  out = fixSingleQuotedKeysAndStrings(out);\r\n  if (quoteKeys) {\r\n    out = quoteUnquotedKeys(out);\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Fallback slice for the outermost JSON object when strict extraction fails.\r\n * Returns substring between the first '{' and the last '}' if present.\r\n */\r\nfunction sliceOuterJson(s: string): string | null {\r\n  const start = s.indexOf('{');\r\n  const end = s.lastIndexOf('}');\r\n  if (start !== -1 && end !== -1 && end > start) {\r\n    return s.slice(start, end + 1);\r\n  }\r\n  return null;\r\n}\r\n\r\n// ------------ Model response normalization and confidence scoring ------------\r\n\r\nexport type ValidationMeta = { attempts: number; repaired: boolean; errors: string[] };\r\n\r\nfunction cleanText(s: string): string {\r\n  return s.replace(/[\\x00-\\x1F\\x7F]/g, '').trim();\r\n}\r\n\r\nfunction clamp01(x: number): number {\r\n  if (!Number.isFinite(x)) return 0;\r\n  return Math.max(0, Math.min(1, x));\r\n}\r\n\r\nfunction normalizeModelData(parsed: ModelAnalysisResponse): ModelAnalysisResponse {\r\n  // Clone to avoid mutation of caller data\r\n  const data: ModelAnalysisResponse = {\r\n    issues: Array.isArray(parsed.issues) ? [...parsed.issues] : [],\r\n    summary: typeof parsed.summary === 'string' ? parsed.summary : '',\r\n    confidence: typeof parsed.confidence === 'number' ? clamp01(parsed.confidence) : undefined,\r\n  };\r\n\r\n  data.summary = cleanText(data.summary);\r\n\r\n  const severityValues = SeverityEnum.options as readonly z.infer<typeof SeverityEnum>[];\r\n  const typeValues = IssueTypeEnum.options as readonly z.infer<typeof IssueTypeEnum>[];\r\n\r\n  data.issues = data.issues.map((issue: ModelAnalysisResponse['issues'][number]) => {\r\n    let severity = issue.severity;\r\n    // Case-insensitive severity coercion if needed (best-effort; schema enforces valid already)\r\n    const sevLower = String(severity).toLowerCase();\r\n    const sevCoerced = severityValues.find((v: z.infer<typeof SeverityEnum>) => v.toLowerCase() === sevLower) ?? severity;\r\n    severity = sevCoerced as typeof issue.severity;\r\n\r\n    let type = issue.type;\r\n    const typeLower = String(type).toLowerCase();\r\n    const typeCoerced =\r\n      typeValues.find((v: z.infer<typeof IssueTypeEnum>) => v.toLowerCase() === typeLower) ?? type;\r\n    type = typeCoerced as typeof issue.type;\r\n\r\n    // Span normalization\r\n    let span = issue.span ?? null;\r\n    if (span) {\r\n      const start = Math.max(0, Math.min(Number.MAX_SAFE_INTEGER, Math.trunc(span.start_index)));\r\n      const end = Math.max(0, Math.min(Number.MAX_SAFE_INTEGER, Math.trunc(span.end_index)));\r\n      span = {\r\n        start_index: Math.max(0, Math.min(start, end)),\r\n        end_index: Math.max(start, end),\r\n      };\r\n    }\r\n\r\n    // Strings cleanup\r\n    const explanation = cleanText(issue.explanation ?? '');\r\n    const suggested_fix = cleanText(issue.suggested_fix ?? '');\r\n\r\n    // Evidence cleanup, dedupe and cap\r\n    const seen = new Set<string>();\r\n    const evidence =\r\n      Array.isArray(issue.evidence) ? issue.evidence.map((e: string) => cleanText(e)).filter((e: string) => e.length > 0) : [];\r\n    const deduped: string[] = [];\r\n    for (const e of evidence) {\r\n      const key = e.toLowerCase();\r\n      if (!seen.has(key)) {\r\n        seen.add(key);\r\n        deduped.push(e);\r\n      }\r\n      if (deduped.length >= 10) break;\r\n    }\r\n\r\n    // Confidence clamp if present\r\n    let conf = issue.confidence;\r\n    if (typeof conf === 'number') {\r\n      conf = clamp01(conf);\r\n    }\r\n\r\n    return {\r\n      type,\r\n      severity,\r\n      span: span ?? null,\r\n      explanation,\r\n      evidence: deduped,\r\n      suggested_fix,\r\n      confidence: conf,\r\n    };\r\n  });\r\n\r\n  // Backfill issue confidences heuristically if missing\r\n  const sevWeights: Record<z.infer<typeof SeverityEnum>, number> = {\r\n    low: 0.4,\r\n    medium: 0.6,\r\n    high: 0.8,\r\n    critical: 0.9,\r\n  };\r\n\r\n  data.issues = data.issues.map((issue: ModelAnalysisResponse['issues'][number]) => {\r\n    if (typeof issue.confidence === 'number') return issue;\r\n    let score = sevWeights[issue.severity] ?? 0.5;\r\n    const bonus = Math.min(0.1, (issue.evidence?.length ?? 0) * 0.02);\r\n    score += bonus;\r\n    if (issue.span && Number.isFinite(issue.span.start_index) && Number.isFinite(issue.span.end_index)) {\r\n      score += 0.05;\r\n    }\r\n    // Clamp into [0.35, 0.98]\r\n    score = Math.max(0.35, Math.min(0.98, score));\r\n    return { ...issue, confidence: clamp01(score) };\r\n  });\r\n\r\n  if (data.confidence === undefined) {\r\n    const confidences = data.issues.map((i: ModelAnalysisResponse['issues'][number]) => i.confidence ?? 0);\r\n    const mean = confidences.length ? confidences.reduce((a: number, b: number) => a + b, 0) / confidences.length : 0;\r\n    data.confidence = clamp01(mean);\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n// ------------ Parsing pipeline with retries and fallbacks ------------\r\n\r\ntype ParseAttemptResult =\r\n  | { ok: true; data: ModelAnalysisResponse; meta: ValidationMeta }\r\n  | { ok: false; meta: ValidationMeta };\r\n\r\nfunction tryZodValidate(candidate: unknown): { ok: true; data: ModelAnalysisResponse } | { ok: false; error: string } {\r\n  const res = AnalysisResponseZodSchema.safeParse(candidate);\r\n  if (res.success) return { ok: true, data: res.data };\r\n  return { ok: false, error: res.error.errors.map((e: z.ZodIssue) => e.message).join('; ') };\r\n}\r\n\r\nfunction parseModelOutputToZod(raw: unknown, retries = 3): ParseAttemptResult {\r\n  const errors: string[] = [];\r\n  let attempts = 0;\r\n  let repaired = false;\r\n  let extractedSub: string | null = null;\r\n\r\n  // 0) Already-object case\r\n  if (isObject(raw)) {\r\n    attempts++;\r\n    const z = tryZodValidate(raw);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    } else {\r\n      errors.push(`Zod validation failed on object: ${z.error}`);\r\n      // Continue to stringify-sanitize attempts below\r\n    }\r\n  }\r\n\r\n  const rawStr = isString(raw) ? raw : (() => {\r\n    try {\r\n      return JSON.stringify(raw);\r\n    } catch {\r\n      return '';\r\n    }\r\n  })();\r\n\r\n  // Strategy 1: Strict JSON.parse on full string\r\n  attempts++;\r\n  try {\r\n    const candidate = JSON.parse(stripBOM(rawStr));\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed on strict JSON: ${z.error}`);\r\n  } catch (e) {\r\n    errors.push(`Strict JSON.parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 2: Extract first top-level JSON object substring (handles fences too)\r\n  attempts++;\r\n  try {\r\n    const jsonSub = extractJsonFromText(rawStr);\r\n    extractedSub = jsonSub;\r\n    if (jsonSub !== rawStr) repaired = true;\r\n    const candidate = JSON.parse(jsonSub);\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed on extracted JSON: ${z.error}`);\r\n  } catch (e) {\r\n    // Keep extractedSub as whatever was found (if any), but note failure\r\n    repaired = true;\r\n    errors.push(`Extraction/parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 3: Sanitize common issues (smart quotes, single quotes, trailing commas, comments)\r\n  attempts++;\r\n  try {\r\n    const base = extractedSub ?? sliceOuterJson(rawStr) ?? rawStr;\r\n    const sanitized = sanitizeJsonLike(base);\r\n    if (sanitized !== base) repaired = true;\r\n    const candidate = JSON.parse(sanitized);\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed after sanitize: ${z.error}`);\r\n  } catch (e) {\r\n    repaired = true;\r\n    errors.push(`Sanitize/parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 3b: Quote unquoted keys conservatively\r\n  attempts++;\r\n  try {\r\n    const base = extractedSub ?? sliceOuterJson(rawStr) ?? rawStr;\r\n    const sanitized = sanitizeJsonLike(base, { quoteKeys: true });\r\n    if (sanitized !== base) repaired = true;\r\n    const candidate = JSON.parse(sanitized);\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed after quoting keys: ${z.error}`);\r\n  } catch (e) {\r\n    repaired = true;\r\n    errors.push(`Quote-keys/parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 4: JSON5 (optional, skipped if not installed)\r\n  // Note: json5 is not in deps by default; skip silently.\r\n  // If added later, this can be enabled with a dynamic import.\r\n\r\n  // Respect retries cap (we have already performed multiple attempts)\r\n  if (attempts >= Math.max(1, retries)) {\r\n    return { ok: false, meta: { attempts, repaired, errors } };\r\n  }\r\n\r\n  return { ok: false, meta: { attempts, repaired, errors } };\r\n}\r\n\r\n// ------------ Provider payload extraction (envelopes) ------------\r\n\r\nfunction extractTextPayload(provider: ProviderName, raw: unknown): string {\r\n  if (provider === 'openai') {\r\n    const parsed = openAIChatSchema().parse(raw);\r\n    return parsed.choices[0].message.content;\r\n  }\r\n  if (provider === 'anthropic') {\r\n    const parsed = anthropicSchema().parse(raw);\r\n    return parsed.content[0].text;\r\n  }\r\n  // google\r\n  const parsed = geminiSchema().parse(raw);\r\n  const parts = parsed.candidates[0]?.content?.parts ?? [];\r\n  const firstWithText = parts.find(\r\n    (p: { text?: string }) => typeof p.text === 'string' && ((p.text?.length ?? 0) > 0)\r\n  );\r\n  if (!firstWithText || !firstWithText.text) {\r\n    throw new Error('No text part found in Gemini response');\r\n  }\r\n  return firstWithText.text;\r\n}\r\n\r\n// ------------ Mapping to application-level AnalysisResponse (legacy) ------------\r\n\r\nfunction mapIssueTypeToLegacy(t: z.infer<typeof IssueTypeEnum>): ContinuityIssue['type'] {\r\n  switch (t) {\r\n    case 'pronoun_reference':\r\n      return 'pronoun';\r\n    case 'timeline':\r\n      return 'timeline';\r\n    case 'character_knowledge':\r\n      return 'character';\r\n    case 'other':\r\n    default:\r\n      return 'context';\r\n  }\r\n}\r\n\r\nfunction mapSeverityToLegacy(s: z.infer<typeof SeverityEnum>): ContinuityIssue['severity'] {\r\n  switch (s) {\r\n    case 'low':\r\n      return 'consider';\r\n    case 'medium':\r\n      return 'should-fix';\r\n    case 'high':\r\n    case 'critical':\r\n    default:\r\n      return 'must-fix';\r\n  }\r\n}\r\n\r\nfunction modelToLegacyIssues(data: ModelAnalysisResponse): ContinuityIssue[] {\r\n  return (data.issues ?? []).map((i: ModelAnalysisResponse['issues'][number]) => {\r\n    const start = i.span?.start_index ?? 0;\r\n    const end = i.span?.end_index ?? Math.max(0, start);\r\n    return {\r\n      type: mapIssueTypeToLegacy(i.type),\r\n      severity: mapSeverityToLegacy(i.severity),\r\n      description: i.explanation ?? '',\r\n      textSpan: [Math.max(0, Math.trunc(start)), Math.max(0, Math.trunc(end))],\r\n      suggestedFix: i.suggested_fix ? String(i.suggested_fix) : undefined,\r\n    };\r\n  });\r\n}\r\n\r\n// ------------ Public API (overloaded) ------------\r\n\r\nexport function validateAndNormalize(\r\n  raw: unknown,\r\n  options?: { retries?: number }\r\n): { data: ModelAnalysisResponse; meta: ValidationMeta };\r\nexport function validateAndNormalize(\r\n  provider: ProviderName,\r\n  raw: unknown,\r\n  fallbackModelLabel: string\r\n): AppAnalysisResponse;\r\n// Implementation\r\nexport function validateAndNormalize(\r\n  a: unknown,\r\n  b?: unknown,\r\n  c?: unknown\r\n): { data: ModelAnalysisResponse; meta: ValidationMeta } | AppAnalysisResponse {\r\n  // Overload dispatcher\r\n  if (isProviderName(a)) {\r\n    // Legacy API: (provider, raw, fallbackModelLabel) -> AppAnalysisResponse\r\n    const provider = a as ProviderName;\r\n    const raw = b as unknown;\r\n    const fallbackModelLabel = String(c ?? '');\r\n    try {\r\n      const payloadText = extractTextPayload(provider, raw);\r\n      const result = parseModelOutputToZod(payloadText, 4);\r\n      if (!result.ok) {\r\n        throw new ValidationError(provider, 'Response validation failed');\r\n      }\r\n      const modelData = result.data; // already normalized and confidences filled\r\n      const legacy: AppAnalysisResponse = {\r\n        issues: modelToLegacyIssues(modelData),\r\n        metadata: {\r\n          modelUsed: fallbackModelLabel,\r\n          provider,\r\n          costEstimate: 0,\r\n          durationMs: 0,\r\n          confidence: typeof modelData.confidence === 'number' ? modelData.confidence : 0,\r\n          cached: false,\r\n        },\r\n      };\r\n      return legacy;\r\n    } catch {\r\n      throw new ValidationError(a as ProviderName, 'Response validation failed');\r\n    }\r\n  } else {\r\n    // New primary API: (raw, options?) -> { data, meta }\r\n    const retries = isObject(b) && isNumberFinite((b as any).retries) ? Math.max(1, Math.trunc((b as any).retries)) : 4;\r\n    const result = parseModelOutputToZod(a, retries);\r\n    if (!result.ok) {\r\n      return { data: { issues: [], summary: '', confidence: 0 }, meta: result.meta };\r\n    }\r\n    return { data: result.data, meta: result.meta };\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\Tokenizers.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":74,"column":11,"nodeType":"BlockStatement","messageId":"unexpected","endLine":74,"endColumn":13,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2934,2934],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":92,"column":41,"nodeType":"BlockStatement","messageId":"unexpected","endLine":92,"endColumn":43,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3716,3716],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":105,"column":11,"nodeType":"BlockStatement","messageId":"unexpected","endLine":105,"endColumn":13,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4111,4111],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":150,"column":13,"nodeType":"BlockStatement","messageId":"unexpected","endLine":150,"endColumn":15,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[5360,5360],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Tokenizers.ts\r\n// Pure utilities for token estimation with optional dynamic tokenizer support.\r\n// - No hard dependency on tokenizer libraries; best-effort dynamic import attempted without logging.\r\n// - Deterministic outputs for the same inputs (no randomness).\r\n//\r\n// Encoding notes (OpenAI):\r\n// - GPT-3.5/4/4o/gpt-* typically use cl100k_base; o-series may use o200k_base where available.\r\n// - We map broadly and fall back to heuristics if encodings/libs are unavailable.\r\n//\r\n// Claude/Gemini:\r\n// - No official JS tokenizer readily available; we approximate with chars-per-token heuristics when dynamic libs aren't present.\r\n//\r\n// Heuristic fallback (used if tokenizer not available):\r\n//   tokens = max(1, round((asciiLen + 0.5*nonAsciiCount) / divisor))\r\n//   divisors by provider/model family:\r\n//     - OpenAI: 4.0\r\n//     - Claude: 3.5\r\n//     - Gemini: 3.2\r\n\r\ntype MessageLike = { role?: string; content: string };\r\n\r\n// Small overhead configuration for chat-like messages\r\nconst OVERHEAD_PER_MESSAGE = 4;\r\nconst BASE_OVERHEAD = 2;\r\n\r\nfunction normalizeModelId(modelId: string): string {\r\n  return String(modelId || '').toLowerCase().trim();\r\n}\r\n\r\nfunction modelFamily(modelId: string): 'openai' | 'anthropic' | 'google' | 'unknown' {\r\n  const m = normalizeModelId(modelId);\r\n  if (m.includes('gpt-') || m.startsWith('gpt') || m.startsWith('o1') || m.startsWith('o3')) return 'openai';\r\n  if (m.includes('claude') || m.includes('anthropic')) return 'anthropic';\r\n  if (m.includes('gemini') || m.includes('google')) return 'google';\r\n  return 'unknown';\r\n}\r\n\r\n// Map model to preferred encoding id for js-tiktoken-like libs\r\nfunction preferredEncodingName(modelId: string): 'cl100k_base' | 'o200k_base' | 'cl100k_base' {\r\n  const m = normalizeModelId(modelId);\r\n  // Heuristic mapping:\r\n  // - Newer \"o\" and \"4o\" families prefer o200k_base when available.\r\n  if (m.includes('o1') || m.includes('o3') || m.includes('4o')) return 'o200k_base';\r\n  // Default OpenAI mapping\r\n  return 'cl100k_base';\r\n}\r\n\r\n// Attempts to get a length function via dynamic import of a tokenizer library.\r\n// Synchronous API; returns a function or null. We DO NOT await dynamic import.\r\n// Future calls may benefit if the dynamic import has resolved by then.\r\nlet tiktokenModule: any | null = null;\r\nlet tiktokenTried = false;\r\n\r\nfunction tryInitiateDynamicImport(): void {\r\n  if (tiktokenTried) return;\r\n  tiktokenTried = true;\r\n  try {\r\n    // Use non-literal dynamic specifiers so TypeScript doesn't try to resolve missing modules.\r\n    const m1 = 'js-tiktoken';\r\n     \r\n    (import(m1 as any) as Promise<any>)\r\n      .then((mod: any) => {\r\n        tiktokenModule = mod;\r\n      })\r\n      .catch(() => {\r\n        const m2 = '@dqbd/tiktoken';\r\n         \r\n        return (import(m2 as any) as Promise<any>)\r\n          .then((mod: any) => {\r\n            tiktokenModule = mod;\r\n          })\r\n          .catch(() => {});\r\n      });\r\n  } catch {}\r\n}\r\n\r\n// Get an encoder length function for a given model if the module has loaded.\r\nfunction getEncoderLenIfReady(modelId: string): ((text: string) => number) | null {\r\n  if (!tiktokenModule) return null;\r\n  const encName = preferredEncodingName(modelId);\r\n  try {\r\n    // js-tiktoken exposes get_encoding(name)\r\n    if (typeof tiktokenModule.get_encoding === 'function') {\r\n      const enc = tiktokenModule.get_encoding(encName);\r\n      if (enc && typeof enc.encode === 'function') {\r\n        return (text: string) => {\r\n          try {\r\n            return enc.encode(text ?? '').length || 0;\r\n          } finally {\r\n            // Some encoders have a free() API; guard it if present\r\n            if (typeof enc.free === 'function') {\r\n              try { enc.free(); } catch {}\r\n            }\r\n          }\r\n        };\r\n      }\r\n    }\r\n    // @dqbd/tiktoken may expose encodingForModel(model)\r\n    if (typeof tiktokenModule.encodingForModel === 'function') {\r\n      const enc = tiktokenModule.encodingForModel(encName);\r\n      if (enc && typeof enc.encode === 'function') {\r\n        return (text: string) => enc.encode(text ?? '').length || 0;\r\n      }\r\n    }\r\n  } catch {}\r\n  return null;\r\n}\r\n\r\nfunction countAsciiAndNonAscii(s: string): { ascii: number; nonAscii: number } {\r\n  let ascii = 0;\r\n  let nonAscii = 0;\r\n  for (let i = 0; i < s.length; i++) {\r\n    const code = s.charCodeAt(i);\r\n    if (code <= 0x7f) ascii++;\r\n    else nonAscii++;\r\n  }\r\n  return { ascii, nonAscii };\r\n}\r\n\r\nfunction heuristicDivisor(modelId: string): number {\r\n  switch (modelFamily(modelId)) {\r\n    case 'openai':\r\n      return 4.0;\r\n    case 'anthropic':\r\n      return 3.5;\r\n    case 'google':\r\n      return 3.2;\r\n    default:\r\n      return 4.0;\r\n  }\r\n}\r\n\r\nfunction heuristicTokens(modelId: string, text: string): number {\r\n  const divisor = heuristicDivisor(modelId);\r\n  const { ascii, nonAscii } = countAsciiAndNonAscii(text ?? '');\r\n  const estimate = Math.round((ascii + 0.5 * nonAscii) / divisor);\r\n  return Math.max(1, estimate);\r\n}\r\n\r\n// Public API\r\n\r\nexport function estimateTokensForModel(modelId: string, text: string): number {\r\n  // Lazy-start dynamic import without side effects outside of this function.\r\n  tryInitiateDynamicImport();\r\n  const encoderLen = getEncoderLenIfReady(modelId);\r\n  if (encoderLen) {\r\n    try {\r\n      const n = encoderLen(text ?? '');\r\n      if (Number.isFinite(n) && n > 0) return n;\r\n    } catch {}\r\n  }\r\n  // Claude and Gemini: approximate via chars/token ratio when tokenizer is absent\r\n  return heuristicTokens(modelId, text ?? '');\r\n}\r\n\r\nexport function estimateMessageTokens(modelId: string, parts: Array<MessageLike>): number {\r\n  const list = Array.isArray(parts) ? parts : [];\r\n  let total = BASE_OVERHEAD;\r\n  for (const p of list) {\r\n    const content = p?.content ?? '';\r\n    total += estimateTokensForModel(modelId, content) + OVERHEAD_PER_MESSAGE;\r\n  }\r\n  return Math.max(1, total | 0);\r\n}\r\n\r\n// Expose constants for tests (not side-effectful)\r\nexport const __TEST_ONLY__TOKENIZER_CONSTANTS = {\r\n  OVERHEAD_PER_MESSAGE,\r\n  BASE_OVERHEAD,\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\__tests__\\ResponseValidator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\__tests__\\Tokenizers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\validation\\ValidationPipeline.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\validation\\__tests__\\ValidationPipeline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\AnalysisCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\CacheStorage.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'now' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":423,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":423,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CacheStorage\r\n *\r\n * Two-tier cache:\r\n *  - L1: in-memory LRU (lru-cache if available; Map-based fallback)\r\n *  - L2: SQLite via better-sqlite3 (optional, dynamic require to avoid bundler/runtime issues)\r\n *\r\n * Notes:\r\n *  - 24h TTL enforced at read-time for both tiers.\r\n *  - L2 is best-effort. If unavailable or errors occur, storage operates in L1-only mode.\r\n *  - JSON serialization must handle ReaderKnowledge.knownCharacters (Set) safely.\r\n *  - Provides public underscore test hooks that delegate to private helpers.\r\n */\r\n\r\nimport path from 'path';\r\nimport type { CachedAnalysis, CacheStats } from './types';\r\n\r\n// Duplication of TTL to avoid coupling/circular import. Keep in sync with AnalysisCache.\r\nconst TTL_MS = 24 * 60 * 60 * 1000;\r\nconst L1_MAX = 200;\r\nconst L2_MAX_ROWS = 1000;\r\n\r\n// Dynamic require helper\r\nconst dynamicRequire: NodeRequire | null = (() => {\r\n  try {\r\n     \r\n    return eval('require');\r\n  } catch {\r\n    return null;\r\n  }\r\n})();\r\n\r\ntype L1Value = CachedAnalysis;\r\ntype L1Key = string;\r\n\r\n/**\r\n * Minimal LRU compatible interface used internally so we can swap implementations.\r\n */\r\ninterface LruLike<K, V> {\r\n  get(key: K): V | undefined;\r\n  set(key: K, val: V): void;\r\n  has(key: K): boolean;\r\n  delete(key: K): boolean;\r\n  clear(): void;\r\n  readonly size: number;\r\n  /** Optional keys iterator for maintenance/invalidation if available. */\r\n  keys?(): IterableIterator<K>;\r\n}\r\n\r\n/**\r\n * Map-based fallback LRU with simple recency management:\r\n *  - get: reinsert to end\r\n *  - set: evict first inserted if over capacity\r\n */\r\nclass SimpleMapLRU<K, V> implements LruLike<K, V> {\r\n  private map = new Map<K, V>();\r\n  private max: number;\r\n  constructor(max: number) { this.max = max; }\r\n  get(key: K): V | undefined {\r\n    if (!this.map.has(key)) return undefined;\r\n    const val = this.map.get(key)!;\r\n    this.map.delete(key);\r\n    this.map.set(key, val);\r\n    return val;\r\n  }\r\n  set(key: K, val: V): void {\r\n    if (this.map.has(key)) this.map.delete(key);\r\n    this.map.set(key, val);\r\n    if (this.map.size > this.max) {\r\n      const firstKey = this.map.keys().next().value;\r\n      if (firstKey !== undefined) this.map.delete(firstKey);\r\n    }\r\n  }\r\n  has(key: K): boolean { return this.map.has(key); }\r\n  delete(key: K): boolean { return this.map.delete(key); }\r\n  clear(): void { this.map.clear(); }\r\n  get size(): number { return this.map.size; }\r\n  keys(): IterableIterator<K> { return this.map.keys(); }\r\n}\r\n\r\n// Attempt to build an L1 cache using lru-cache if available.\r\nfunction createL1(max: number): LruLike<L1Key, L1Value> {\r\n  try {\r\n    if (dynamicRequire) {\r\n      const LRU = dynamicRequire('lru-cache');\r\n      if (LRU && LRU.default) {\r\n        // lru-cache v7+ exports default\r\n        const lru = new LRU.default({ max });\r\n        return {\r\n          get: (k: L1Key) => lru.get(k),\r\n          set: (k: L1Key, v: L1Value) => { lru.set(k, v); },\r\n          has: (k: L1Key) => lru.has(k),\r\n          delete: (k: L1Key) => lru.delete(k),\r\n          clear: () => lru.clear(),\r\n          get size() { return lru.size; },\r\n          keys: () => lru.keys(),\r\n        };\r\n      } else if (LRU) {\r\n        // older versions\r\n        const lru = new LRU({ max });\r\n        return {\r\n          get: (k: L1Key) => lru.get(k),\r\n          set: (k: L1Key, v: L1Value) => { lru.set(k, v); },\r\n          has: (k: L1Key) => lru.has(k),\r\n          delete: (k: L1Key) => lru.delete(k),\r\n          clear: () => lru.clear(),\r\n          get size() { return lru.size; },\r\n          keys: () => lru.keys(),\r\n        };\r\n      }\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  return new SimpleMapLRU<L1Key, L1Value>(max);\r\n}\r\n\r\n// SQLite (better-sqlite3) dynamic load\r\ntype BetterSqliteDatabase = any;\r\n\r\nfunction resolveDbPath(): string {\r\n  // Try Electron userData\r\n  try {\r\n    if (dynamicRequire) {\r\n      const electron = dynamicRequire('electron');\r\n      const userData =\r\n        electron?.app?.getPath?.('userData') ||\r\n        (electron as any)?.remote?.app?.getPath?.('userData');\r\n      if (typeof userData === 'string' && userData.length > 0) {\r\n        return path.join(userData, 'analysis-cache.sqlite');\r\n      }\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  // Fallback to CWD\r\n  return path.join(process.cwd(), 'analysis-cache.sqlite');\r\n}\r\n\r\n// Helpers to serialize/deserialize CachedAnalysis safely for DB storage\r\nfunction serializeCachedAnalysis(value: CachedAnalysis): string {\r\n  try {\r\n    // Clone and convert ReaderKnowledge.knownCharacters(Set) -> Array to ensure JSON-safe\r\n    const clone: any = JSON.parse(JSON.stringify(value, (_k, v) => {\r\n      // Basic stable conversion (structures already JSON-safe except Set)\r\n      return v;\r\n    }));\r\n    if (clone?.analysis?.readerContext?.knownCharacters instanceof Set) {\r\n      clone.analysis.readerContext.knownCharacters = Array.from(clone.analysis.readerContext.knownCharacters);\r\n    } else if (Array.isArray(clone?.analysis?.readerContext?.knownCharacters)) {\r\n      // already array, ok\r\n    } else if (value?.analysis?.readerContext?.knownCharacters instanceof Set) {\r\n      clone.analysis.readerContext.knownCharacters = Array.from(value.analysis.readerContext.knownCharacters);\r\n    }\r\n    return JSON.stringify(clone);\r\n  } catch {\r\n    // As a last resort, do a manual shallow conversion for knownCharacters\r\n    try {\r\n      const shallow: any = {\r\n        ...value,\r\n        analysis: {\r\n          ...value.analysis,\r\n          readerContext: {\r\n            ...value.analysis.readerContext,\r\n            knownCharacters: Array.from(value.analysis.readerContext.knownCharacters || []),\r\n          },\r\n        },\r\n      };\r\n      return JSON.stringify(shallow);\r\n    } catch {\r\n      // give up but avoid throwing\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\nfunction deserializeCachedAnalysis(json: string): CachedAnalysis | null {\r\n  try {\r\n    const parsed = JSON.parse(json);\r\n    if (parsed?.analysis?.readerContext?.knownCharacters && Array.isArray(parsed.analysis.readerContext.knownCharacters)) {\r\n      parsed.analysis.readerContext.knownCharacters = new Set<string>(parsed.analysis.readerContext.knownCharacters);\r\n    }\r\n    return parsed as CachedAnalysis;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\ninterface SqliteRow {\r\n  cache_key: string;\r\n  analysis_data: string;\r\n  semantic_hash: string;\r\n  cached_at: number;\r\n  last_accessed: number;\r\n  hit_count: number;\r\n  scene_id?: string | null;\r\n  position?: number | null;\r\n}\r\n\r\nexport default class CacheStorage {\r\n  private l1: LruLike<L1Key, L1Value>;\r\n  private l2Db: BetterSqliteDatabase | null = null;\r\n  private l2Available = false;\r\n\r\n  // In-memory metadata for L1 invalidation\r\n  private keyMeta = new Map<string, { sceneId?: string; position?: number }>();\r\n\r\n  // Storage-level approximate stats\r\n  private storageHits = 0;\r\n  private storageMisses = 0;\r\n\r\n  constructor() {\r\n    this.l1 = createL1(L1_MAX);\r\n  }\r\n\r\n  async init(): Promise<void> {\r\n    // initialize SQLite if possible\r\n    try {\r\n      let Database: any = null;\r\n      if (dynamicRequire) {\r\n        try {\r\n          Database = dynamicRequire('better-sqlite3');\r\n        } catch {\r\n          Database = null;\r\n        }\r\n      }\r\n\r\n      if (Database) {\r\n        const dbPath = resolveDbPath();\r\n        this.l2Db = new Database(dbPath);\r\n        this.l2Available = true;\r\n        // Create schema\r\n        this.l2Db\r\n          .prepare(\r\n            `CREATE TABLE IF NOT EXISTS analysis_cache (\r\n              cache_key TEXT PRIMARY KEY,\r\n              analysis_data TEXT NOT NULL,\r\n              semantic_hash TEXT NOT NULL,\r\n              cached_at INTEGER NOT NULL,\r\n              last_accessed INTEGER NOT NULL,\r\n              hit_count INTEGER DEFAULT 0,\r\n              scene_id TEXT,\r\n              position INTEGER\r\n            )`,\r\n          )\r\n          .run();\r\n\r\n        this.l2Db.prepare(`CREATE INDEX IF NOT EXISTS idx_scene_id ON analysis_cache(scene_id)`).run();\r\n        this.l2Db.prepare(`CREATE INDEX IF NOT EXISTS idx_position ON analysis_cache(position)`).run();\r\n        this.l2Db.prepare(`CREATE INDEX IF NOT EXISTS idx_last_accessed ON analysis_cache(last_accessed)`).run();\r\n      }\r\n    } catch (err) {\r\n      // Disable L2 for session\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] SQLite unavailable, continuing with memory-only.', err);\r\n    }\r\n  }\r\n\r\n  // Public API\r\n\r\n  async get(cacheKey: string): Promise<CachedAnalysis | null> {\r\n    try {\r\n      // L1\r\n      const fromMem = this.getFromMemory(cacheKey);\r\n      if (fromMem) {\r\n        this.storageHits++;\r\n        this.bumpAccess(cacheKey, /*l1*/ true, /*l2*/ true);\r\n        return fromMem;\r\n      }\r\n      this.storageMisses++;\r\n\r\n      // L2\r\n      const row = await this.getRowFromSQLite(cacheKey);\r\n      if (row) {\r\n        const now = Date.now();\r\n        if (now - row.cached_at > TTL_MS) {\r\n          // expired\r\n          await this.deleteFromSQLite(cacheKey);\r\n          return null;\r\n        }\r\n        const parsed = deserializeCachedAnalysis(row.analysis_data);\r\n        if (!parsed) {\r\n          // corruption\r\n          await this.deleteFromSQLite(cacheKey);\r\n          return null;\r\n        }\r\n        // hydrate L1 and metadata\r\n        this.setToMemory(cacheKey, parsed);\r\n        this.keyMeta.set(cacheKey, { sceneId: row.scene_id ?? undefined, position: row.position ?? undefined });\r\n        this.storageHits++;\r\n        this.bumpAccess(cacheKey, /*l1*/ true, /*l2*/ true);\r\n        return parsed;\r\n      }\r\n      return null;\r\n    } catch {\r\n      // Never break caller flow\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // meta is optional; if provided, allows L2 to store scene_id/position for targeted invalidation.\r\n  async set(cacheKey: string, analysis: CachedAnalysis, meta?: { sceneId?: string; position?: number }): Promise<void> {\r\n    try {\r\n      // L1\r\n      this.setToMemory(cacheKey, analysis);\r\n      if (meta) this.keyMeta.set(cacheKey, { sceneId: meta.sceneId, position: meta.position });\r\n\r\n      // L2\r\n      await this._setToSQLite(cacheKey, analysis, meta);\r\n      await this.cleanupExpired();\r\n      await this.enforceL2Capacity();\r\n    } catch (err) {\r\n      // Disable L2 on persistent failure, do not throw\r\n       \r\n      console.warn('[CacheStorage] set failed, proceeding with memory-only.', err);\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n    }\r\n  }\r\n\r\n  async getStats(): Promise<CacheStats> {\r\n    let l2Count = 0;\r\n    if (this.l2Available && this.l2Db) {\r\n      try {\r\n        const row = this.l2Db.prepare('SELECT COUNT(*) as cnt FROM analysis_cache').get();\r\n        l2Count = typeof row?.cnt === 'number' ? row.cnt : 0;\r\n      } catch {\r\n        // ignore\r\n      }\r\n    }\r\n\r\n    const totalGets = this.storageHits + this.storageMisses;\r\n    const hitRate = totalGets > 0 ? (this.storageHits / totalGets) * 100 : 0;\r\n\r\n    return {\r\n      hitRate,\r\n      size: (this.l1?.size ?? 0) + l2Count,\r\n      totalHits: this.storageHits,\r\n      totalMisses: this.storageMisses,\r\n      avgHitTime: 0,\r\n      avgGenerationTime: 0,\r\n    };\r\n    }\r\n\r\n  async clear(): Promise<void> {\r\n    try {\r\n      this.l1.clear();\r\n      this.keyMeta.clear();\r\n      if (this.l2Available && this.l2Db) {\r\n        this.l2Db.prepare('DELETE FROM analysis_cache').run();\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  // Private L1 helpers\r\n\r\n  private getFromMemory(cacheKey: string): CachedAnalysis | null {\r\n    try {\r\n      if (!this.l1?.has(cacheKey)) return null;\r\n      const val = this.l1.get(cacheKey);\r\n      if (!val) return null;\r\n      const now = Date.now();\r\n      // Enforce TTL against creation time\r\n      if (now - val.cachedAt > TTL_MS) {\r\n        this.l1.delete(cacheKey);\r\n        this.keyMeta.delete(cacheKey);\r\n        return null;\r\n      }\r\n      return val;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private setToMemory(cacheKey: string, analysis: CachedAnalysis): void {\r\n    try {\r\n      this.l1.set(cacheKey, analysis);\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  // Private L2 helpers\r\n\r\n  private async getRowFromSQLite(cacheKey: string): Promise<SqliteRow | null> {\r\n    if (!this.l2Available || !this.l2Db) return null;\r\n    try {\r\n      const row = this.l2Db\r\n        .prepare(\r\n          `SELECT cache_key, analysis_data, semantic_hash, cached_at, last_accessed, hit_count, scene_id, position\r\n           FROM analysis_cache WHERE cache_key = ?`,\r\n        )\r\n        .get(cacheKey) as SqliteRow | undefined;\r\n      return row || null;\r\n    } catch (err) {\r\n      // Disable L2 on error\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] getRowFromSQLite failed, disabling L2.', err);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Test hook: publicly exposed wrapper\r\n  public async _getFromSQLite(cacheKey: string): Promise<CachedAnalysis | null> {\r\n    const row = await this.getRowFromSQLite(cacheKey);\r\n    if (!row) return null;\r\n    const parsed = deserializeCachedAnalysis(row.analysis_data);\r\n    if (!parsed) return null;\r\n    return parsed;\r\n  }\r\n\r\n  private async setToSQLite(cacheKey: string, analysis: CachedAnalysis, meta?: { sceneId?: string; position?: number }): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      const payload = serializeCachedAnalysis(analysis);\r\n      if (!payload) return; // skip if serialization failed\r\n      const now = Date.now();\r\n      const sceneId = meta?.sceneId ?? null;\r\n      const position = typeof meta?.position === 'number' ? meta!.position : null;\r\n\r\n      this.l2Db\r\n        .prepare(\r\n          `INSERT INTO analysis_cache (cache_key, analysis_data, semantic_hash, cached_at, last_accessed, hit_count, scene_id, position)\r\n           VALUES (@cache_key, @analysis_data, @semantic_hash, @cached_at, @last_accessed, @hit_count, @scene_id, @position)\r\n           ON CONFLICT(cache_key) DO UPDATE SET\r\n             analysis_data = excluded.analysis_data,\r\n             semantic_hash = excluded.semantic_hash,\r\n             cached_at = excluded.cached_at,\r\n             last_accessed = excluded.last_accessed,\r\n             scene_id = COALESCE(excluded.scene_id, analysis_cache.scene_id),\r\n             position = COALESCE(excluded.position, analysis_cache.position)`,\r\n        )\r\n        .run({\r\n          cache_key: cacheKey,\r\n          analysis_data: payload,\r\n          semantic_hash: analysis.semanticHash,\r\n          cached_at: analysis.cachedAt,\r\n          last_accessed: analysis.lastAccessed,\r\n          hit_count: analysis.hitCount,\r\n          scene_id: sceneId,\r\n          position: position,\r\n        });\r\n    } catch (err) {\r\n      // Disable L2 on persistent failure\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] setToSQLite failed, disabling L2.', err);\r\n    }\r\n  }\r\n\r\n  // Test hook: publicly exposed wrapper\r\n  public async _setToSQLite(cacheKey: string, analysis: CachedAnalysis, meta?: { sceneId?: string; position?: number }): Promise<void> {\r\n    await this.setToSQLite(cacheKey, analysis, meta);\r\n  }\r\n\r\n  private async deleteFromSQLite(cacheKey: string): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      this.l2Db.prepare('DELETE FROM analysis_cache WHERE cache_key = ?').run(cacheKey);\r\n    } catch (err) {\r\n      // Disable L2 on error\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] deleteFromSQLite failed, disabling L2.', err);\r\n    }\r\n  }\r\n\r\n  private async enforceL2Capacity(): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      const countRow = this.l2Db.prepare('SELECT COUNT(*) as cnt FROM analysis_cache').get();\r\n      const cnt = typeof countRow?.cnt === 'number' ? countRow.cnt : 0;\r\n      const excess = cnt - L2_MAX_ROWS;\r\n      if (excess > 0) {\r\n        this.l2Db\r\n          .prepare(\r\n            `DELETE FROM analysis_cache\r\n             WHERE cache_key IN (\r\n               SELECT cache_key FROM analysis_cache\r\n               ORDER BY last_accessed ASC\r\n               LIMIT ?\r\n             )`,\r\n          )\r\n          .run(excess);\r\n      }\r\n    } catch (err) {\r\n      // ignore; not critical\r\n       \r\n      console.warn('[CacheStorage] enforceL2Capacity warning:', err);\r\n    }\r\n  }\r\n\r\n  private async cleanupExpired(): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      const cutoff = Date.now() - TTL_MS;\r\n      this.l2Db.prepare('DELETE FROM analysis_cache WHERE cached_at < ?').run(cutoff);\r\n    } catch (err) {\r\n      // ignore\r\n       \r\n      console.warn('[CacheStorage] cleanupExpired warning:', err);\r\n    }\r\n  }\r\n\r\n  private bumpAccess(cacheKey: string, bumpL1: boolean, bumpL2: boolean): void {\r\n    const now = Date.now();\r\n    if (bumpL1) {\r\n      const val = this.l1.get(cacheKey);\r\n      if (val) {\r\n        const bumped: CachedAnalysis = {\r\n          ...val,\r\n          lastAccessed: now,\r\n          hitCount: (val.hitCount || 0) + 1,\r\n        };\r\n        this.l1.set(cacheKey, bumped);\r\n      }\r\n    }\r\n    if (bumpL2 && this.l2Available && this.l2Db) {\r\n      try {\r\n        this.l2Db\r\n          .prepare('UPDATE analysis_cache SET last_accessed = ?, hit_count = hit_count + 1 WHERE cache_key = ?')\r\n          .run(now, cacheKey);\r\n      } catch {\r\n        // ignore\r\n      }\r\n    }\r\n  }\r\n\r\n  // Private invalidation helpers (invoked by AnalysisCache using symbolic helper call with \"as any\")\r\n\r\n  private deleteBySceneId(sceneId: string): number {\r\n    let removed = 0;\r\n    // L1 by metadata map\r\n    try {\r\n      for (const [key, meta] of this.keyMeta.entries()) {\r\n        if (meta.sceneId === sceneId) {\r\n          if (this.l1.delete(key)) removed++;\r\n          this.keyMeta.delete(key);\r\n        }\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    // L2\r\n    try {\r\n      if (this.l2Available && this.l2Db) {\r\n        const info = this.l2Db.prepare('DELETE FROM analysis_cache WHERE scene_id = ?').run(sceneId);\r\n        removed += info?.changes ?? 0;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return removed;\r\n  }\r\n\r\n  private deleteByPosition(position: number): number {\r\n    let removed = 0;\r\n    // L1 by metadata map\r\n    try {\r\n      for (const [key, meta] of this.keyMeta.entries()) {\r\n        if (typeof meta.position === 'number' && meta.position === position) {\r\n          if (this.l1.delete(key)) removed++;\r\n          this.keyMeta.delete(key);\r\n        }\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    // L2\r\n    try {\r\n      if (this.l2Available && this.l2Db) {\r\n        const info = this.l2Db.prepare('DELETE FROM analysis_cache WHERE position = ?').run(position);\r\n        removed += info?.changes ?? 0;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return removed;\r\n  }\r\n\r\n  // Public underscore test hooks for memory\r\n  public _getFromMemory(cacheKey: string): CachedAnalysis | null {\r\n    return this.getFromMemory(cacheKey);\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\SemanticHasher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\export\\ManuscriptExporter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'orderedScenes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":145,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Manuscript, Scene, RewriteVersion } from '../../shared/types';\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport interface ExportOptions {\r\n  format: 'original' | 'rewritten' | 'both' | 'changelog';\r\n  includeMetadata: boolean;\r\n  includeChangeLog: boolean;\r\n  changeLogDetail: 'summary' | 'detailed';\r\n  outputPath?: string;\r\n  filename?: string;\r\n}\r\n\r\nexport interface ExportResult {\r\n  success: boolean;\r\n  filePath?: string;\r\n  error?: string;\r\n  stats?: {\r\n    totalScenes: number;\r\n    rewrittenScenes: number;\r\n    totalWords: number;\r\n    totalChanges: number;\r\n  };\r\n}\r\n\r\nexport interface ChangeLogEntry {\r\n  sceneNumber: number;\r\n  sceneTitle: string;\r\n  changes: {\r\n    issueType: string;\r\n    description: string;\r\n    fix: string;\r\n  }[];\r\n  wordCountBefore: number;\r\n  wordCountAfter: number;\r\n  modelUsed?: string;\r\n  timestamp?: number;\r\n}\r\n\r\nclass ManuscriptExporter {\r\n  /**\r\n   * Export manuscript with various format options\r\n   */\r\n  async exportManuscript(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): Promise<ExportResult> {\r\n    try {\r\n      const stats = this.calculateStats(manuscript, rewrites);\r\n      \r\n      let content: string;\r\n      switch (options.format) {\r\n        case 'original':\r\n          content = this.exportOriginal(manuscript);\r\n          break;\r\n        case 'rewritten':\r\n          content = this.exportRewritten(manuscript, rewrites);\r\n          break;\r\n        case 'both':\r\n          content = this.exportBothVersions(manuscript, rewrites, options);\r\n          break;\r\n        case 'changelog':\r\n          content = this.exportChangeLog(manuscript, rewrites, options);\r\n          break;\r\n        default:\r\n          content = this.exportRewritten(manuscript, rewrites);\r\n      }\r\n      \r\n      // Add metadata header if requested\r\n      if (options.includeMetadata) {\r\n        content = this.addMetadataHeader(manuscript, stats, options) + content;\r\n      }\r\n      \r\n      // Add change log section if requested\r\n      if (options.includeChangeLog && options.format !== 'changelog') {\r\n        content += this.generateChangeLogSection(manuscript, rewrites, options);\r\n      }\r\n      \r\n      // Determine output path\r\n      const outputPath = options.outputPath || process.cwd();\r\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\r\n      const defaultFilename = `${manuscript.title || 'manuscript'}_${options.format}_${timestamp}.txt`;\r\n      const filename = options.filename || defaultFilename;\r\n      const filePath = path.join(outputPath, filename);\r\n      \r\n      // Write file\r\n      await fs.writeFile(filePath, content, 'utf-8');\r\n      \r\n      return {\r\n        success: true,\r\n        filePath,\r\n        stats\r\n      };\r\n      \r\n    } catch (error) {\r\n       \r\n      console.error('[ManuscriptExporter] Export error:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Export failed'\r\n      };\r\n    }\r\n  }\r\n  \r\n  private exportOriginal(manuscript: Manuscript): string {\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    return orderedScenes\r\n      .map(scene => scene.text)\r\n      .join('\\n\\n### SCENE BREAK ###\\n\\n');\r\n  }\r\n  \r\n  private exportRewritten(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>\r\n  ): string {\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    \r\n    return orderedScenes\r\n      .map(scene => {\r\n        // Use applied rewrite if available, otherwise original\r\n        if (scene.rewriteStatus === 'approved') {\r\n          // Scene text was already updated with rewrite\r\n          return scene.text;\r\n        }\r\n        \r\n        // Check for unapplied rewrites\r\n        const sceneRewrites = rewrites.get(scene.id);\r\n        const latestRewrite = sceneRewrites?.[sceneRewrites.length - 1];\r\n        \r\n        if (latestRewrite && latestRewrite.rewrittenText) {\r\n          return latestRewrite.rewrittenText;\r\n        }\r\n        \r\n        return scene.text;\r\n      })\r\n      .join('\\n\\n### SCENE BREAK ###\\n\\n');\r\n  }\r\n  \r\n  private exportBothVersions(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): string {\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    const sections: string[] = [];\r\n    \r\n    // Add table of contents\r\n    sections.push('TABLE OF CONTENTS\\n' + '='.repeat(50) + '\\n');\r\n    sections.push('Original Version ............... Page 1');\r\n    sections.push('Rewritten Version .............. Page 2');\r\n    if (options.includeChangeLog) {\r\n      sections.push('Change Log ..................... Page 3');\r\n    }\r\n    sections.push('\\n\\n');\r\n    \r\n    // Original version\r\n    sections.push('ORIGINAL VERSION\\n' + '='.repeat(50) + '\\n\\n');\r\n    sections.push(this.exportOriginal(manuscript));\r\n    sections.push('\\n\\n' + '='.repeat(50) + '\\n\\n');\r\n    \r\n    // Rewritten version\r\n    sections.push('REWRITTEN VERSION\\n' + '='.repeat(50) + '\\n\\n');\r\n    sections.push(this.exportRewritten(manuscript, rewrites));\r\n    \r\n    return sections.join('');\r\n  }\r\n  \r\n  private exportChangeLog(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): string {\r\n    const entries = this.buildChangeLogEntries(manuscript, rewrites);\r\n    \r\n    const sections: string[] = [\r\n      'MANUSCRIPT CHANGE LOG',\r\n      '='.repeat(50),\r\n      `Generated: ${new Date().toLocaleString()}`,\r\n      `Total Scenes: ${manuscript.scenes.length}`,\r\n      `Scenes Rewritten: ${entries.length}`,\r\n      '',\r\n      '='.repeat(50),\r\n      ''\r\n    ];\r\n    \r\n    if (entries.length === 0) {\r\n      sections.push('No scenes have been rewritten.');\r\n      return sections.join('\\n');\r\n    }\r\n    \r\n    // Add entries\r\n    entries.forEach((entry, index) => {\r\n      sections.push(`\\nSCENE ${entry.sceneNumber}`);\r\n      sections.push('-'.repeat(30));\r\n      \r\n      if (entry.sceneTitle) {\r\n        sections.push(`Title: ${entry.sceneTitle}`);\r\n      }\r\n      \r\n      sections.push(`Word Count: ${entry.wordCountBefore} → ${entry.wordCountAfter} (${\r\n        entry.wordCountAfter - entry.wordCountBefore > 0 ? '+' : ''\r\n      }${entry.wordCountAfter - entry.wordCountBefore})`);\r\n      \r\n      if (entry.modelUsed) {\r\n        sections.push(`AI Model: ${entry.modelUsed}`);\r\n      }\r\n      \r\n      sections.push('\\nChanges Made:');\r\n      entry.changes.forEach(change => {\r\n        sections.push(`  • ${change.issueType.toUpperCase()}: ${change.description}`);\r\n        if (options.changeLogDetail === 'detailed' && change.fix) {\r\n          sections.push(`    → ${change.fix}`);\r\n        }\r\n      });\r\n      \r\n      if (index < entries.length - 1) {\r\n        sections.push('');\r\n      }\r\n    });\r\n    \r\n    return sections.join('\\n');\r\n  }\r\n  \r\n  private generateChangeLogSection(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): string {\r\n    const changeLog = this.exportChangeLog(manuscript, rewrites, options);\r\n    return '\\n\\n' + '='.repeat(50) + '\\n\\n' + changeLog;\r\n  }\r\n  \r\n  private addMetadataHeader(\r\n    manuscript: Manuscript,\r\n    stats: ExportResult['stats'],\r\n    options: ExportOptions\r\n  ): string {\r\n    const header: string[] = [\r\n      '='.repeat(50),\r\n      'MANUSCRIPT EXPORT',\r\n      '='.repeat(50),\r\n      `Title: ${manuscript.title || 'Untitled'}`,\r\n      `Export Date: ${new Date().toLocaleString()}`,\r\n      `Export Format: ${options.format}`,\r\n      `Total Scenes: ${stats?.totalScenes || 0}`,\r\n      `Rewritten Scenes: ${stats?.rewrittenScenes || 0}`,\r\n      `Total Words: ${stats?.totalWords || 0}`,\r\n      '='.repeat(50),\r\n      '\\n\\n'\r\n    ];\r\n    \r\n    return header.join('\\n');\r\n  }\r\n  \r\n  private buildChangeLogEntries(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>\r\n  ): ChangeLogEntry[] {\r\n    const entries: ChangeLogEntry[] = [];\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    \r\n    orderedScenes.forEach((scene, index) => {\r\n      const sceneRewrites = rewrites.get(scene.id);\r\n      const latestRewrite = sceneRewrites?.[sceneRewrites.length - 1];\r\n      \r\n      if (latestRewrite && (scene.rewriteStatus === 'approved' || latestRewrite.rewrittenText)) {\r\n        const entry: ChangeLogEntry = {\r\n          sceneNumber: index + 1,\r\n          sceneTitle: this.extractSceneTitle(scene.text),\r\n          changes: latestRewrite.issuesAddressed.map(issue => ({\r\n            issueType: issue.type,\r\n            description: issue.description,\r\n            fix: issue.suggestedFix || 'Applied contextual fix'\r\n          })),\r\n          wordCountBefore: scene.wordCount,\r\n          wordCountAfter: this.countWords(\r\n            scene.rewriteStatus === 'approved' ? scene.text : latestRewrite.rewrittenText\r\n          ),\r\n          modelUsed: latestRewrite.modelUsed,\r\n          timestamp: latestRewrite.timestamp\r\n        };\r\n        \r\n        entries.push(entry);\r\n      }\r\n    });\r\n    \r\n    return entries;\r\n  }\r\n  \r\n  private getOrderedScenes(manuscript: Manuscript): Scene[] {\r\n    return manuscript.currentOrder\r\n      .map(id => manuscript.scenes.find(s => s.id === id))\r\n      .filter(Boolean) as Scene[];\r\n  }\r\n  \r\n  private calculateStats(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>\r\n  ): ExportResult['stats'] {\r\n    const rewrittenScenes = manuscript.scenes.filter(scene => \r\n      scene.rewriteStatus === 'approved' || rewrites.has(scene.id)\r\n    );\r\n    \r\n    const totalWords = manuscript.scenes.reduce((sum, scene) => {\r\n      if (scene.rewriteStatus === 'approved') {\r\n        return sum + scene.wordCount;\r\n      }\r\n      const rewrite = rewrites.get(scene.id)?.[0];\r\n      if (rewrite?.rewrittenText) {\r\n        return sum + this.countWords(rewrite.rewrittenText);\r\n      }\r\n      return sum + scene.wordCount;\r\n    }, 0);\r\n    \r\n    const totalChanges = Array.from(rewrites.values())\r\n      .reduce((sum, versions) => {\r\n        const latest = versions[versions.length - 1];\r\n        return sum + (latest?.issuesAddressed.length || 0);\r\n      }, 0);\r\n    \r\n    return {\r\n      totalScenes: manuscript.scenes.length,\r\n      rewrittenScenes: rewrittenScenes.length,\r\n      totalWords,\r\n      totalChanges\r\n    };\r\n  }\r\n  \r\n  private extractSceneTitle(text: string): string {\r\n    const firstLine = text.split('\\n')[0];\r\n    if (firstLine && firstLine.length < 100) {\r\n      return firstLine.trim();\r\n    }\r\n    return text.substring(0, 50).trim() + '...';\r\n  }\r\n  \r\n  private countWords(text: string): number {\r\n    return text.split(/\\s+/).filter(word => word.length > 0).length;\r\n  }\r\n}\r\n\r\nexport default ManuscriptExporter;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\export\\__tests__\\ManuscriptExporter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\DiffEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\PerformanceOptimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'BatchRewriteProgress' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { BatchRewriteProgress } from './RewriteOrchestrator';\r\n\r\nexport interface PerformanceMetrics {\r\n  avgRewriteTime: number;\r\n  cacheHitRate: number;\r\n  memoryUsage: number;\r\n  errorRate: number;\r\n  lastUpdated: number;\r\n}\r\n\r\nclass PerformanceOptimizer {\r\n  private metrics: PerformanceMetrics = {\r\n    avgRewriteTime: 0,\r\n    cacheHitRate: 0,\r\n    memoryUsage: 0,\r\n    errorRate: 0,\r\n    lastUpdated: Date.now()\r\n  };\r\n  \r\n  private rewriteTimes: number[] = [];\r\n  private cacheHits = 0;\r\n  private cacheMisses = 0;\r\n  private errors = 0;\r\n  private total = 0;\r\n  \r\n  /**\r\n   * Track rewrite performance\r\n   */\r\n  trackRewrite(startTime: number, success: boolean, cached: boolean = false): void {\r\n    const duration = Date.now() - startTime;\r\n    this.total++;\r\n    \r\n    if (success) {\r\n      this.rewriteTimes.push(duration);\r\n      // Keep only last 100 times for moving average\r\n      if (this.rewriteTimes.length > 100) {\r\n        this.rewriteTimes.shift();\r\n      }\r\n    } else {\r\n      this.errors++;\r\n    }\r\n    \r\n    if (cached) {\r\n      this.cacheHits++;\r\n    } else {\r\n      this.cacheMisses++;\r\n    }\r\n    \r\n    this.updateMetrics();\r\n  }\r\n  \r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getMetrics(): PerformanceMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n  \r\n  /**\r\n   * Suggest optimizations based on current metrics\r\n   */\r\n  getSuggestions(): string[] {\r\n    const suggestions: string[] = [];\r\n    \r\n    if (this.metrics.avgRewriteTime > 30000) {\r\n      suggestions.push('Consider using simpler models for basic issues');\r\n    }\r\n    \r\n    if (this.metrics.cacheHitRate < 0.3 && this.total > 10) {\r\n      suggestions.push('Low cache hit rate - ensure cache is properly configured');\r\n    }\r\n    \r\n    if (this.metrics.errorRate > 0.1) {\r\n      suggestions.push('High error rate detected - check API keys and network');\r\n    }\r\n    \r\n    if (this.metrics.memoryUsage > 500) {\r\n      suggestions.push('High memory usage - consider clearing old rewrites');\r\n    }\r\n    \r\n    return suggestions;\r\n  }\r\n  \r\n  /**\r\n   * Optimize batch size based on performance\r\n   */\r\n  getOptimalBatchSize(): number {\r\n    if (this.metrics.avgRewriteTime < 5000) {\r\n      return 10; // Fast processing, larger batches OK\r\n    } else if (this.metrics.avgRewriteTime < 15000) {\r\n      return 5; // Medium speed\r\n    } else {\r\n      return 3; // Slow processing, smaller batches\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Clean up old data to free memory\r\n   */\r\n  cleanup(): void {\r\n    // Clear old metrics\r\n    if (this.rewriteTimes.length > 100) {\r\n      this.rewriteTimes = this.rewriteTimes.slice(-100);\r\n    }\r\n    \r\n    // Reset counters periodically\r\n    if (this.total > 1000) {\r\n      const hitRate = this.metrics.cacheHitRate;\r\n      const errorRate = this.metrics.errorRate;\r\n      \r\n      // Reset but maintain ratios\r\n      this.cacheHits = Math.round(hitRate * 100);\r\n      this.cacheMisses = Math.round((1 - hitRate) * 100);\r\n      this.errors = Math.round(errorRate * 100);\r\n      this.total = 100;\r\n    }\r\n  }\r\n  \r\n  private updateMetrics(): void {\r\n    // Calculate average rewrite time\r\n    if (this.rewriteTimes.length > 0) {\r\n      const sum = this.rewriteTimes.reduce((a, b) => a + b, 0);\r\n      this.metrics.avgRewriteTime = Math.round(sum / this.rewriteTimes.length);\r\n    }\r\n    \r\n    // Calculate cache hit rate\r\n    const cacheTotal = this.cacheHits + this.cacheMisses;\r\n    if (cacheTotal > 0) {\r\n      this.metrics.cacheHitRate = this.cacheHits / cacheTotal;\r\n    }\r\n    \r\n    // Calculate error rate\r\n    if (this.total > 0) {\r\n      this.metrics.errorRate = this.errors / this.total;\r\n    }\r\n    \r\n    // Estimate memory usage (simplified)\r\n    if (typeof process !== 'undefined' && (process as any).memoryUsage) {\r\n      const usage = (process as any).memoryUsage();\r\n      this.metrics.memoryUsage = Math.round(usage.heapUsed / 1024 / 1024); // MB\r\n    }\r\n    \r\n    this.metrics.lastUpdated = Date.now();\r\n  }\r\n}\r\n\r\nexport default PerformanceOptimizer;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\RewriteOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ContinuityIssue' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import SceneRewriter from './SceneRewriter';\r\nimport type { Scene, ContinuityIssue, ReaderKnowledge } from '../../shared/types';\r\nimport type { RewriteResult } from './SceneRewriter';\r\nimport AIServiceManager from '../ai/AIServiceManager';\r\n\r\nexport interface BatchRewriteProgress {\r\n  totalScenes: number;\r\n  completedScenes: number;\r\n  currentSceneId?: string;\r\n  currentSceneTitle?: string;\r\n  phase: 'preparing' | 'analyzing' | 'rewriting' | 'complete' | 'error';\r\n  message: string;\r\n  results: Map<string, RewriteResult>;\r\n  errors: Map<string, string>;\r\n}\r\n\r\nexport interface BatchRewriteOptions {\r\n  sceneIds?: string[];  // Specific scenes, or all moved if not provided\r\n  skipIfNoIssues?: boolean;\r\n  preserveElements?: Map<string, string[]>; // Per-scene preservation\r\n  progressCallback?: (progress: BatchRewriteProgress) => void;\r\n}\r\n\r\nclass RewriteOrchestrator {\r\n  private sceneRewriter: SceneRewriter;\r\n  private aiManager: AIServiceManager;\r\n  private currentBatch?: AbortController;\r\n\r\n  constructor(aiManager?: AIServiceManager) {\r\n    this.aiManager = aiManager || new AIServiceManager();\r\n    this.sceneRewriter = new SceneRewriter(this.aiManager);\r\n  }\r\n\r\n  /**\r\n   * Rewrite multiple moved scenes in dependency order\r\n   */\r\n  async rewriteMovedScenes(\r\n    manuscript: { scenes: Scene[]; currentOrder: string[] },\r\n    options: BatchRewriteOptions = {}\r\n  ): Promise<BatchRewriteProgress> {\r\n    // Cancel any existing batch\r\n    this.cancelBatch();\r\n    this.currentBatch = new AbortController();\r\n\r\n    const progress: BatchRewriteProgress = {\r\n      totalScenes: 0,\r\n      completedScenes: 0,\r\n      phase: 'preparing',\r\n      message: 'Preparing batch rewrite...',\r\n      results: new Map(),\r\n      errors: new Map()\r\n    };\r\n\r\n    try {\r\n      // Step 1: Identify scenes to rewrite\r\n      const scenesToRewrite = this.identifyScenesToRewrite(manuscript, options);\r\n      progress.totalScenes = scenesToRewrite.length;\r\n\r\n      if (scenesToRewrite.length === 0) {\r\n        progress.phase = 'complete';\r\n        progress.message = 'No scenes need rewriting';\r\n        return progress;\r\n      }\r\n\r\n      // Step 2: Order scenes by dependency (narrative) order\r\n      const orderedScenes = this.orderByDependency(scenesToRewrite, manuscript.currentOrder);\r\n\r\n      progress.phase = 'analyzing';\r\n      progress.message = `Analyzing ${scenesToRewrite.length} scenes...`;\r\n      options.progressCallback?.(progress);\r\n\r\n      // Step 3: Process each scene\r\n      for (const sceneId of orderedScenes) {\r\n        if (this.currentBatch?.signal.aborted) {\r\n          progress.phase = 'error';\r\n          progress.message = 'Batch rewrite cancelled';\r\n          break;\r\n        }\r\n\r\n        const scene = manuscript.scenes.find(s => s.id === sceneId);\r\n        if (!scene) {\r\n          progress.errors.set(sceneId, 'Scene not found');\r\n          progress.completedScenes++;\r\n          options.progressCallback?.(progress);\r\n          continue;\r\n        }\r\n\r\n        progress.currentSceneId = sceneId;\r\n        progress.currentSceneTitle = this.getSceneTitle(scene);\r\n        progress.phase = 'rewriting';\r\n        progress.message = `Rewriting scene ${progress.completedScenes + 1} of ${progress.totalScenes}`;\r\n        options.progressCallback?.(progress);\r\n\r\n        try {\r\n          // Get issues from analysis\r\n          const issues = scene.continuityAnalysis?.issues || [];\r\n          if (options.skipIfNoIssues && issues.length === 0) {\r\n            progress.completedScenes++;\r\n            continue;\r\n          }\r\n\r\n          // Build reader context from previous scenes\r\n          const readerContext = this.buildReaderContext(\r\n            manuscript,\r\n            sceneId,\r\n            progress.results\r\n          );\r\n\r\n          // Get previous scenes (including any already rewritten)\r\n          const previousScenes = this.getPreviousScenes(\r\n            manuscript,\r\n            sceneId,\r\n            progress.results\r\n          );\r\n\r\n          // Rewrite the scene\r\n          const result = await this.sceneRewriter.rewriteScene({\r\n            scene,\r\n            issuesFound: issues,\r\n            readerContext,\r\n            previousScenes,\r\n            preserveElements: options.preserveElements?.get(sceneId) || []\r\n          });\r\n\r\n          if (result.success) {\r\n            progress.results.set(sceneId, result);\r\n          } else {\r\n            progress.errors.set(sceneId, result.error || 'Unknown error');\r\n          }\r\n        } catch (error) {\r\n           \r\n          console.error(`[RewriteOrchestrator] Failed to rewrite scene ${sceneId}:`, error);\r\n          progress.errors.set(sceneId, error instanceof Error ? error.message : 'Unknown error');\r\n        }\r\n\r\n        progress.completedScenes++;\r\n        options.progressCallback?.(progress);\r\n\r\n        // Add small delay between scenes to prevent rate limiting\r\n        if (progress.completedScenes < progress.totalScenes) {\r\n          await this.delay(500);\r\n        }\r\n      }\r\n\r\n      progress.phase = progress.errors.size > 0 ? 'error' : 'complete';\r\n      progress.message = this.generateCompletionMessage(progress);\r\n\r\n    } catch (error) {\r\n       \r\n      console.error('[RewriteOrchestrator] Batch rewrite error:', error);\r\n      progress.phase = 'error';\r\n      progress.message = 'Batch rewrite failed';\r\n    }\r\n\r\n    this.currentBatch = undefined;\r\n    return progress;\r\n  }\r\n\r\n  /**\r\n   * Cancel the current batch operation\r\n   */\r\n  cancelBatch(): void {\r\n    if (this.currentBatch) {\r\n      this.currentBatch.abort();\r\n    }\r\n  }\r\n\r\n  private identifyScenesToRewrite(\r\n    manuscript: { scenes: Scene[] },\r\n    options: BatchRewriteOptions\r\n  ): string[] {\r\n    if (options.sceneIds) {\r\n      return options.sceneIds;\r\n    }\r\n\r\n    // Default: all moved scenes with issues\r\n    return manuscript.scenes\r\n      .filter(scene =>\r\n        scene.hasBeenMoved &&\r\n        !!scene.continuityAnalysis?.issues &&\r\n        scene.continuityAnalysis.issues.length > 0\r\n      )\r\n      .map(scene => scene.id);\r\n  }\r\n\r\n  private orderByDependency(\r\n    sceneIds: string[],\r\n    currentOrder: string[]\r\n  ): string[] {\r\n    // Process scenes in their current narrative order\r\n    // This ensures reader context builds correctly\r\n    return sceneIds.sort((a, b) => {\r\n      const aIndex = currentOrder.indexOf(a);\r\n      const bIndex = currentOrder.indexOf(b);\r\n      return aIndex - bIndex;\r\n    });\r\n  }\r\n\r\n  private buildReaderContext(\r\n    manuscript: { scenes: Scene[]; currentOrder: string[] },\r\n    sceneId: string,\r\n    rewrittenScenes: Map<string, RewriteResult>\r\n  ): ReaderKnowledge {\r\n    const context: ReaderKnowledge = {\r\n      knownCharacters: new Set<string>(),\r\n      establishedTimeline: [],\r\n      revealedPlotPoints: [],\r\n      establishedSettings: []\r\n    };\r\n\r\n    const sceneIndex = manuscript.currentOrder.indexOf(sceneId);\r\n    if (sceneIndex <= 0) return context;\r\n\r\n    // Include all scenes before this one\r\n    for (let i = 0; i < sceneIndex; i++) {\r\n      const prevSceneId = manuscript.currentOrder[i];\r\n      const prevScene = manuscript.scenes.find(s => s.id === prevSceneId);\r\n      if (!prevScene) continue;\r\n\r\n      // Use rewritten version if available\r\n      const rewritten = rewrittenScenes.get(prevSceneId);\r\n      if (rewritten && rewritten.rewrittenText) {\r\n        // For now, use original metadata; could extract from rewritten text later\r\n        prevScene.characters?.forEach(char => context.knownCharacters.add(char));\r\n      } else {\r\n        prevScene.characters?.forEach(char => context.knownCharacters.add(char));\r\n        prevScene.timeMarkers?.forEach(marker => {\r\n          context.establishedTimeline.push({ label: marker });\r\n        });\r\n        prevScene.locationMarkers?.forEach(loc => {\r\n          context.establishedSettings.push({ name: loc });\r\n        });\r\n      }\r\n    }\r\n\r\n    return context;\r\n  }\r\n\r\n  private getPreviousScenes(\r\n    manuscript: { scenes: Scene[]; currentOrder: string[] },\r\n    sceneId: string,\r\n    rewrittenScenes: Map<string, RewriteResult>\r\n  ): Scene[] {\r\n    const sceneIndex = manuscript.currentOrder.indexOf(sceneId);\r\n    if (sceneIndex <= 0) return [];\r\n\r\n    // Get last 3 scenes before this one\r\n    const startIndex = Math.max(0, sceneIndex - 3);\r\n    const previousScenes: Scene[] = [];\r\n\r\n    for (let i = startIndex; i < sceneIndex; i++) {\r\n      const prevSceneId = manuscript.currentOrder[i];\r\n      const prevScene = manuscript.scenes.find(s => s.id === prevSceneId);\r\n      if (!prevScene) continue;\r\n\r\n      // Use rewritten version if available\r\n      const rewritten = rewrittenScenes.get(prevSceneId);\r\n      if (rewritten && rewritten.rewrittenText) {\r\n        previousScenes.push({\r\n          ...prevScene,\r\n          text: rewritten.rewrittenText,\r\n          currentRewrite: rewritten.rewrittenText\r\n        });\r\n      } else {\r\n        previousScenes.push(prevScene);\r\n      }\r\n    }\r\n\r\n    return previousScenes;\r\n  }\r\n\r\n  private getSceneTitle(scene: Scene): string {\r\n    // Try to extract a title from the scene\r\n    const firstLine = (scene.text || '').split('\\n')[0];\r\n    if (firstLine && firstLine.length < 100) {\r\n      return firstLine;\r\n    }\r\n    return `Scene ${scene.position + 1}`;\r\n  }\r\n\r\n  private generateCompletionMessage(progress: BatchRewriteProgress): string {\r\n    const successful = progress.completedScenes - progress.errors.size;\r\n\r\n    if (progress.errors.size === 0) {\r\n      return `Successfully rewrote ${successful} scene${successful !== 1 ? 's' : ''}`;\r\n    } else if (successful === 0) {\r\n      return `Failed to rewrite ${progress.errors.size} scene${progress.errors.size !== 1 ? 's' : ''}`;\r\n    } else {\r\n      return `Rewrote ${successful} scene${successful !== 1 ? 's' : ''}, ${progress.errors.size} failed`;\r\n    }\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}\r\n\r\nexport default RewriteOrchestrator;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\SceneRewriter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\DiffEngine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\PerformanceOptimizer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\RewriteConsensusIntegration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\RewriteOrchestrator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\SceneRewriter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\SceneRewriterRetry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\shared\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\shared\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\types\\compromise.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\types\\preload.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\types\\vitest-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vite.main.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vite.preload.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vite.renderer.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vitest.setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
