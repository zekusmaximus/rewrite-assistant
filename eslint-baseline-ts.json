[{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\.eslintrc.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\eslint.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\__tests__\\SettingsService.security.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[816,819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[816,819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":47,"column":11,"nodeType":"BlockStatement","messageId":"unexpected","endLine":47,"endColumn":13,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1229,1229],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":79,"column":69,"nodeType":"BlockStatement","messageId":"unexpected","endLine":79,"endColumn":71,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2447,2447],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport * as os from 'os';\r\n\r\nlet userDataDir: string;\r\n\r\nvi.mock('electron', () => {\r\n  const api = {\r\n    app: {\r\n      getPath: (name: string) => {\r\n        if (name === 'userData') {\r\n          return userDataDir;\r\n        }\r\n        return '';\r\n      }\r\n    },\r\n    safeStorage: {\r\n      isEncryptionAvailable: () => true,\r\n      encryptString: (s: string) => Buffer.from('enc:' + s, 'utf8'),\r\n      decryptString: (b: Buffer) => Buffer.from(b).toString('utf8').replace(/^enc:/, '')\r\n    }\r\n  };\r\n  return api;\r\n});\r\n\r\nconst importService = async () => {\r\n  vi.resetModules();\r\n  const mod = await import('../../main/services/SettingsService');\r\n  return mod.default as any;\r\n};\r\n\r\nconst settingsFilePath = () => path.join(userDataDir, 'settings.json');\r\n\r\nconst makeTempUserData = async () => {\r\n  const prefix = path.join(os.tmpdir(), 'ra-userdata-');\r\n  return await fs.mkdtemp(prefix);\r\n};\r\n\r\nbeforeEach(async () => {\r\n  userDataDir = await makeTempUserData();\r\n});\r\n\r\nafterEach(async () => {\r\n  try {\r\n    await fs.rm(userDataDir, { recursive: true, force: true });\r\n  } catch {}\r\n});\r\n\r\ndescribe('SettingsService security and persistence', () => {\r\n  it('saves settings with encrypted apiKey and loads back decrypted', async () => {\r\n    const service = await importService();\r\n    const PLAINTEXT = 'test-openai-key';\r\n\r\n    const saveRes = await service.saveSettings({\r\n      providers: {\r\n        openai: { enabled: true, apiKey: PLAINTEXT, model: 'gpt-4-turbo-preview' }\r\n      }\r\n    });\r\n    expect(saveRes.success).toBe(true);\r\n\r\n    const raw = await fs.readFile(settingsFilePath(), 'utf8');\r\n    const parsed = JSON.parse(raw);\r\n    const stored = parsed?.providers?.openai?.apiKey;\r\n\r\n    expect(typeof stored).toBe('string');\r\n    // base64-like check and not equal to plaintext\r\n    expect(/^[A-Za-z0-9+/=]+$/.test(stored)).toBe(true);\r\n    expect(stored === PLAINTEXT).toBe(false);\r\n\r\n    const loaded = await service.loadSettings();\r\n    // Avoid printing secrets on assertion failure\r\n    expect(loaded?.providers?.openai?.apiKey === PLAINTEXT).toBe(true);\r\n  });\r\n\r\n  it('returns defaults when settings.json is missing', async () => {\r\n    const service = await importService();\r\n    // ensure file is absent\r\n    try { await fs.rm(settingsFilePath(), { force: true }); } catch {}\r\n\r\n    const loaded = await service.loadSettings();\r\n\r\n    expect(loaded?.general?.theme).toBe('light');\r\n    expect(loaded?.providers?.openai?.apiKey === '').toBe(true);\r\n  });\r\n\r\n  it('returns defaults on corrupted settings.json', async () => {\r\n    const service = await importService();\r\n\r\n    await fs.mkdir(userDataDir, { recursive: true });\r\n    await fs.writeFile(settingsFilePath(), 'not json', 'utf8');\r\n\r\n    const loaded = await service.loadSettings();\r\n\r\n    expect(loaded?.general?.theme).toBe('light');\r\n    expect(loaded?.providers?.openai?.apiKey === '').toBe(true);\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\__tests__\\rewriteHandlers.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":7,"column":36,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":7,"endColumn":44},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[338,341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[338,341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[626,629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[626,629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[658,661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[658,661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[800,803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[800,803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[837,840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[837,840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[872,875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[872,875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[909,912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[909,912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[946,949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[946,949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[999,1002],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[999,1002],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1039,1042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1039,1042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1080,1083],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1080,1083],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":46,"column":43,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":46,"endColumn":51},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1552,1555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1552,1555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3083,3086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3083,3086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":105,"column":37,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":105,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":120,"column":31,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":120,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":131,"column":31,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":131,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":153,"column":33,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":153,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5151,5154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5151,5154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeAll, beforeEach } from 'vitest';\r\nimport { IPC_CHANNELS } from '../../shared/constants';\r\n\r\n// Hoisted state so it's initialized before hoisted mocks execute\r\nconst hoisted = vi.hoisted(() => {\r\n  return {\r\n    registry: {} as Record<string, Function>,\r\n    mockSend: vi.fn(),\r\n    windows: [] as any[],\r\n  };\r\n});\r\n\r\n// Mock electron to provide minimal app/ipcMain/BrowserWindow used by main code\r\nvi.mock('electron', () => {\r\n  const { registry, mockSend, windows } = hoisted;\r\n\r\n  class MockBrowserWindow {\r\n    static getAllWindows = vi.fn(() => windows);\r\n    public webContents: any;\r\n    constructor(..._args: any[]) {\r\n      this.webContents = {\r\n        send: mockSend,\r\n        on: vi.fn(),\r\n        openDevTools: vi.fn(),\r\n      };\r\n      (this as any).once = vi.fn();\r\n      (this as any).on = vi.fn();\r\n      (this as any).show = vi.fn();\r\n      (this as any).hide = vi.fn();\r\n      (this as any).setMenuBarVisibility = vi.fn();\r\n      (this as any).loadURL = vi.fn();\r\n      (this as any).loadFile = vi.fn();\r\n      (this as any).isDestroyed = vi.fn(() => false);\r\n      windows.push(this);\r\n    }\r\n  }\r\n\r\n  return {\r\n    app: {\r\n      whenReady: () => Promise.resolve(),\r\n      on: vi.fn(),\r\n      off: vi.fn(),\r\n      quit: vi.fn(),\r\n    },\r\n    ipcMain: {\r\n      handle: vi.fn((channel: string, fn: Function) => {\r\n        registry[channel] = fn;\r\n      }),\r\n      on: vi.fn(),\r\n      removeHandler: vi.fn(),\r\n      removeAllListeners: vi.fn(),\r\n    },\r\n    BrowserWindow: MockBrowserWindow as any,\r\n    dialog: {\r\n      showOpenDialog: vi.fn(async () => ({ canceled: true, filePaths: [] })),\r\n      showSaveDialog: vi.fn(async () => ({ canceled: true, filePath: undefined })),\r\n    },\r\n  };\r\n});\r\n\r\n// Ensure electron-squirrel-startup import is inert\r\nvi.mock('electron-squirrel-startup', () => ({}));\r\n\r\n// Break circular import: mock the app entry to avoid executing real index.ts during handlers import\r\nvi.mock('../../main/index', () => {\r\n  // Provide a stub mainWindow export referenced by handlers\r\n  return { mainWindow: undefined };\r\n});\r\n\r\n// Mock SceneRewriter used by the GENERATE_REWRITE handler\r\nvi.mock('../../services/rewrite/SceneRewriter', () => {\r\n  return {\r\n    default: vi.fn().mockImplementation(() => {\r\n      return {\r\n        rewriteScene: vi.fn().mockResolvedValue({\r\n          success: true,\r\n          rewrittenText: 'rewritten text',\r\n          issuesAddressed: [],\r\n          changesExplanation: 'mocked explanation',\r\n          preservedElements: [],\r\n          diffData: [],\r\n          modelUsed: 'mock-model',\r\n        }),\r\n      };\r\n    }),\r\n  };\r\n});\r\n\r\n// Import handlers after mocks and invoke registration directly.\r\n// Also ensure at least one BrowserWindow exists so progress events can be emitted.\r\nbeforeAll(async () => {\r\n  const { setupIPCHandlers } = await import('../../main/handlers');\r\n  setupIPCHandlers();\r\n\r\n  const { BrowserWindow } = await import('electron');\r\n  // Create one window instance in the mocked electron so handlers can find it\r\n   \r\n  new (BrowserWindow as any)();\r\n});\r\n\r\ndescribe('IPC rewrite handler', () => {\r\n  const handlers = hoisted.registry;\r\n  const mockSend = hoisted.mockSend;\r\n\r\n  const resolveRewriteHandler = (): Function | undefined => {\r\n    const preferred = handlers[IPC_CHANNELS.GENERATE_REWRITE];\r\n    if (typeof preferred === 'function') return preferred;\r\n    const all = Object.keys(handlers);\r\n    return all.length ? handlers[all[0]] : undefined;\r\n  };\r\n\r\n  beforeEach(() => {\r\n    mockSend.mockClear();\r\n  });\r\n\r\n  it('validates payload and returns error when missing scene or issues', async () => {\r\n    const fn = resolveRewriteHandler();\r\n    expect(fn, `Available channels: ${Object.keys(handlers).join(', ')}`).toBeTypeOf('function');\r\n\r\n    const res1 = await (fn as Function)({}, { scene: null, issues: [] });\r\n    // Expect standardized error shape from toErrorResponse()\r\n    expect(res1).toEqual(\r\n      expect.objectContaining({\r\n        ok: false,\r\n        error: expect.objectContaining({\r\n          message: expect.stringContaining('Invalid'),\r\n        }),\r\n      })\r\n    );\r\n\r\n    const res2 = await (fn as Function)({}, { scene: { id: 's1', text: 'x' }, issues: [] });\r\n    expect(res2.ok).toBe(false);\r\n  });\r\n\r\n  it('invokes SceneRewriter and emits progress on success', async () => {\r\n    const fn = resolveRewriteHandler();\r\n    expect(fn, `Available channels: ${Object.keys(handlers).join(', ')}`).toBeTypeOf('function');\r\n\r\n    const payload = {\r\n      sceneId: 's1',\r\n      scene: { id: 's1', text: 'original' },\r\n      issues: [{ id: 'i1', type: 'pronoun', severity: 'should-fix', description: 'x' }],\r\n      previousScenes: [],\r\n      readerContext: {\r\n        knownCharacters: new Set(['Alice']),\r\n        establishedTimeline: [],\r\n        revealedPlotPoints: [],\r\n        establishedSettings: [],\r\n      },\r\n      preserveElements: [],\r\n    };\r\n\r\n    const result = await (fn as Function)({}, payload);\r\n    expect(result.success).toBe(true);\r\n    expect(result.rewrittenText).toBe('rewritten text');\r\n\r\n    expect(mockSend).toHaveBeenCalledWith(\r\n      (IPC_CHANNELS as any).REEWRITE_PROGRESS ?? IPC_CHANNELS.REWRITE_PROGRESS, // allow minor constant drift\r\n      expect.objectContaining({\r\n        sceneId: 's1',\r\n        status: 'complete',\r\n      })\r\n    );\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\preload.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[900,903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[900,903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1016,1019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1016,1019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1236,1239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1236,1239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1330,1333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1330,1333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1830,1833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1830,1833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2327,2330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2327,2330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2343,2346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2343,2346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2413,2416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2413,2416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2552,2555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2552,2555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2589,2592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2589,2592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2675,2678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2675,2678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3016,3019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3016,3019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3034,3037],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3034,3037],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { contextBridge, ipcRenderer } from 'electron';\r\nimport { IPC_CHANNELS } from '../shared/constants';\r\nimport { Manuscript } from '../shared/types';\r\n\r\n// Expose protected methods that allow the renderer process to use\r\n// the ipcRenderer without exposing the entire object\r\ncontextBridge.exposeInMainWorld('electronAPI', {\r\n  // File operations\r\n  loadFile: (): Promise<Manuscript | null> => ipcRenderer.invoke(IPC_CHANNELS.LOAD_FILE),\r\n  loadSpecificFile: (filePath: string): Promise<Manuscript | null> => ipcRenderer.invoke(IPC_CHANNELS.LOAD_SPECIFIC_FILE, filePath),\r\n  autoLoadManuscript: (): Promise<Manuscript | null> => ipcRenderer.invoke(IPC_CHANNELS.AUTO_LOAD_MANUSCRIPT),\r\n  saveFile: (manuscript: Manuscript): Promise<string | null> => ipcRenderer.invoke(IPC_CHANNELS.SAVE_FILE, manuscript),\r\n\r\n  // AI provider configuration (no logging of secrets)\r\n  configureProviders: (config: any) => ipcRenderer.invoke(IPC_CHANNELS.CONFIGURE_AI_PROVIDER, config),\r\n  testProvider: (provider: string, config: any) =>\r\n    ipcRenderer.invoke('test-ai-provider', { provider, config }),\r\n  \r\n  // Settings (secure, via main process)\r\n  loadSettings: () => ipcRenderer.invoke(IPC_CHANNELS.SETTINGS_LOAD),\r\n  saveSettings: (settings: any) => ipcRenderer.invoke(IPC_CHANNELS.SETTINGS_SAVE, settings),\r\n  testConnection: (params: any) => ipcRenderer.invoke(IPC_CHANNELS.SETTINGS_TEST_CONNECTION, params),\r\n  \r\n  // Platform info\r\n  platform: process.platform,\r\n  \r\n  // Version info\r\n  versions: {\r\n    node: process.versions.node,\r\n    chrome: process.versions.chrome,\r\n    electron: process.versions.electron,\r\n  }\r\n});\r\n\r\n// Expose a minimal ipcRenderer bridge to support invoke-based workflows (used by rewrite store/UI)\r\ncontextBridge.exposeInMainWorld('electron', {\r\n  ipcRenderer: {\r\n    invoke: (channel: string, ...args: any[]) => ipcRenderer.invoke(channel, ...args),\r\n  }\r\n});\r\n\r\n// Type definitions for the exposed API\r\ndeclare global {\r\n interface Window {\r\n   electronAPI: {\r\n     // File ops\r\n     loadFile: () => Promise<Manuscript | null>;\r\n     loadSpecificFile: (filePath: string) => Promise<Manuscript | null>;\r\n     autoLoadManuscript: () => Promise<Manuscript | null>;\r\n     saveFile: (manuscript: Manuscript) => Promise<string | null>;\r\n\r\n     // AI provider endpoints\r\n     configureProviders: (config: any) => Promise<any>;\r\n     testProvider: (\r\n       provider: string,\r\n       config: any\r\n     ) => Promise<{ ok: boolean; error?: { message: string; code: string } }>;\r\n \r\n     // Settings\r\n     loadSettings: () => Promise<any>;\r\n     saveSettings: (settings: any) => Promise<{ success: boolean; error?: string }>;\r\n     testConnection: (params: any) => Promise<{ success: boolean; error?: string }>;\r\n \r\n     // Env info\r\n     platform: string;\r\n     versions: {\r\n       node: string;\r\n       chrome: string;\r\n       electron: string;\r\n     };\r\n   };\r\n   // Minimal ipc bridge typing (only what's exposed)\r\n   electron: {\r\n     ipcRenderer: {\r\n       invoke: (channel: string, ...args: any[]) => Promise<any>;\r\n     };\r\n   };\r\n }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\main\\services\\SettingsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2720,2723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2720,2723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":116,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3186,3189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3186,3189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3521,3524],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3521,3524],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3795,3798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3795,3798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4288,4291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4288,4291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4686,4689],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4686,4689],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4897,4900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4897,4900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4909,4912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4909,4912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":153,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":156,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5005,5008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5005,5008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":167,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5030,5033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5030,5033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":167,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5050,5053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5050,5053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5139,5142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5139,5142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":172,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5271,5274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5271,5274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":173,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5307,5310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5307,5310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7004,7007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7004,7007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7066,7069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7066,7069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":308,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10517,10520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10517,10520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { safeStorage, app } from 'electron';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport * as https from 'https';\r\n\r\ntype ProviderName = 'claude' | 'openai' | 'gemini';\r\n\r\ninterface ProviderConfig {\r\n  enabled?: boolean;\r\n  apiKey?: string;\r\n  model?: string;\r\n  baseUrl?: string;\r\n}\r\n\r\ninterface Settings {\r\n  providers: {\r\n    claude: ProviderConfig;\r\n    openai: ProviderConfig;\r\n    gemini: ProviderConfig;\r\n  };\r\n  general: {\r\n    autoSave: boolean;\r\n    autoAnalyze: boolean;\r\n    theme: string;\r\n  };\r\n}\r\n\r\nclass SettingsService {\r\n  private settingsPath: string;\r\n\r\n  constructor() {\r\n    this.settingsPath = path.join(app.getPath('userData'), 'settings.json');\r\n  }\r\n\r\n  private getDefaultSettings(): Settings {\r\n    return {\r\n      providers: {\r\n        claude: { enabled: false, apiKey: '', model: 'claude-3-opus-20240229' },\r\n        openai: { enabled: false, apiKey: '', model: 'gpt-4-turbo-preview' },\r\n        gemini: { enabled: false, apiKey: '', model: 'gemini-pro' }\r\n      },\r\n      general: {\r\n        autoSave: true,\r\n        autoAnalyze: false,\r\n        theme: 'light'\r\n      }\r\n    };\r\n  }\r\n\r\n  private async ensureDirExists(): Promise<void> {\r\n    try {\r\n      await fs.mkdir(path.dirname(this.settingsPath), { recursive: true });\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  private base64ToBuffer(b64: string): Buffer {\r\n    return Buffer.from(b64, 'base64');\r\n  }\r\n\r\n  private bufferToBase64(buf: Buffer): string {\r\n    return buf.toString('base64');\r\n  }\r\n\r\n  private decryptIfNeeded(value: unknown): string {\r\n    if (typeof value !== 'string' || !value) return '';\r\n    if (!safeStorage.isEncryptionAvailable()) {\r\n      // If encryption isn't available, we cannot decrypt; return as-is\r\n      return value;\r\n    }\r\n    try {\r\n      // Attempt to treat as base64-encoded encrypted string\r\n      const buf = this.base64ToBuffer(value);\r\n      return safeStorage.decryptString(buf);\r\n    } catch {\r\n      // If decryption fails, assume it was plaintext previously saved\r\n      return value;\r\n    }\r\n  }\r\n\r\n  private encryptIfAvailable(value: unknown): string {\r\n    if (typeof value !== 'string' || !value) return '';\r\n    if (!safeStorage.isEncryptionAvailable()) {\r\n      // If encryption isn't available, persist plaintext (best effort)\r\n      return value;\r\n    }\r\n    try {\r\n      const enc = safeStorage.encryptString(value);\r\n      return this.bufferToBase64(Buffer.from(enc));\r\n    } catch {\r\n      // If encryption fails unexpectedly, persist plaintext to avoid data loss\r\n      return value;\r\n    }\r\n  }\r\n\r\n  async loadSettings(): Promise<Settings> {\r\n    try {\r\n      const raw = await fs.readFile(this.settingsPath, 'utf-8');\r\n      let parsed: any;\r\n      try {\r\n        parsed = JSON.parse(raw);\r\n      } catch {\r\n        return this.getDefaultSettings();\r\n      }\r\n\r\n      const settings: Settings = {\r\n        ...this.getDefaultSettings(),\r\n        ...(parsed || {})\r\n      };\r\n\r\n      // Decrypt provider API keys if present\r\n      try {\r\n        const providers: Array<ProviderName> = ['claude', 'openai', 'gemini'];\r\n        for (const p of providers) {\r\n          const current = (settings.providers as any)[p];\r\n          if (current && typeof current.apiKey === 'string' && current.apiKey) {\r\n            current.apiKey = this.decryptIfNeeded(current.apiKey);\r\n          }\r\n        }\r\n      } catch {\r\n        // Do not throw or log secrets; fall back to defaults when catastrophic\r\n      }\r\n\r\n      return settings;\r\n    } catch (err: any) {\r\n      // If file missing or unreadable, return defaults\r\n      if (err && (err.code === 'ENOENT' || err.code === 'ENOTDIR')) {\r\n        return this.getDefaultSettings();\r\n      }\r\n      return this.getDefaultSettings();\r\n    }\r\n  }\r\n\r\n  async saveSettings(settings: any): Promise<{ success: boolean; error?: string }> {\r\n    try {\r\n      await this.ensureDirExists();\r\n\r\n      // Create a shallow clone and ensure structure\r\n      const toWrite: Settings = {\r\n        ...this.getDefaultSettings(),\r\n        ...(settings || {})\r\n      };\r\n\r\n      // Encrypt API keys if available\r\n      try {\r\n        const providers: Array<ProviderName> = ['claude', 'openai', 'gemini'];\r\n        for (const p of providers) {\r\n          const current = (toWrite.providers as any)[p];\r\n          if (current && typeof current.apiKey === 'string' && current.apiKey) {\r\n            current.apiKey = this.encryptIfAvailable(current.apiKey);\r\n          }\r\n        }\r\n      } catch {\r\n        // Continue; do not log secrets\r\n      }\r\n\r\n      await fs.writeFile(this.settingsPath, JSON.stringify(toWrite, null, 2), 'utf-8');\r\n      return { success: true };\r\n    } catch (error: any) {\r\n      return { success: false, error: String(error?.message || 'Failed to save settings') };\r\n    }\r\n  }\r\n\r\n  // Lightweight fetch getter with safe fallbacks\r\n  private async getFetch(): Promise<(input: any, init?: any) => Promise<{ ok: boolean; status: number; text: () => Promise<string>; json: () => Promise<any> }>> {\r\n    const g: any = globalThis as any;\r\n    if (typeof g.fetch === 'function') {\r\n      return g.fetch.bind(globalThis) as any;\r\n    }\r\n    // Minimal https-based fetch-like fallback (POST only in our usage)\r\n    const httpsFetch = (input: string, init?: any) => {\r\n      return new Promise<any>((resolve) => {\r\n        try {\r\n          const url = new URL(input);\r\n          const opts: https.RequestOptions = {\r\n            method: (init?.method || 'GET').toString(),\r\n            hostname: url.hostname,\r\n            port: url.port || (url.protocol === 'https:' ? 443 : 80),\r\n            path: url.pathname + (url.search || ''),\r\n            headers: init?.headers || {}\r\n          };\r\n          const req = https.request(opts, (res) => {\r\n            const chunks: Buffer[] = [];\r\n            res.on('data', (d) => chunks.push(Buffer.isBuffer(d) ? d : Buffer.from(d)));\r\n            res.on('end', () => {\r\n              const body = Buffer.concat(chunks).toString('utf-8');\r\n              resolve({\r\n                ok: res.statusCode! >= 200 && res.statusCode! < 300,\r\n                status: res.statusCode || 0,\r\n                text: async () => body,\r\n                json: async () => {\r\n                  try { return JSON.parse(body); } catch { return null; }\r\n                }\r\n              });\r\n            });\r\n          });\r\n          req.on('error', () => {\r\n            resolve({\r\n              ok: false,\r\n              status: 0,\r\n              text: async () => '',\r\n              json: async () => null\r\n            });\r\n          });\r\n          if (init?.body) {\r\n            const bodyData = typeof init.body === 'string' ? init.body : JSON.stringify(init.body);\r\n            req.write(bodyData);\r\n          }\r\n          req.end();\r\n        } catch {\r\n          resolve({\r\n            ok: false,\r\n            status: 0,\r\n            text: async () => '',\r\n            json: async () => null\r\n          });\r\n        }\r\n      });\r\n    };\r\n    return httpsFetch as any;\r\n  }\r\n\r\n  async testConnection(provider: string, config: any): Promise<{ success: boolean; error?: string }> {\r\n    try {\r\n      const p = String(provider || '').toLowerCase();\r\n      if (!['claude', 'openai', 'gemini'].includes(p)) {\r\n        return { success: false, error: 'Unsupported provider' };\r\n      }\r\n      if (!config || typeof config !== 'object') {\r\n        return { success: false, error: 'Invalid configuration' };\r\n      }\r\n      const apiKey = typeof config.apiKey === 'string' ? config.apiKey.trim() : '';\r\n      if (!apiKey) {\r\n        return { success: false, error: 'Missing API key' };\r\n      }\r\n\r\n      const fetchImpl = await this.getFetch();\r\n\r\n      if (p === 'claude') {\r\n        const model = typeof config.model === 'string' && config.model.trim() ? config.model.trim() : 'claude-3-opus-20240229';\r\n        const base = typeof config.baseUrl === 'string' && /^https?:\\/\\//i.test(config.baseUrl) ? config.baseUrl.replace(/\\/+$/, '') : 'https://api.anthropic.com';\r\n        const url = `${base}/v1/messages`;\r\n        const res = await fetchImpl(url, {\r\n          method: 'POST',\r\n          headers: {\r\n            'content-type': 'application/json',\r\n            'x-api-key': apiKey,\r\n            'anthropic-version': '2023-06-01'\r\n          },\r\n          body: JSON.stringify({\r\n            model,\r\n            max_tokens: 1,\r\n            messages: [{ role: 'user', content: 'ping' }]\r\n          })\r\n        });\r\n        if (!res.ok) {\r\n          return { success: false, error: `HTTP ${res.status}` };\r\n        }\r\n        return { success: true };\r\n      }\r\n\r\n      if (p === 'openai') {\r\n        const model = typeof config.model === 'string' && config.model.trim() ? config.model.trim() : 'gpt-4-turbo-preview';\r\n        const base = typeof config.baseUrl === 'string' && /^https?:\\/\\//i.test(config.baseUrl) ? config.baseUrl.replace(/\\/+$/, '') : 'https://api.openai.com/v1';\r\n        const url = `${base}/chat/completions`;\r\n        const res = await fetchImpl(url, {\r\n          method: 'POST',\r\n          headers: {\r\n            'content-type': 'application/json',\r\n            'authorization': `Bearer ${apiKey}`\r\n          },\r\n          body: JSON.stringify({\r\n            model,\r\n            messages: [{ role: 'user', content: 'ping' }],\r\n            max_tokens: 1,\r\n            temperature: 0\r\n          })\r\n        });\r\n        if (!res.ok) {\r\n          return { success: false, error: `HTTP ${res.status}` };\r\n        }\r\n        return { success: true };\r\n      }\r\n\r\n      // gemini\r\n      {\r\n        const model = typeof config.model === 'string' && config.model.trim() ? config.model.trim() : 'gemini-pro';\r\n        // Gemini typically uses fixed base; allow override if explicitly provided\r\n        const base = typeof config.baseUrl === 'string' && /^https?:\\/\\//i.test(config.baseUrl)\r\n          ? config.baseUrl.replace(/\\/+$/, '')\r\n          : 'https://generativelanguage.googleapis.com/v1beta';\r\n        const url = `${base}/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`;\r\n        const res = await fetchImpl(url, {\r\n          method: 'POST',\r\n          headers: { 'content-type': 'application/json' },\r\n          body: JSON.stringify({\r\n            contents: [\r\n              { parts: [{ text: 'ping' }] }\r\n            ]\r\n          })\r\n        });\r\n        if (!res.ok) {\r\n          return { success: false, error: `HTTP ${res.status}` };\r\n        }\r\n        return { success: true };\r\n      }\r\n    } catch (error: any) {\r\n      return { success: false, error: String(error?.message || 'Connection test failed') };\r\n    }\r\n  }\r\n}\r\n\r\nexport default new SettingsService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\components\\ErrorMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\components\\LoadingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\components\\SceneViewer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildReaderContext' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1333,1336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1333,1336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1371,1374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1371,1374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react/display-name","severity":2,"message":"Component definition is missing display name","line":40,"column":21,"nodeType":"CallExpression","messageId":"noDisplayName","endLine":234,"endColumn":3},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'manuscript' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":41,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":39}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { forwardRef, useImperativeHandle, useMemo, useRef, useState } from 'react';\r\nimport { useManuscriptStore } from '../stores/manuscriptStore';\r\nimport useIssueHighlighting from '../features/analyze/hooks/useIssueHighlighting';\r\nimport IssueHighlighter from '../features/analyze/components/IssueHighlighter';\r\nimport type { Scene, ReaderKnowledge, ContinuityIssue } from '../../shared/types';\r\nimport useRewriteStore from '../features/rewrite/stores/rewriteStore';\r\nimport RewriteEditor from '../features/rewrite/components/RewriteEditor';\r\n\r\nexport interface SceneViewerHandle {\r\n  scrollToIssue(sceneId: string, issue: ContinuityIssue): void;\r\n}\r\n\r\n// Helper: focused reader context builder\r\nconst buildReaderContext = (previousScenes: Scene[]): ReaderKnowledge => {\r\n  const context: ReaderKnowledge = {\r\n    knownCharacters: new Set<string>(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n\r\n  previousScenes.forEach((scene) => {\r\n    scene.characters?.forEach((char) => context.knownCharacters.add(char));\r\n    scene.timeMarkers?.forEach((marker) => {\r\n      context.establishedTimeline.push({ label: marker });\r\n    });\r\n    scene.locationMarkers?.forEach((loc) => {\r\n      context.establishedSettings.push({ name: loc });\r\n    });\r\n    if (Array.isArray((scene as any).plotMarkers)) {\r\n      (scene as any).plotMarkers.forEach((p: string) => {\r\n        context.revealedPlotPoints.push(p);\r\n      });\r\n    }\r\n  });\r\n\r\n  return context;\r\n};\r\n\r\nconst SceneViewer = forwardRef<SceneViewerHandle>((_props, ref) => {\r\n  const { getSelectedScene, manuscript } = useManuscriptStore();\r\n  const selectedScene = getSelectedScene();\r\n  const analysis = selectedScene?.continuityAnalysis;\r\n\r\n  // Rewrite workflow integration\r\n  const { generateRewrite, hasRewrite, isRewriting, currentRewriteSceneId } = useRewriteStore();\r\n  const [showRewriteEditor, setShowRewriteEditor] = useState(false);\r\n\r\n  // Generate rewrite via store and open the editor\r\n  const handleGenerateRewrite = async () => {\r\n    if (!selectedScene || !analysis?.issues) return;\r\n    await generateRewrite(selectedScene.id);\r\n    setShowRewriteEditor(true);\r\n  };\r\n\r\n  // Is this specific scene currently generating?\r\n  const isGeneratingForThisScene = isRewriting && currentRewriteSceneId === selectedScene?.id;\r\n\r\n  const { buildHighlightsForScene, getScrollTarget } = useIssueHighlighting();\r\n\r\n  const spans = useMemo(() => {\r\n    if (!selectedScene) return [];\r\n    return buildHighlightsForScene(selectedScene.id);\r\n  }, [selectedScene, buildHighlightsForScene]);\r\n\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n\r\n  useImperativeHandle(ref, () => ({\r\n    scrollToIssue(sceneId: string, issue: ContinuityIssue) {\r\n      const root = containerRef.current;\r\n      if (!root) return;\r\n\r\n      const anchorId = getScrollTarget(sceneId, issue);\r\n      const escapeAttr = (s: string) => s.replace(/\"/g, '\\\\\"');\r\n\r\n      let target: HTMLElement | null =\r\n        (root.querySelector(`[id=\"${escapeAttr(anchorId)}\"]`) as HTMLElement | null) ??\r\n        (root.querySelector(`[data-issue-id=\"${escapeAttr(anchorId)}\"]`) as HTMLElement | null);\r\n\r\n      if (!target) {\r\n        const startIdx = Array.isArray(issue.textSpan) ? Number(issue.textSpan?.[0] ?? 0) : 0;\r\n        const candidates = Array.from(root.querySelectorAll<HTMLElement>('[data-start][data-end]'));\r\n        let best: { el: HTMLElement; dist: number } | null = null;\r\n        for (const el of candidates) {\r\n          const a = Number(el.getAttribute('data-start') ?? '0');\r\n          const b = Number(el.getAttribute('data-end') ?? '0');\r\n          const contains = a <= startIdx && startIdx < b;\r\n          const dist = contains ? 0 : Math.min(Math.abs(startIdx - a), Math.abs(startIdx - b));\r\n          if (!best || dist < best.dist || (dist === best.dist && a <= startIdx)) {\r\n            best = { el, dist };\r\n            if (dist === 0) break;\r\n          }\r\n        }\r\n        target = best?.el ?? null;\r\n      }\r\n\r\n      if (target) {\r\n        try {\r\n          target.scrollIntoView({ behavior: 'smooth', block: 'center' });\r\n        } catch {\r\n          // no-op if scrollIntoView options unsupported\r\n          target.scrollIntoView();\r\n        }\r\n        // transient flash to draw attention\r\n        target.classList.add('ring-2', 'ring-indigo-500', 'transition-shadow');\r\n        setTimeout(() => {\r\n          target.classList.remove('ring-2', 'ring-indigo-500', 'transition-shadow');\r\n        }, 1200);\r\n      }\r\n    },\r\n  }));\r\n\r\n  if (!selectedScene) {\r\n    return (\r\n      <div className=\"h-full flex items-center justify-center text-gray-500\">\r\n        <div className=\"text-center\">\r\n          <div className=\"mx-auto h-12 w-12 text-gray-400 mb-4\">\r\n            <svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\r\n            </svg>\r\n          </div>\r\n          <p>Select a scene to view its content</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"h-full flex flex-col\">\r\n      {/* Scene Header */}\r\n      <div className=\"p-4 border-b border-gray-200 bg-gray-50\">\r\n        <div className=\"flex items-center justify-between\">\r\n          <div>\r\n            <h3 className=\"text-lg font-semibold text-gray-900\">\r\n              Scene {selectedScene.position + 1}\r\n            </h3>\r\n            <div className=\"flex items-center gap-4 text-sm text-gray-600 mt-1\">\r\n              <span>{selectedScene.wordCount} words</span>\r\n              {selectedScene.hasBeenMoved && (\r\n                <span className=\"inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800\">\r\n                  Moved from position {selectedScene.originalPosition + 1}\r\n                </span>\r\n              )}\r\n              <span\r\n                className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${\r\n                  selectedScene.rewriteStatus === 'pending'\r\n                    ? 'bg-gray-100 text-gray-800'\r\n                    : selectedScene.rewriteStatus === 'generated'\r\n                    ? 'bg-blue-100 text-blue-800'\r\n                    : selectedScene.rewriteStatus === 'approved'\r\n                    ? 'bg-green-100 text-green-800'\r\n                    : 'bg-red-100 text-red-800'\r\n                }`}\r\n              >\r\n                {selectedScene.rewriteStatus}\r\n              </span>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Scene Content */}\r\n      <div ref={containerRef} className=\"flex-1 overflow-auto p-4\">\r\n        <div className=\"prose max-w-none\">\r\n          <IssueHighlighter\r\n            content={selectedScene.currentRewrite || selectedScene.text}\r\n            spans={spans}\r\n            className=\"whitespace-pre-wrap text-gray-900 leading-relaxed\"\r\n          />\r\n        </div>\r\n      </div>\r\n\r\n      {/* Scene Actions */}\r\n      <div className=\"p-4 border-t border-gray-200 bg-gray-50\">\r\n        <div className=\"flex justify-between items-center\">\r\n          <div className=\"text-sm text-gray-600\">\r\n            {selectedScene.hasBeenMoved ? (\r\n              <span>This scene has been moved and may need rewriting</span>\r\n            ) : (\r\n              <span>Scene is in its original position</span>\r\n            )}\r\n          </div>\r\n          <div className=\"flex gap-2\">\r\n            {selectedScene.hasBeenMoved && ((analysis?.issues?.length ?? 0) > 0) && (\r\n              <>\r\n                {!hasRewrite(selectedScene.id) ? (\r\n                  <button\r\n                    onClick={handleGenerateRewrite}\r\n                    disabled={isGeneratingForThisScene}\r\n                    className={`px-3 py-1 text-sm font-medium rounded-md focus:outline-none focus:ring-2 ${\r\n                      isGeneratingForThisScene\r\n                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\r\n                        : 'text-green-700 bg-green-100 hover:bg-green-200 focus:ring-green-500'\r\n                    }`}\r\n                  >\r\n                    {isGeneratingForThisScene ? 'Generating...' : 'Generate Rewrite'}\r\n                  </button>\r\n                ) : (\r\n                  <>\r\n                    <button\r\n                      onClick={() => setShowRewriteEditor(true)}\r\n                      className=\"px-3 py-1 text-sm font-medium text-blue-700 bg-blue-100 rounded-md hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                    >\r\n                      View Rewrite\r\n                    </button>\r\n                    <button\r\n                      onClick={handleGenerateRewrite}\r\n                      disabled={isGeneratingForThisScene}\r\n                      className=\"px-3 py-1 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500\"\r\n                    >\r\n                      Regenerate\r\n                    </button>\r\n                  </>\r\n                )}\r\n              </>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Rewrite Editor Modal */}\r\n      {showRewriteEditor && selectedScene && (\r\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n          <div className=\"bg-white rounded-lg shadow-xl w-full max-w-6xl h-5/6 flex flex-col\">\r\n            <RewriteEditor\r\n              scene={selectedScene}\r\n              onClose={() => setShowRewriteEditor(false)}\r\n            />\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default SceneViewer;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\__tests__\\DetectorIntegration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildReader' is defined but never used. Allowed unused vars must match /^_/u.","line":44,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2114,2117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2114,2117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2312,2315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2312,2315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2782,2785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2782,2785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3014,3017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3014,3017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4145,4148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4145,4148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4166,4169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4166,4169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4560,4563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4560,4563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4762,4765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4762,4765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5381,5384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5381,5384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":154,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5402,5405],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5402,5405],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5570,5573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5570,5573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":170,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5969,5972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5969,5972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6249,6252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6249,6252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":191,"column":119,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":122,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6808,6811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6808,6811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":127,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":130,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6941,6944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6941,6944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7139,7142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7139,7142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7206,7209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7206,7209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7307,7310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7307,7310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":203,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7379,7382],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7379,7382],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport PronounDetector from '../detectors/PronounDetector';\r\nimport TimelineDetector from '../detectors/TimelineDetector';\r\nimport CharacterDetector from '../detectors/CharacterDetector';\r\nimport PlotContextDetector from '../detectors/PlotContextDetector';\r\nimport EngagementDetector from '../detectors/EngagementDetector';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { ValidationPipeline } from '../../../../services/ai/validation/ValidationPipeline';\r\n\r\ntype AnalyzeReq = Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\nfunction buildScene(overrides?: Partial<Scene>): Scene {\r\n  const base: Scene = {\r\n    id: 's1',\r\n    text: 'Alice looked at Bob. They went home together.',\r\n    wordCount: 7,\r\n    position: 3,\r\n    originalPosition: 1,\r\n    characters: ['Alice', 'Bob'],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: true,\r\n    rewriteStatus: 'pending',\r\n  };\r\n  return { ...base, ...(overrides ?? {}) } as Scene;\r\n}\r\n\r\nfunction buildPrev(n = 2): Scene[] {\r\n  return Array.from({ length: n }).map((_, i) => ({\r\n    id: `p${i + 1}`,\r\n    text: `Prev ${i + 1} text with Alice and Bob context.`,\r\n    wordCount: 6,\r\n    position: i,\r\n    originalPosition: i,\r\n    characters: ['Alice'],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending',\r\n  })) as Scene[];\r\n}\r\n\r\nfunction buildReader(): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(['Alice']),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\nfunction makeManagerStub(recorded: AnalyzeReq[]) {\r\n  const stub: Pick<AIServiceManager, 'analyzeContinuity'> = {\r\n    analyzeContinuity: vi.fn(async (req: AnalyzeReq) => {\r\n      recorded.push(req);\r\n      const issues: ContinuityIssue[] = []; // return empty to keep mapping deterministic\r\n      return {\r\n        issues,\r\n        metadata: {\r\n          modelUsed: (req as any).__modelId ?? 'mock',\r\n          provider: 'openai',\r\n          costEstimate: 0,\r\n          durationMs: 1,\r\n          confidence: 0.6,\r\n          cached: false,\r\n        },\r\n      };\r\n    }) as any,\r\n  };\r\n  return stub as AIServiceManager;\r\n}\r\n\r\ndescribe('Detector integration - AnalysisRequest enrichment and consensus adapter', () => {\r\n  beforeEach(() => {\r\n    vi.restoreAllMocks();\r\n  });\r\n\r\n  it('non-critical pronoun request: single analyze call with enriched fields', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new PronounDetector();\r\n\r\n    const scene = buildScene({ position: 7 } as any); // no critical flag\r\n    const prev = buildPrev(3);\r\n    await det.detect(scene, prev, manager);\r\n\r\n    // One AI call expected (enrichment path uses single-run)\r\n    expect(calls.length).toBe(1);\r\n    const req = calls[0] as any;\r\n\r\n    // Required enriched fields presence\r\n    expect(req).toBeTruthy();\r\n    expect(req.scene).toBeTruthy();\r\n    expect(req.readerContext).toBeTruthy();\r\n    expect(req.previousScenes).toBeTruthy();\r\n\r\n    // taskType/detector label\r\n    expect(req.taskType).toBe('pronoun');\r\n    expect(req.detector).toBe('pronoun');\r\n\r\n    // sceneText and newPosition meta added (local-only)\r\n    expect(typeof req.sceneText).toBe('string');\r\n    expect(req.sceneText).toContain('Alice looked at Bob');\r\n\r\n    expect(typeof req.newPosition).toBe('number');\r\n    expect(req.newPosition).toBe(7);\r\n\r\n    // previousScenes truncated/compacted upstream but is an array\r\n    expect(Array.isArray(req.previousScenes)).toBe(true);\r\n\r\n    // readerContext knownCharacters is a Set\r\n    expect(req.readerContext.knownCharacters instanceof Set).toBe(true);\r\n  });\r\n\r\n  it('critical pronoun request: consensus path calls analyze twice with distinct modelId', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new PronounDetector();\r\n\r\n    const scene = buildScene({ position: 4 } as any);\r\n    (scene as any).critical = true; // signal critical\r\n    const prev = buildPrev(2);\r\n\r\n    // Spy on reconcile to ensure consensus path engaged\r\n    const spyRecon = vi.spyOn(ValidationPipeline, 'reconcile');\r\n\r\n    await det.detect(scene, prev, manager);\r\n\r\n    // Two calls expected (consensus with default 2 candidates)\r\n    expect(calls.length).toBe(2);\r\n\r\n    const modelIds = new Set((calls.map((r: any) => r.__modelId).filter(Boolean)));\r\n    expect(modelIds.size).toBeGreaterThanOrEqual(2); // distinct per candidate\r\n\r\n    // Each call still carries enriched fields\r\n    for (const req of calls as any[]) {\r\n      expect(req.taskType).toBe('pronoun');\r\n      expect(typeof req.sceneText).toBe('string');\r\n    }\r\n\r\n    expect(spyRecon).toHaveBeenCalledTimes(1);\r\n  });\r\n\r\n  it('timeline detector honors enrichment and consensus flags', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new TimelineDetector();\r\n\r\n    // Provide clear temporal markers so localDetection will produce targets (and trigger AI)\r\n    const scene = buildScene({\r\n      text: 'Next morning, the sky cleared. Later that day, rain returned. Meanwhile, plans were made.',\r\n    } as any);\r\n    (scene as any).critical = true;\r\n    const prev = buildPrev(1);\r\n\r\n    await det.detect(scene, prev, manager);\r\n    expect(calls.length).toBe(2);\r\n    for (const req of calls as any[]) {\r\n      expect(req.taskType).toBe('timeline');\r\n      expect(typeof req.sceneText).toBe('string');\r\n    }\r\n  });\r\n\r\n  it('character detector single-run when not critical', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const det = new CharacterDetector();\r\n\r\n    const scene = buildScene({ text: 'Eve met Mallory. \"Sis,\" she said.' } as any);\r\n    const prev = buildPrev(2);\r\n\r\n    await det.detect(scene, prev, manager);\r\n    // Could be 0 or 1 depending on targets; we assert at most one (no consensus)\r\n    expect(calls.length).toBeLessThanOrEqual(1);\r\n    if (calls.length === 1) {\r\n      const req = calls[0] as any;\r\n      expect(req.taskType).toBe('character');\r\n    }\r\n  });\r\n\r\n  it('plot/engagement detectors set proper taskType and pass enriched meta', async () => {\r\n    const callsPlot: AnalyzeReq[] = [];\r\n    const callsEng: AnalyzeReq[] = [];\r\n    const managerPlot = makeManagerStub(callsPlot);\r\n    const managerEng = makeManagerStub(callsEng);\r\n\r\n    const plot = new PlotContextDetector();\r\n    const engage = new EngagementDetector();\r\n\r\n    const scenePlot = buildScene({ text: 'The incident shocked the town. What happened would change everything.' } as any);\r\n    const sceneEng = buildScene({ text: 'It was the best of times, it was the worst of times. Dialogue starts. \"Hello.\"' } as any);\r\n\r\n    await plot.detect(scenePlot, buildPrev(2), managerPlot);\r\n    await engage.detect(sceneEng, buildPrev(1), managerEng);\r\n\r\n    if (callsPlot.length > 0) {\r\n      expect((callsPlot[0] as any).taskType).toBe('plot');\r\n      expect(typeof (callsPlot[0] as any).sceneText).toBe('string');\r\n    }\r\n    if (callsEng.length > 0) {\r\n      expect((callsEng[0] as any).taskType).toBe('engagement');\r\n      expect(typeof (callsEng[0] as any).sceneText).toBe('string');\r\n    }\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\AnalysisProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\IssueHighlighter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\IssueItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SEVERITY_ORDER' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport type { ContinuityIssue } from '../../../../shared/types';\r\n\r\nexport interface IssueItemProps {\r\n  issue: ContinuityIssue;\r\n  sceneId: string;\r\n  sceneTitle?: string;\r\n  scenePosition?: number;\r\n  onShowInScene?: (issue: ContinuityIssue, sceneId: string) => void;\r\n  onDismiss?: (issue: ContinuityIssue, sceneId: string) => void;\r\n  className?: string;\r\n}\r\n\r\nconst SEVERITY_ORDER: Record<'must-fix' | 'should-fix' | 'consider', number> = {\r\n  'must-fix': 3,\r\n  'should-fix': 2,\r\n  'consider': 1,\r\n} as const;\r\n\r\nconst SEVERITY_LABEL: Record<'must-fix' | 'should-fix' | 'consider', string> = {\r\n  'must-fix': 'MUST FIX',\r\n  'should-fix': 'SHOULD FIX',\r\n  'consider': 'CONSIDER',\r\n} as const;\r\n\r\nconst SEVERITY_CLASS: Record<'must-fix' | 'should-fix' | 'consider', string> = {\r\n  'must-fix': 'bg-red-500/20 text-red-700 dark:text-red-200 border border-red-500/30',\r\n  'should-fix': 'bg-amber-500/20 text-amber-800 dark:text-amber-200 border border-amber-500/30',\r\n  'consider': 'bg-blue-500/20 text-blue-700 dark:text-blue-200 border border-blue-500/30',\r\n} as const;\r\n\r\ntype IssueKind = 'pronoun' | 'timeline' | 'character' | 'plot' | 'engagement' | 'context';\r\n\r\nconst TYPE_ICON: Record<IssueKind, string> = {\r\n  pronoun: '',\r\n  timeline: '',\r\n  character: '',\r\n  plot: '',\r\n  engagement: '',\r\n  context: '', // treat unknown/context like plot for display\r\n} as const;\r\n\r\nconst TYPE_LABEL: Record<IssueKind, string> = {\r\n  pronoun: 'pronoun',\r\n  timeline: 'timeline',\r\n  character: 'character',\r\n  plot: 'plot',\r\n  engagement: 'engagement',\r\n  context: 'context',\r\n} as const;\r\n\r\nfunction IssueItem(props: IssueItemProps) {\r\n  const { issue, sceneId, sceneTitle, scenePosition, onShowInScene, onDismiss, className } = props;\r\n\r\n  const severity: 'must-fix' | 'should-fix' | 'consider' =\r\n    (issue.severity as 'must-fix' | 'should-fix' | 'consider') ?? 'should-fix';\r\n\r\n  const typeKey: IssueKind =\r\n    (['pronoun', 'timeline', 'character', 'plot', 'engagement', 'context'] as IssueKind[]).includes(\r\n      issue.type as IssueKind\r\n    )\r\n      ? (issue.type as IssueKind)\r\n      : 'plot';\r\n\r\n  const icon = TYPE_ICON[typeKey];\r\n  const typeLabel = TYPE_LABEL[typeKey];\r\n\r\n  const handleShow = () => {\r\n    if (onShowInScene) onShowInScene(issue, sceneId);\r\n  };\r\n\r\n  const handleDismiss = () => {\r\n    if (onDismiss) onDismiss(issue, sceneId);\r\n  };\r\n\r\n  // Build context line exactly as specified, while avoiding awkward double spaces\r\n  const positionText = scenePosition != null ? String(scenePosition) : '';\r\n  const titleText = sceneTitle ?? sceneId;\r\n  const contextLine = `Scene ${positionText}: ${titleText} (moved)`;\r\n\r\n  return (\r\n    <div\r\n      className={[\r\n        'w-full rounded-md border border-gray-200 dark:border-gray-700 bg-white/60 dark:bg-gray-900/40 p-3 shadow-sm',\r\n        className,\r\n      ]\r\n        .filter(Boolean)\r\n        .join(' ')}\r\n      data-severity={severity}\r\n      data-type={typeLabel}\r\n      aria-label={`Issue ${typeLabel} ${SEVERITY_LABEL[severity]}`}\r\n    >\r\n      <div className=\"flex items-start justify-between gap-2\">\r\n        <div className=\"flex items-center gap-2\">\r\n          <span className=\"text-base\" aria-hidden=\"true\">{icon}</span>\r\n          <span className={['text-[10px] leading-4 px-2 py-0.5 rounded-full uppercase tracking-wide font-semibold', SEVERITY_CLASS[severity]].join(' ')}>\r\n            {SEVERITY_LABEL[severity]}\r\n          </span>\r\n        </div>\r\n\r\n        <div className=\"flex items-center gap-2\">\r\n          {onShowInScene ? (\r\n            <button\r\n              type=\"button\"\r\n              onClick={handleShow}\r\n              className=\"text-xs px-2 py-1 rounded border border-indigo-300 dark:border-indigo-700 text-indigo-700 dark:text-indigo-200 hover:bg-indigo-50 dark:hover:bg-indigo-900/40 transition\"\r\n            >\r\n              Show in Scene\r\n            </button>\r\n          ) : null}\r\n          {onDismiss ? (\r\n            <button\r\n              type=\"button\"\r\n              onClick={handleDismiss}\r\n              className=\"text-xs px-2 py-1 rounded border border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-800 transition\"\r\n            >\r\n              Dismiss\r\n            </button>\r\n          ) : null}\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"mt-2 text-sm text-gray-900 dark:text-gray-100\">\r\n        <div className=\"font-medium\">{typeLabel}</div>\r\n        <div className=\"mt-1\">{issue.description}</div>\r\n        {issue.suggestedFix ? (\r\n          <div className=\"mt-1 text-gray-700 dark:text-gray-300\">\r\n            <span className=\"font-medium\">Fix:</span> {issue.suggestedFix}\r\n          </div>\r\n        ) : null}\r\n        <div className=\"mt-2 text-xs text-gray-600 dark:text-gray-400\">{contextLine}</div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default React.memo(IssueItem);","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\IssuePanel.tsx","messages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useManuscriptStore\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":33,"column":22,"nodeType":"Identifier","endLine":33,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useAnalysis\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":44,"column":7,"nodeType":"Identifier","endLine":44,"endColumn":18},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":47,"column":23,"nodeType":"Identifier","endLine":47,"endColumn":30},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":52,"column":25,"nodeType":"Identifier","endLine":52,"endColumn":32},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":55,"column":18,"nodeType":"Identifier","endLine":55,"endColumn":25},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":58,"column":22,"nodeType":"Identifier","endLine":58,"endColumn":29},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":76,"column":31,"nodeType":"Identifier","endLine":76,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":81,"column":24,"nodeType":"Identifier","endLine":81,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":88,"column":25,"nodeType":"Identifier","endLine":88,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":92,"column":29,"nodeType":"Identifier","endLine":92,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":99,"column":30,"nodeType":"Identifier","endLine":99,"endColumn":41}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo } from 'react';\r\nimport type { ContinuityIssue } from '../../../../shared/types';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useAnalysis from '../hooks/useAnalysis';\r\nimport AnalysisProgress from './AnalysisProgress';\r\nimport IssueItem from './IssueItem';\r\n\r\nexport interface IssuePanelProps {\r\n  isOpen?: boolean;\r\n  onClose?: () => void;\r\n  className?: string;\r\n  onShowInScene?: (sceneId: string, issue: ContinuityIssue) => void;\r\n}\r\n\r\ntype IssueKind = 'pronoun' | 'timeline' | 'character' | 'plot' | 'engagement';\r\n\r\nconst TYPE_LABELS: Record<IssueKind, string> = {\r\n  pronoun: 'Pronoun',\r\n  timeline: 'Timeline',\r\n  character: 'Character',\r\n  plot: 'Plot',\r\n  engagement: 'Engagement',\r\n} as const;\r\n\r\nfunction IssuePanel(props: IssuePanelProps) {\r\n  const { isOpen = true, onClose, className, onShowInScene } = props;\r\n\r\n  // Collapsed placeholder (parent manages layout space)\r\n  if (isOpen === false) {\r\n    return <div className={className} />;\r\n  }\r\n\r\n  const manuscript = useManuscriptStore((s) => s.manuscript);\r\n\r\n  const {\r\n    analyzeMovedScenes,\r\n    getSceneIssues,\r\n    getIssueCountsByType,\r\n    clearIssues,\r\n    toggleIssueType,\r\n    isAnalyzing,\r\n    progress,\r\n    selectedIssueTypes,\r\n  } = useAnalysis();\r\n\r\n  // Moved scenes (ids and map for context)\r\n  const movedScenes = useMemo(() => {\r\n    const scenes = manuscript?.scenes ?? [];\r\n    return scenes.filter((s) => s.hasBeenMoved === true);\r\n  }, [manuscript]);\r\n\r\n  const movedSceneIds = useMemo(() => movedScenes.map((s) => s.id), [movedScenes]);\r\n\r\n  // Counts by type (respects selectedIssueTypes inside hook implementation)\r\n  const counts = useMemo(() => getIssueCountsByType(movedSceneIds), [getIssueCountsByType, movedSceneIds]);\r\n\r\n  // Flat list of issues across moved scenes (grouping optional per subtask; provide scene metadata to items)\r\n  const flatIssues = useMemo(() => {\r\n    const items: Array<{ sceneId: string; issue: ContinuityIssue; sceneTitle?: string; scenePosition?: number }> = [];\r\n    for (const scene of movedScenes) {\r\n      const sceneIssues = getSceneIssues(scene.id);\r\n      if (!sceneIssues || sceneIssues.length === 0) continue;\r\n      for (const issue of sceneIssues) {\r\n        items.push({\r\n          sceneId: scene.id,\r\n          issue,\r\n          // Title/name may not exist on Scene type; fall back to id. Position is available.\r\n          sceneTitle: (scene as unknown as { title?: string; name?: string }).title ?? (scene as unknown as { title?: string; name?: string }).name ?? scene.id,\r\n          scenePosition: scene.position,\r\n        });\r\n      }\r\n    }\r\n    return items;\r\n  }, [movedScenes, getSceneIssues]);\r\n\r\n  const totalFilteredIssues = useMemo(\r\n    () => Object.values(counts).reduce((acc, n) => acc + n, 0),\r\n    [counts]\r\n  );\r\n\r\n  const handleToggle = useCallback(\r\n    (type: IssueKind) => {\r\n      toggleIssueType(type);\r\n    },\r\n    [toggleIssueType]\r\n  );\r\n\r\n  const handleAnalyze = useCallback(() => {\r\n    void analyzeMovedScenes();\r\n  }, [analyzeMovedScenes]);\r\n\r\n  const handleShowInScene = useCallback(\r\n    (issue: ContinuityIssue, sceneId: string) => {\r\n      if (onShowInScene) onShowInScene(sceneId, issue);\r\n    },\r\n    [onShowInScene]\r\n  );\r\n\r\n  const handleDismissIssue = useCallback(\r\n    (issue: ContinuityIssue, sceneId: string) => {\r\n      // Subtask scope: simple dismissal clears all issues for the scene.\r\n      clearIssues(sceneId);\r\n    },\r\n    [clearIssues]\r\n  );\r\n\r\n  const Pill = ({ type }: { type: IssueKind }) => {\r\n    const active = selectedIssueTypes.has(type);\r\n    const count = counts[type] ?? 0;\r\n    return (\r\n      <button\r\n        type=\"button\"\r\n        onClick={() => handleToggle(type)}\r\n        className={[\r\n          'text-xs px-2 py-1 rounded-full border transition',\r\n          active\r\n            ? 'bg-indigo-600 text-white border-indigo-600'\r\n            : 'bg-white/60 dark:bg-gray-900/40 text-gray-800 dark:text-gray-200 border-gray-300 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800',\r\n        ].join(' ')}\r\n        aria-pressed={active}\r\n        aria-label={`${TYPE_LABELS[type]} issues`}\r\n      >\r\n        <span>{TYPE_LABELS[type]}</span>\r\n        <span\r\n          className={[\r\n            'ml-2 inline-flex items-center justify-center min-w-[1.25rem] h-5 px-1 rounded-full',\r\n            active ? 'bg-white/20 text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200',\r\n          ].join(' ')}\r\n        >\r\n          {count}\r\n        </span>\r\n      </button>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div className={['w-full rounded-lg border border-gray-200 dark:border-gray-700 bg-white/70 dark:bg-gray-900/40', className].filter(Boolean).join(' ')}>\r\n      {/* Header */}\r\n      <div className=\"flex items-center justify-between p-3 border-b border-gray-200 dark:border-gray-700\">\r\n        <div className=\"flex items-center gap-2\">\r\n          <h2 className=\"text-sm font-semibold text-gray-900 dark:text-gray-100\">Issues Found in Moved Scenes</h2>\r\n        </div>\r\n        <div className=\"flex items-center gap-2\">\r\n          <button\r\n            type=\"button\"\r\n            onClick={handleAnalyze}\r\n            className=\"text-xs px-3 py-1.5 rounded-md bg-indigo-600 text-white hover:bg-indigo-700 transition\"\r\n          >\r\n            Analyze Moved Scenes\r\n          </button>\r\n          {onClose ? (\r\n            <button\r\n              type=\"button\"\r\n              onClick={onClose}\r\n              className=\"text-xs px-2 py-1 rounded-md border border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-800\"\r\n              aria-label=\"Close issues panel\"\r\n              title=\"Close\"\r\n            >\r\n              \r\n            </button>\r\n          ) : null}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Progress */}\r\n      <div className=\"p-3\">\r\n        <AnalysisProgress isAnalyzing={isAnalyzing} progress={progress} />\r\n      </div>\r\n\r\n      {/* Filters */}\r\n      <div className=\"px-3 pb-2\">\r\n        <div className=\"flex flex-wrap gap-2\">\r\n          {(['pronoun', 'timeline', 'character', 'plot', 'engagement'] as IssueKind[]).map((t) => (\r\n            <Pill key={t} type={t} />\r\n          ))}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Body */}\r\n      <div className=\"p-3\">\r\n        {totalFilteredIssues === 0 && !isAnalyzing && progress?.total > 0 ? (\r\n          <div className=\"text-sm text-gray-600 dark:text-gray-300\">No issues found in moved scenes</div>\r\n        ) : (\r\n          <div className=\"flex flex-col gap-3\">\r\n            {flatIssues.map(({ sceneId, issue, sceneTitle, scenePosition }) => (\r\n              <IssueItem\r\n                key={`${sceneId}-${issue.type}-${issue.textSpan?.[0] ?? 0}-${issue.textSpan?.[1] ?? 0}-${issue.description}`}\r\n                issue={issue}\r\n                sceneId={sceneId}\r\n                sceneTitle={sceneTitle}\r\n                scenePosition={scenePosition}\r\n                onShowInScene={handleShowInScene}\r\n                onDismiss={handleDismissIssue}\r\n              />\r\n            ))}\r\n            {flatIssues.length === 0 && isAnalyzing ? (\r\n              <div className=\"text-sm text-gray-600 dark:text-gray-300\">Analyzing moved scenes</div>\r\n            ) : null}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default IssuePanel;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\BaseDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3761,3764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3761,3764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3860,3863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3860,3863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\n\r\n/**\r\n * Local detection result from a specific detector before optional AI enrichment.\r\n */\r\nexport interface LocalDetectionResult<T = unknown> {\r\n  issues: ContinuityIssue[];\r\n  requiresAI: boolean;\r\n  targets: readonly T[];\r\n  stats?: Record<string, number>;\r\n}\r\n\r\n/**\r\n * Abstract base class for all continuity detectors.\r\n * Handles orchestration between local (rule/NLP) pass and optional AI pass.\r\n */\r\nexport default abstract class BaseDetector<TTarget = unknown> {\r\n  public abstract readonly detectorType:\r\n    | 'pronoun'\r\n    | 'timeline'\r\n    | 'character'\r\n    | 'plot'\r\n    | 'engagement';\r\n\r\n  /**\r\n   * Run detection for a scene, optionally enriching with AI if requested by local pass.\r\n   * Robust to AI failures: returns at least local issues.\r\n   */\r\n  public async detect(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager\r\n  ): Promise<ContinuityIssue[]> {\r\n    try {\r\n      const local = await this.localDetection(scene, previousScenes, aiManager);\r\n      const baseIssues = Array.isArray(local.issues) ? local.issues : [];\r\n      if (!local.requiresAI) {\r\n        console.debug(`[${this.constructor.name}] Local-only detection complete: ${baseIssues.length} issue(s).`);\r\n        return baseIssues;\r\n      }\r\n\r\n      try {\r\n        const aiIssues = await this.aiDetection(scene, previousScenes, aiManager, local.targets ?? []);\r\n        const merged = this.mergeResults(baseIssues, aiIssues);\r\n        console.debug(\r\n          `[${this.constructor.name}] AI-enriched detection complete: local=${baseIssues.length}, ai=${aiIssues.length}, merged=${merged.length}`\r\n        );\r\n        return merged;\r\n      } catch (aiErr) {\r\n        console.debug(`[${this.constructor.name}] AI enrichment failed; returning local issues only.`, aiErr);\r\n        return baseIssues;\r\n      }\r\n    } catch (err) {\r\n      console.debug(`[${this.constructor.name}] Local detection failed; returning empty list.`, err);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implement local (non-AI) pass using heuristics, regex, or lightweight NLP.\r\n   * Should be fast and side-effect-free.\r\n   */\r\n  protected abstract localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<TTarget>>;\r\n\r\n  /**\r\n   * Optional AI enrichment step, only called if localDetection.requiresAI === true.\r\n   * May consult the AIServiceManager to analyze detection targets and produce additional issues.\r\n   */\r\n  protected abstract aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly TTarget[]\r\n  ): Promise<ContinuityIssue[]>;\r\n\r\n  /**\r\n   * Merge and de-duplicate issues. Default strategy: concat and de-dupe by (type, start, end, description).\r\n   */\r\n  protected mergeResults(baseIssues: readonly ContinuityIssue[], aiIssues: readonly ContinuityIssue[]): ContinuityIssue[] {\r\n    const out: ContinuityIssue[] = [];\r\n    const seen = new Set<string>();\r\n\r\n    const add = (it: ContinuityIssue): void => {\r\n      const [start, end] = it.textSpan ?? [NaN, NaN];\r\n      const key = `${it.type}|${start}|${end}|${it.description}`;\r\n      if (!seen.has(key)) {\r\n        seen.add(key);\r\n        out.push(it);\r\n      }\r\n    };\r\n\r\n    for (const i of baseIssues) add(i);\r\n    for (const i of aiIssues) add(i);\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Lazy, safe loader for compromise NLP. Returns null on failure.\r\n   * Not used yet by default implementations but provided for subclasses.\r\n   */\r\n  protected async safeNLP(text: string): Promise<any | null> {\r\n    try {\r\n      const mod = await import('compromise');\r\n      const nlp = (mod as any).default ?? mod;\r\n      return typeof nlp === 'function' ? nlp(text) : null;\r\n    } catch (err) {\r\n      console.debug(`[${this.constructor.name}] safeNLP failed to load compromise`, err);\r\n      return null;\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\CharacterDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8978,8981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8978,8981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'assessFirstAppearanceIssues' is defined but never used. Allowed unused vars must match /^_/u.","line":380,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":380,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'assessRelationshipAssumptions' is defined but never used. Allowed unused vars must match /^_/u.","line":404,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":404,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'assessPronounBeforeNaming' is defined but never used. Allowed unused vars must match /^_/u.","line":435,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":435,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":584,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":584,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23007,23010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23007,23010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":587,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":587,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23112,23115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23112,23115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":591,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":591,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23332,23335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23332,23335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":592,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":592,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23379,23382],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23379,23382],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\n/**\r\n * Character continuity detector (Detector 2 - Phase 2):\r\n * - Local NLP via compromise (safe) + regex fallback\r\n * - Previous character registry caching and alias handling\r\n * - Immediate local issues for missing/weak intros and relationship assumptions\r\n * - Selective AI validation (analysisType \"consistency\") for adequacy/ambiguity\r\n */\r\n\r\n// ---------- Internal & exported types ----------\r\nexport interface NameOccurrence {\r\n  name: string;\r\n  start: number;\r\n  end: number;\r\n  sentenceIndex: number;\r\n  isFull: boolean;\r\n  isFirstOnly: boolean;\r\n  hasApposition: boolean;\r\n  nickname?: string;\r\n}\r\n\r\nexport interface PreviousRegistry {\r\n  canonical: Set<string>;\r\n  aliases: Map<string, Set<string>>; // key: canonical, value: alias set\r\n}\r\n\r\nexport interface CharacterDetectionTarget {\r\n  characterName: string;\r\n  aliasNames: string[];\r\n  firstOccurrence: [number, number];\r\n  sentenceText: string;\r\n  context: string;\r\n  prevRegistry: { canonical: string[]; aliases: string[] };\r\n  relationshipTerms: string[];\r\n  sentenceIndex: number;\r\n}\r\n\r\n// ---------- Module state ----------\r\nconst registryCache: Map<string, PreviousRegistry> = new Map();\r\n\r\n// ---------- Small utilities (kept <= 40 lines) ----------\r\nfunction escapeRegExp(s: string): string {\r\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n\r\nfunction signature(previous: readonly Scene[]): string {\r\n  return previous.map(s => s.id).join('|');\r\n}\r\n\r\nfunction splitSentences(text: string): { text: string; start: number; end: number }[] {\r\n  const out: { text: string; start: number; end: number }[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      const seg = text.slice(m.index, m.index + m[0].length);\r\n      out.push({ text: seg.trim(), start: m.index, end: m.index + m[0].length });\r\n    }\r\n  } catch {/* noop */}\r\n  if (out.length === 0) out.push({ text, start: 0, end: text.length });\r\n  return out;\r\n}\r\n\r\nfunction toLowerSet(iter: Iterable<string>): Set<string> {\r\n  const s = new Set<string>();\r\n  for (const v of iter) s.add(v.toLowerCase());\r\n  return s;\r\n}\r\n\r\nfunction appositionAfter(text: string, end: number): boolean {\r\n  const seg = text.slice(end, Math.min(text.length, end + 40));\r\n  return /(,\\s*(the|a|an)\\s+[a-z-]{2,})|(\\s+who\\s+)/i.test(seg);\r\n}\r\n\r\nfunction contextSnippet(text: string, start: number, end: number, radius = 120): string {\r\n  const s = Math.max(0, start - radius);\r\n  const e = Math.min(text.length, end + radius);\r\n  return text.slice(s, e).trim();\r\n}\r\n\r\nfunction flattenAliases(reg: PreviousRegistry): Set<string> {\r\n  const flat = new Set<string>();\r\n  for (const set of reg.aliases.values()) for (const a of set) flat.add(a);\r\n  return flat;\r\n}\r\n\r\nfunction firstLastTokens(full: string): { first?: string; last?: string } {\r\n  const parts = full.split(/\\s+/).filter(Boolean);\r\n  return { first: parts[0], last: parts.length > 1 ? parts[parts.length - 1] : undefined };\r\n}\r\n\r\nfunction titleStripped(name: string): string {\r\n  return name.replace(/\\b(?:Dr|Mr|Mrs|Ms|Miss)\\.\\s*/g, '').trim();\r\n}\r\n\r\nconst REL_TERMS = [\r\n  'as usual','like before','as she told him','as he told her','back at it','you know',\r\n  'sis','bro','honey','dear','sweetie','buddy','pal'\r\n];\r\n\r\nconst PRONOUNS = ['he','she','him','her','his','hers','they','them','their','theirs'];\r\n\r\nconst NAME_FALLBACK_RE = /\\b(?:Dr|Mr|Mrs|Ms|Miss)\\.\\s+[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?|\\b([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?)\\b/g;\r\n\r\nconst NAME_STOP = new Set([\r\n  'The','A','An','And','But','Or','If','Then','When','While','After','Before',\r\n  'Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday',\r\n  'January','February','March','April','May','June','July','August','September','October','November','December'\r\n]);\r\n\r\n// ---------- Required exports (testing hooks) ----------\r\nexport function buildPreviousRegistry(previousScenes: readonly Scene[]): PreviousRegistry {\r\n  const canonical = new Set<string>();\r\n  const aliases = new Map<string, Set<string>>();\r\n  const addAlias = (canon: string, a: string | undefined) => {\r\n    if (!a) return;\r\n    const key = canon;\r\n    const set = aliases.get(key) ?? new Set<string>();\r\n    set.add(a);\r\n    aliases.set(key, set);\r\n  };\r\n\r\n  for (const sc of previousScenes) {\r\n    let m: RegExpExecArray | null;\r\n    const text = sc.text ?? '';\r\n    while ((m = NAME_FALLBACK_RE.exec(text)) !== null) {\r\n      const raw = m[0].trim();\r\n      const nm = raw;\r\n      if (!nm) continue;\r\n      const stripped = titleStripped(nm);\r\n      const tok0 = stripped.split(/\\s+/)[0];\r\n      if (!tok0 || NAME_STOP.has(tok0)) continue;\r\n      canonical.add(stripped);\r\n      const { first, last } = firstLastTokens(stripped);\r\n      addAlias(stripped, first);\r\n      addAlias(stripped, last);\r\n    }\r\n    // nickname patterns: First \"Nick\" Last OR First (Nick) Last\r\n    const nickRe = /\\b([A-Z][a-z]+)\\s+(?:\"([^\"]+)\"|\\(([^)]+)\\))\\s+([A-Z][a-z]+)\\b/g;\r\n    let nm: RegExpExecArray | null;\r\n    while ((nm = nickRe.exec(text)) !== null) {\r\n      const canon = `${nm[1]} ${nm[4]}`;\r\n      canonical.add(canon);\r\n      const nick = (nm[2] ?? nm[3] ?? '').trim();\r\n      if (nick) addAlias(canon, nick);\r\n      addAlias(canon, nm[1]);\r\n      addAlias(canon, nm[4]);\r\n    }\r\n  }\r\n  return { canonical, aliases };\r\n}\r\n\r\nexport function extractSceneNames(sceneText: string): NameOccurrence[] {\r\n  const sentences = splitSentences(sceneText);\r\n  const seen = new Set<string>();\r\n  const out: NameOccurrence[] = [];\r\n  let m: RegExpExecArray | null;\r\n  while ((m = NAME_FALLBACK_RE.exec(sceneText)) !== null) {\r\n    const raw = m[0].trim();\r\n    const nm = raw;\r\n    if (!nm) continue;\r\n    const stripped = titleStripped(nm);\r\n    const tok0 = stripped.split(/\\s+/)[0];\r\n    if (!tok0 || NAME_STOP.has(tok0)) continue;\r\n    if (seen.has(stripped)) continue;\r\n    seen.add(stripped);\r\n    const start = m.index;\r\n    const end = start + m[0].length;\r\n    let si = sentences.findIndex(s => start >= s.start && start < s.end);\r\n    if (si < 0) si = 0;\r\n    const isFull = /\\s/.test(stripped);\r\n    const isFirstOnly = !isFull;\r\n    out.push({ name: stripped, start, end, sentenceIndex: si, isFull, isFirstOnly, hasApposition: appositionAfter(sceneText, end) });\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function findFirstMentionOffsets(name: string, sceneText: string, fromIndex?: number): [number, number] {\r\n  const nm = escapeRegExp(name);\r\n  const re = new RegExp(`\\\\b${nm}\\\\b`);\r\n  const idx = re.exec(sceneText.slice(fromIndex ?? 0))?.index;\r\n  if (idx === undefined) return [-1, -1];\r\n  const start = (fromIndex ?? 0) + idx;\r\n  return [start, start + name.length];\r\n}\r\n\r\nexport function detectRelationshipTerms(sentenceText: string): string[] {\r\n  const low = sentenceText.toLowerCase();\r\n  const found: string[] = [];\r\n  for (const t of REL_TERMS) {\r\n    if (low.includes(t)) found.push(t);\r\n  }\r\n  return found;\r\n}\r\n\r\nexport function prepareDetectionTargets(\r\n  names: readonly NameOccurrence[],\r\n  sceneText: string,\r\n  sentences: readonly { text: string; start: number; end: number }[],\r\n  reg: PreviousRegistry\r\n): CharacterDetectionTarget[] {\r\n  const cset = toLowerSet(reg.canonical);\r\n  const aset = toLowerSet(flattenAliases(reg));\r\n  const targets: CharacterDetectionTarget[] = [];\r\n  for (const n of names) {\r\n    const low = n.name.toLowerCase();\r\n    const known = n.isFull ? cset.has(low) : aset.has(low);\r\n    if (!known && (n.isFirstOnly || n.nickname) && !n.hasApposition) {\r\n      const sent = sentences[n.sentenceIndex]?.text ?? '';\r\n      targets.push({\r\n        characterName: n.name,\r\n        aliasNames: Array.from(new Set([firstLastTokens(n.name).first, firstLastTokens(n.name).last, n.nickname].filter(Boolean) as string[])),\r\n        firstOccurrence: [n.start, n.end],\r\n        sentenceText: sent,\r\n        context: contextSnippet(sceneText, n.start, n.end),\r\n        prevRegistry: {\r\n          canonical: Array.from(reg.canonical).slice(0, 6),\r\n          aliases: Array.from(flattenAliases(reg)).slice(0, 6),\r\n        },\r\n        relationshipTerms: detectRelationshipTerms(sent),\r\n        sentenceIndex: n.sentenceIndex,\r\n      });\r\n    }\r\n  }\r\n  return targets;\r\n}\r\n\r\n// ---------- Internal helpers for local analysis ----------\r\nfunction getOrBuildRegistry(previous: readonly Scene[]): PreviousRegistry {\r\n  const sig = signature(previous);\r\n  const cached = registryCache.get(sig);\r\n  if (cached) return cached;\r\n  const reg = buildPreviousRegistry(previous);\r\n  registryCache.set(sig, reg);\r\n  return reg;\r\n}\r\n\r\nfunction compileCurrentNamesWithCompromise(sceneText: string, doc: any | null): NameOccurrence[] {\r\n  if (!doc || typeof doc.people !== 'function') return extractSceneNames(sceneText);\r\n  try {\r\n    const arr: string[] = doc.people().out('array') ?? [];\r\n    const uniq = Array.from(new Set(arr.filter(s => s && typeof s === 'string').map(s => s.trim()).filter(Boolean)));\r\n    const sentences = splitSentences(sceneText);\r\n    const out: NameOccurrence[] = [];\r\n    for (const nm of uniq) {\r\n      const [start, end] = findFirstMentionOffsets(nm, sceneText);\r\n      if (start < 0) continue;\r\n      let si = sentences.findIndex(s => start >= s.start && start < s.end);\r\n      if (si < 0) si = 0;\r\n      const stripped = titleStripped(nm);\r\n      const isFull = /\\s/.test(stripped);\r\n      out.push({\r\n        name: stripped,\r\n        start,\r\n        end,\r\n        sentenceIndex: si,\r\n        isFull,\r\n        isFirstOnly: !isFull,\r\n        hasApposition: appositionAfter(sceneText, end),\r\n      });\r\n    }\r\n    return out.length ? out : extractSceneNames(sceneText);\r\n  } catch {\r\n    return extractSceneNames(sceneText);\r\n  }\r\n}\r\n\r\nfunction prevTextContainsRelation(previous: readonly Scene[], name: string, term: string): boolean {\r\n  const hay = previous.map(s => s.text || '').join('\\n').toLowerCase();\r\n  return hay.includes(name.toLowerCase()) && hay.includes(term.toLowerCase());\r\n}\r\n\r\nfunction findOpeningPronouns(sceneText: string, sentences: readonly { start: number; end: number }[], maxSentence = 2) {\r\n  const limitEnd = sentences[Math.min(maxSentence - 1, sentences.length - 1)]?.end ?? Math.min(sceneText.length, 240);\r\n  const text = sceneText.slice(0, limitEnd);\r\n  const re = new RegExp(`\\\\b(${PRONOUNS.join('|')})\\\\b`, 'gi');\r\n  const list: { pronoun: string; start: number; end: number }[] = [];\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text)) !== null) {\r\n    const s = m.index;\r\n    list.push({ pronoun: m[0].toLowerCase(), start: s, end: s + m[0].length });\r\n  }\r\n  return list;\r\n}\r\n\r\n// ---------- AI request/response helpers ----------\r\nfunction buildReaderContext(names: readonly string[]): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(names),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\nfunction registryKnownNames(reg: PreviousRegistry): string[] {\r\n  return Array.from(reg.canonical);\r\n}\r\n\r\nfunction buildAIHeader(scene: Scene, targets: readonly CharacterDetectionTarget[], reg: PreviousRegistry): string {\r\n  const lines: string[] = [];\r\n  lines.push('[[Character detection targets]]');\r\n  lines.push(`scene: id=${scene.id} pos=${scene.position}`);\r\n  const chosen = targets.slice(0, 8);\r\n  for (const c of chosen) {\r\n    const sent = (c.sentenceText || '').slice(0, 140).replace(/\\n+/g, ' ');\r\n    const aliases = c.aliasNames.slice(0, 4).join(', ') || 'none';\r\n    const rel = c.relationshipTerms.slice(0, 4).join(', ') || 'none';\r\n    lines.push(`- name=\"${c.characterName}\" span=[${c.firstOccurrence[0]},${c.firstOccurrence[1]}] sent=\"${sent}\" aliases=[${aliases}] rel=[${rel}]`);\r\n  }\r\n  lines.push('[[Previous registry summary]]');\r\n  lines.push(`canonical: ${Array.from(reg.canonical).slice(0, 8).join(' | ')}`);\r\n  lines.push(`aliases: ${Array.from(flattenAliases(reg)).slice(0, 10).join(' | ')}`);\r\n  lines.push('[[Scene excerpt]]');\r\n  return lines.join('\\n');\r\n}\r\n\r\nfunction buildSceneExcerpt(text: string, targets: readonly CharacterDetectionTarget[], maxLen = 1200): string {\r\n  if (!targets.length) return text.slice(0, maxLen);\r\n  const snippets: string[] = [];\r\n  const used: [number, number][] = [];\r\n  for (const c of targets) {\r\n    const [s, e] = c.firstOccurrence;\r\n    const snip = contextSnippet(text, s, e, 220);\r\n    if (!snip) continue;\r\n    snippets.push(snip);\r\n    used.push([s, e]);\r\n    const len = snippets.join('\\n---\\n').length;\r\n    if (len > maxLen) break;\r\n  }\r\n  const out = snippets.join('\\n---\\n');\r\n  return out.slice(0, maxLen);\r\n}\r\n\r\nfunction mapAICharacterIssues(\r\n  resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n  sceneText: string,\r\n  targets: readonly CharacterDetectionTarget[]\r\n): ContinuityIssue[] {\r\n  const byName = new Map<string, CharacterDetectionTarget>();\r\n  for (const c of targets) byName.set(c.characterName.toLowerCase(), c);\r\n  const out: ContinuityIssue[] = [];\r\n  for (const it of resp?.issues ?? []) {\r\n    if ((it.type ?? 'character') !== 'character') continue;\r\n    const hasSpan = Array.isArray(it.textSpan) && Number.isFinite(it.textSpan[0]) && Number.isFinite(it.textSpan[1]);\r\n    if (hasSpan) {\r\n      out.push({\r\n        type: 'character',\r\n        severity: it.severity ?? 'should-fix',\r\n        description: it.description ?? 'Character introduction/relationship adequacy issue',\r\n        textSpan: it.textSpan as [number, number],\r\n        suggestedFix: it.suggestedFix,\r\n      });\r\n      continue;\r\n    }\r\n    // Fallback: attach to detection target first occurrence by name if present\r\n    const key = (it.description ?? '').toLowerCase();\r\n    let chosen = null as CharacterDetectionTarget | null;\r\n    for (const [nm, c] of byName) {\r\n      if (key.includes(nm)) { chosen = c; break; }\r\n    }\r\n    chosen ??= targets[0] ?? null;\r\n    const span: [number, number] = chosen ? chosen.firstOccurrence : [0, Math.min(1, sceneText.length)];\r\n    out.push({\r\n      type: 'character',\r\n      severity: it.severity ?? 'should-fix',\r\n      description: it.description ?? `Character adequacy issue: ${chosen?.characterName ?? 'unknown'}`,\r\n      textSpan: span,\r\n      suggestedFix: it.suggestedFix,\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\n// ---------- Local assessment helpers (<= 40 lines each) ----------\r\nfunction assessFirstAppearanceIssues(\r\n  currentNames: readonly NameOccurrence[],\r\n  reg: PreviousRegistry\r\n): { issues: ContinuityIssue[]; unknownFirstMentions: number } {\r\n  const issues: ContinuityIssue[] = [];\r\n  let count = 0;\r\n  const canSet = toLowerSet(reg.canonical);\r\n  const aliSet = toLowerSet(flattenAliases(reg));\r\n  for (const n of currentNames) {\r\n    const low = n.name.toLowerCase();\r\n    const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n    if (!known && (n.isFirstOnly || n.nickname) && !n.hasApposition) {\r\n      count++;\r\n      issues.push({\r\n        type: 'character',\r\n        severity: n.sentenceIndex <= 1 ? 'must-fix' : 'should-fix',\r\n        description: `First mention \"${n.name}\" appears without introduction/background.`,\r\n        textSpan: [n.start, n.end],\r\n      });\r\n    }\r\n  }\r\n  return { issues, unknownFirstMentions: count };\r\n}\r\n\r\nfunction assessRelationshipAssumptions(\r\n  sentences: readonly { text: string; start: number; end: number }[],\r\n  currentNames: readonly NameOccurrence[],\r\n  previousScenes: readonly Scene[]\r\n): { issues: ContinuityIssue[]; relTermsFound: number } {\r\n  const issues: ContinuityIssue[] = [];\r\n  let relTermsFound = 0;\r\n  for (const sent of sentences) {\r\n    const terms = detectRelationshipTerms(sent.text);\r\n    if (!terms.length) continue;\r\n    const anyNameHere = currentNames.some(n => n.start >= sent.start && n.start < sent.end);\r\n    if (!anyNameHere) continue;\r\n    relTermsFound += terms.length;\r\n    const nameInSent = currentNames.find(n => n.start >= sent.start && n.start < sent.end)?.name;\r\n    const supported = nameInSent ? terms.some(t => prevTextContainsRelation(previousScenes, nameInSent, t)) : false;\r\n    if (!supported) {\r\n      const t0 = terms[0];\r\n      const off = sent.text.toLowerCase().indexOf(t0);\r\n      const begin = off >= 0 ? sent.start + off : sent.start;\r\n      const end = off >= 0 ? begin + t0.length : Math.min(sent.end, begin + 4);\r\n      issues.push({\r\n        type: 'character',\r\n        severity: 'should-fix',\r\n        description: `Relationship assumption \"${t0}\" with ${nameInSent ?? 'a character'} may lack prior support.`,\r\n        textSpan: [begin, end],\r\n      });\r\n    }\r\n  }\r\n  return { issues, relTermsFound };\r\n}\r\n\r\nfunction assessPronounBeforeNaming(\r\n  sceneText: string,\r\n  sentences: readonly { start: number; end: number }[],\r\n  currentNames: readonly NameOccurrence[],\r\n  reg: PreviousRegistry\r\n): ContinuityIssue[] {\r\n  const issues: ContinuityIssue[] = [];\r\n  const canSet = toLowerSet(reg.canonical);\r\n  const aliSet = toLowerSet(flattenAliases(reg));\r\n  const openingPronouns = findOpeningPronouns(sceneText, sentences, 2);\r\n  if (!openingPronouns.length) return issues;\r\n  const earliestUnknown = currentNames\r\n    .filter(n => {\r\n      const low = n.name.toLowerCase();\r\n      const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n      return !known;\r\n    })\r\n    .sort((a, b) => a.sentenceIndex - b.sentenceIndex)[0];\r\n  if (earliestUnknown && earliestUnknown.sentenceIndex >= 2) {\r\n    const p0 = openingPronouns[0];\r\n    issues.push({\r\n      type: 'character',\r\n      severity: 'should-fix',\r\n      description: `Early pronoun reference precedes first naming of a new character \"${earliestUnknown.name}\".`,\r\n      textSpan: [p0.start, p0.end],\r\n    });\r\n  }\r\n  return issues;\r\n}\r\n// ---------- Detector implementation ----------\r\nexport default class CharacterDetector extends BaseDetector<CharacterDetectionTarget> {\r\n  public readonly detectorType = 'character' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<CharacterDetectionTarget>> {\r\n    if (!scene?.text || typeof scene.text !== 'string' || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n\r\n    const doc = await this.safeNLP(scene.text);\r\n    const sentences = splitSentences(scene.text);\r\n    const currentNames = compileCurrentNamesWithCompromise(scene.text, doc);\r\n    const reg = getOrBuildRegistry(previousScenes);\r\n    const canSet = toLowerSet(reg.canonical);\r\n    const aliSet = toLowerSet(flattenAliases(reg));\r\n\r\n    let unknownFirstMentions = 0;\r\n    let relTermsFound = 0;\r\n    const issues: ContinuityIssue[] = [];\r\n\r\n    // First-appearance without intro\r\n    for (const n of currentNames) {\r\n      const low = n.name.toLowerCase();\r\n      const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n      if (!known && (n.isFirstOnly || n.nickname) && !n.hasApposition) {\r\n        unknownFirstMentions++;\r\n        const sev: ContinuityIssue['severity'] = n.sentenceIndex <= 1 ? 'must-fix' : 'should-fix';\r\n        issues.push({\r\n          type: 'character',\r\n          severity: sev,\r\n          description: `First mention \"${n.name}\" appears without introduction/background.`,\r\n          textSpan: [n.start, n.end],\r\n        });\r\n      }\r\n    }\r\n\r\n    // Relationship assumptions\r\n    for (const sent of sentences) {\r\n      const terms = detectRelationshipTerms(sent.text);\r\n      if (!terms.length) continue;\r\n      const anyNameHere = currentNames.some(n => n.start >= sent.start && n.start < sent.end);\r\n      if (!anyNameHere) continue;\r\n      relTermsFound += terms.length;\r\n      // If no evidence in previous scenes, flag should-fix\r\n      const nameInSent = currentNames.find(n => n.start >= sent.start && n.start < sent.end)?.name;\r\n      const supported = nameInSent ? terms.some(t => prevTextContainsRelation(previousScenes, nameInSent, t)) : false;\r\n      if (!supported) {\r\n        const t0 = terms[0];\r\n        const off = sent.text.toLowerCase().indexOf(t0);\r\n        const begin = off >= 0 ? sent.start + off : sent.start;\r\n        const end = off >= 0 ? begin + t0.length : Math.min(sent.end, begin + 4);\r\n        issues.push({\r\n          type: 'character',\r\n          severity: 'should-fix',\r\n          description: `Relationship assumption \"${t0}\" with ${nameInSent ?? 'a character'} may lack prior support.`,\r\n          textSpan: [begin, end],\r\n        });\r\n      }\r\n    }\r\n\r\n    // Pronouns before naming (approximate)\r\n    const openingPronouns = findOpeningPronouns(scene.text, sentences, 2);\r\n    if (openingPronouns.length) {\r\n      const earliestUnknown = currentNames\r\n        .filter(n => {\r\n          const low = n.name.toLowerCase();\r\n          const known = n.isFull ? canSet.has(low) : aliSet.has(low);\r\n          return !known;\r\n        })\r\n        .sort((a, b) => a.sentenceIndex - b.sentenceIndex)[0];\r\n      if (earliestUnknown && earliestUnknown.sentenceIndex >= 2) {\r\n        const p0 = openingPronouns[0];\r\n        issues.push({\r\n          type: 'character',\r\n          severity: 'should-fix',\r\n          description: `Early pronoun reference precedes first naming of a new character \"${earliestUnknown.name}\".`,\r\n          textSpan: [p0.start, p0.end],\r\n        });\r\n      }\r\n    }\r\n\r\n    const targets = prepareDetectionTargets(currentNames, scene.text, sentences, reg);\r\n    console.debug('[CharacterDetector] names:', currentNames.length, 'unknownFirst:', unknownFirstMentions, 'relTerms:', relTermsFound, 'targets:', targets.length);\r\n\r\n    return {\r\n      issues,\r\n      requiresAI: targets.length > 0,\r\n      targets,\r\n      stats: {\r\n        namesFound: currentNames.length,\r\n        unknownFirstMentions,\r\n        relTermsFound,\r\n        targets: targets.length,\r\n      },\r\n    };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly CharacterDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n    try {\r\n      const reg = getOrBuildRegistry(previousScenes);\r\n      const header = buildAIHeader(scene, targets, reg);\r\n      const excerpt = buildSceneExcerpt(scene.text, targets, 1200);\r\n      const lastPrev = previousScenes.slice(-1).map(s => ({ ...s, text: (s.text ?? '').slice(0, 800) }));\r\n      const baseReq = {\r\n        scene: { ...scene, text: `${header}\\n\\n${excerpt}` },\r\n        previousScenes: lastPrev as Scene[],\r\n        analysisType: 'consistency' as const,\r\n        readerContext: buildReaderContext(registryKnownNames(reg)),\r\n      } as Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\n      const enriched = enrichAnalysisRequest(baseReq as any, {\r\n        scene,\r\n        detectorType: 'character',\r\n        flags: { critical: Boolean((scene as any)?.critical) },\r\n      });\r\n\r\n      console.debug('[CharacterDetector] invoking AI (consistency) for targets:', targets.length);\r\n      const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n\r\n      const out = mapAICharacterIssues({ issues }, scene.text, targets);\r\n      console.debug('[CharacterDetector] AI returned character issues:', out.length);\r\n      return out;\r\n    } catch (err) {\r\n      console.debug('[CharacterDetector] AI analyzeContinuity failed; degrading to local-only.', err);\r\n      return [];\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\EngagementDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2403,2406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2403,2406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":104,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":104,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4522,4525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4522,4525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":168,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7278,7281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7278,7281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":253,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10935,10938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10935,10938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11041,11044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11041,11044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":260,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11248,11251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11248,11251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11295,11298],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11295,11298],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\ninterface OpeningStats {\r\n  tokenCount150: number;\r\n  avgSentenceLen: number;\r\n  dialogueRatio: number;\r\n  namedEntities: number;\r\n  adverbs: number;\r\n  adjectives: number;\r\n  uniqueProperNouns2: number;\r\n}\r\n\r\ninterface PreviousSummary {\r\n  characters: string[];\r\n  keyTerms: string[];\r\n}\r\n\r\ninterface EngagementDetectionTarget {\r\n  hookLine: string;\r\n  firstSentences: string[];\r\n  contextWindow: string;\r\n  openingStats: OpeningStats;\r\n  previousSummary: PreviousSummary;\r\n}\r\n\r\nconst ADJ_WORDS = new Set([\r\n  'new','young','old','small','large','little','long','short','great','good','bad','happy','sad','dark','bright','cold','warm','quiet','loud','sudden','slow','fast','early'\r\n]);\r\n\r\nexport function splitSentences(text: string): { start: number; end: number; text: string }[] {\r\n  const out: { start: number; end: number; text: string }[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      const seg = text.slice(m.index, m.index + m[0].length);\r\n      out.push({ start: m.index, end: m.index + m[0].length, text: seg.trim() });\r\n    }\r\n  } catch { /* noop */ }\r\n  if (out.length === 0) out.push({ start: 0, end: text.length, text });\r\n  return out;\r\n}\r\n\r\nexport function extractHookLine(text: string): string {\r\n  const sents = splitSentences(text);\r\n  const first = sents.find(s => s.text.trim().length > 0)?.text ?? '';\r\n  return first.trim().slice(0, 200);\r\n}\r\n\r\nfunction uniqueProperInSentences(text: string, sents: readonly { start: number; end: number }[], count = 2): number {\r\n  const take = sents.slice(0, Math.max(0, Math.min(count, sents.length)));\r\n  const set = new Set<string>();\r\n  for (const s of take) {\r\n    const seg = text.slice(s.start, s.end);\r\n    const m = seg.match(/\\b[A-Z][a-z]+\\b/g) ?? [];\r\n    m.forEach((t, idx) => { if (idx > 0) set.add(t); });\r\n  }\r\n  return set.size;\r\n}\r\n\r\nexport function computeOpeningStats(\r\n  text: string,\r\n  firstSentenceSpans: readonly { start: number; end: number; text: string }[],\r\n  nlpDocOrNull: any | null\r\n): OpeningStats {\r\n  const words = (text || '').trim().split(/\\s+/).filter(Boolean);\r\n  const head = words.slice(0, 150).join(' ');\r\n  const tokenCount150 = Math.min(words.length, 150);\r\n  const avgSentenceLen = (() => {\r\n    const consider = firstSentenceSpans.slice(0, Math.min(3, firstSentenceSpans.length));\r\n    if (!consider.length) return 0;\r\n    const totals = consider.map(s => (s.text.split(/\\s+/).filter(Boolean).length));\r\n    return Math.round((totals.reduce((a, b) => a + b, 0) / consider.length) * 10) / 10;\r\n  })();\r\n  const dialogueRatio = (() => {\r\n    const lines = head.split(/\\r?\\n/).filter(l => l.trim().length > 0);\r\n    if (!lines.length) return 0;\r\n    const dlg = lines.filter(l => /^[\"]/.test(l.trim()) || /\\bsaid\\b/i.test(l) || /\\.\\.\\./.test(l));\r\n    return Math.round((dlg.length / lines.length) * 100) / 100;\r\n  })();\r\n  const namedEntities = (() => {\r\n    try { return Array.isArray(nlpDocOrNull?.people?.().out?.('array')) ? (nlpDocOrNull.people().out('array') as string[]).length : (head.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+\\b/g) ?? []).length; }\r\n    catch { return (head.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+\\b/g) ?? []).length; }\r\n  })();\r\n  const adverbs = (head.match(/\\b\\w+ly\\b/g) ?? []).length;\r\n  const adjectives = (() => {\r\n    try { const n = nlpDocOrNull?.adjectives?.()?.out?.('array'); if (Array.isArray(n)) return n.length; } catch {/*noop*/}\r\n    const toks = head.toLowerCase().match(/\\b[a-z]{3,}\\b/g) ?? [];\r\n    return toks.reduce((c, w) => c + (ADJ_WORDS.has(w) ? 1 : 0), 0);\r\n  })();\r\n  const uniqueProperNouns2 = uniqueProperInSentences(text, firstSentenceSpans, 2);\r\n  return { tokenCount150, avgSentenceLen, dialogueRatio, namedEntities, adverbs, adjectives, uniqueProperNouns2 };\r\n}\r\n\r\nexport function summarizePreviousContext(previousScenes: readonly Scene[]): PreviousSummary {\r\n  const joined = previousScenes.map(s => s.text || '').join('\\n').slice(0, 5000);\r\n  const characters = (() => {\r\n    try {\r\n      // Attempt compromise if available\r\n       \r\n      const mod = require('compromise');\r\n      const nlp = (mod?.default ?? mod) as any;\r\n      const doc = typeof nlp === 'function' ? nlp(joined) : null;\r\n      const arr: string[] = doc?.people?.()?.out?.('array') ?? [];\r\n      const uniq = Array.from(new Set(arr.map(s => String(s).trim()).filter(Boolean)));\r\n      return uniq.slice(0, 6);\r\n    } catch {\r\n      const m = joined.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+\\b/g) ?? [];\r\n      const uniq = Array.from(new Set(m));\r\n      return uniq.slice(0, 6);\r\n    }\r\n  })();\r\n  const keyTerms = (() => {\r\n    const caps = (joined.match(/\\b[A-Z][a-z]+\\b/g) ?? []).map(s => s.trim());\r\n    const stop = new Set(['The','A','An','And','But','Or','If','Then','When','While','After','Before']);\r\n    const freq = new Map<string, number>();\r\n    for (const t of caps) {\r\n      if (stop.has(t)) continue;\r\n      freq.set(t, (freq.get(t) ?? 0) + 1);\r\n    }\r\n    return Array.from(freq.entries()).sort((a,b)=>b[1]-a[1]).slice(0,5).map(e=>e[0]);\r\n  })();\r\n  return { characters, keyTerms };\r\n}\r\n\r\nexport function buildEngagementDetectionTarget(\r\n  scene: Scene,\r\n  previousScenes: readonly Scene[],\r\n  stats: OpeningStats,\r\n  sentences: readonly { start: number; end: number; text: string }[]\r\n): EngagementDetectionTarget {\r\n  const hookLine = extractHookLine(scene.text || '');\r\n  const firstSentences = sentences.slice(0, 3).map(s => s.text.trim());\r\n  const contextWindow = (scene.text || '').slice(0, 900);\r\n  const previousSummary = summarizePreviousContext(previousScenes);\r\n  return { hookLine, firstSentences, contextWindow, openingStats: stats, previousSummary };\r\n}\r\n\r\nfunction findHookSpan(sceneText: string, hookLine: string): [number, number] {\r\n  const trimmed = (hookLine || '').trim();\r\n  if (!trimmed) return [0, Math.min(sceneText.length, 1)];\r\n  const idx = sceneText.indexOf(trimmed);\r\n  if (idx >= 0) return [idx, idx + trimmed.length];\r\n  return [0, Math.min(sceneText.length, Math.max(1, trimmed.length))];\r\n}\r\n\r\nfunction deriveSeverity(desc?: string): ContinuityIssue['severity'] {\r\n  const d = (desc || '').toLowerCase();\r\n  if (/(no|weak)\\s+hook|no\\s+conflict|los(e|ing)\\s+reader|very\\s+slow\\s+pacing/.test(d)) return 'must-fix';\r\n  if (/moderate|somewhat\\s+slow|dense\\s+exposition|confusing\\s+load|could\\s+be\\s+tighter/.test(d)) return 'should-fix';\r\n  return 'consider';\r\n}\r\n\r\nfunction mapAIEngagementIssues(\r\n  resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n  sceneText: string,\r\n  hookLine: string\r\n): ContinuityIssue[] {\r\n  const out: ContinuityIssue[] = [];\r\n  const fallbackSpan = findHookSpan(sceneText, hookLine);\r\n  for (const it of resp?.issues ?? []) {\r\n    const hasSpan = Array.isArray(it.textSpan) && Number.isFinite(it.textSpan[0]) && Number.isFinite(it.textSpan[1]);\r\n    out.push({\r\n      type: 'engagement',\r\n      severity: (it.severity as any) || deriveSeverity(it.description),\r\n      description: it.description ?? 'Engagement issue detected in opening.',\r\n      textSpan: (hasSpan ? (it.textSpan as [number, number]) : fallbackSpan),\r\n      suggestedFix: it.suggestedFix\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction buildReaderContextFromSummary(sum: PreviousSummary) {\r\n  return {\r\n    knownCharacters: new Set(sum.characters),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: []\r\n  };\r\n}\r\n\r\nfunction buildAIHeader(scene: Scene, cand: EngagementDetectionTarget): string {\r\n  const s = cand.openingStats;\r\n  const parts: string[] = [];\r\n  parts.push('[[Engagement assessment request]]');\r\n  parts.push(`scene: id=${scene.id} pos=${scene.position}`);\r\n  parts.push(`hook: \"${cand.hookLine.slice(0, 160).replace(/\\n+/g, ' ')}\"`);\r\n  parts.push(`openingStats: token150=${s.tokenCount150} avgSentLen=${s.avgSentenceLen} dialogRatio=${s.dialogueRatio} ents=${s.namedEntities} adv=${s.adverbs} adj=${s.adjectives} proper2=${s.uniqueProperNouns2}`);\r\n  parts.push('Assess:');\r\n  parts.push('- Opening hook clarity/strength');\r\n  parts.push('- Early tension/conflict presence');\r\n  parts.push('- Pacing in first ~700900 chars');\r\n  parts.push('- Character introduction load and clarity');\r\n  const chars = cand.previousSummary.characters.join(', ');\r\n  const terms = cand.previousSummary.keyTerms.join(', ');\r\n  parts.push(`prevContext: chars=[${chars}] key=[${terms}]`);\r\n  return parts.join('\\n');\r\n}\r\n\r\nexport default class EngagementDetector extends BaseDetector<EngagementDetectionTarget> {\r\n  public readonly detectorType = 'engagement' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<EngagementDetectionTarget>> {\r\n    if (!scene?.text || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n    const doc = await this.safeNLP(scene.text);\r\n    const sentences = splitSentences(scene.text);\r\n    const stats = computeOpeningStats(scene.text, sentences, doc);\r\n    const target = buildEngagementDetectionTarget(scene, previousScenes, stats, sentences);\r\n    const targets = target.hookLine ? [target] : [];\r\n    console.debug('[EngagementDetector] stats/target:', { stats, hasTarget: targets.length > 0 });\r\n    return {\r\n      issues: [],\r\n      requiresAI: targets.length > 0,\r\n      targets,\r\n      stats: stats as unknown as Record<string, number>\r\n    };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly EngagementDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n    const cand = targets[0];\r\n    try {\r\n      const header = buildAIHeader(scene, cand);\r\n      const body: string[] = [];\r\n      body.push('[[First sentences]]');\r\n      for (const s of cand.firstSentences) body.push(`- ${s}`);\r\n      body.push('[[Scene context (~900 chars)]]');\r\n      body.push(cand.contextWindow);\r\n      const textPayload = `${header}\\n\\n${body.join('\\n')}`;\r\n      const lastPrev = previousScenes.slice(-1).map(s => ({ ...s, text: (s.text ?? '').slice(0, 600) }));\r\n      const baseReq = {\r\n        scene: { ...scene, text: textPayload },\r\n        previousScenes: lastPrev as Scene[],\r\n        analysisType: 'full' as const,\r\n        readerContext: buildReaderContextFromSummary(cand.previousSummary)\r\n      } as Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\n      const enriched = enrichAnalysisRequest(baseReq as any, {\r\n        scene,\r\n        detectorType: 'engagement',\r\n        flags: { critical: Boolean((scene as any)?.critical) },\r\n      });\r\n\r\n      console.debug('[EngagementDetector] invoking AI (full) for detection targets');\r\n      const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n\r\n      const out = mapAIEngagementIssues({ issues }, scene.text, cand.hookLine);\r\n      console.debug('[EngagementDetector] AI returned engagement issues:', out.length);\r\n      return out;\r\n    } catch (err) {\r\n      console.debug('[EngagementDetector] AI analyzeContinuity failed; returning empty.', err);\r\n      return [];\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\IssueAggregator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1349,1352],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1349,1352],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1406,1409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1406,1409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1464,1467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1464,1467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":131,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5510,5513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5510,5513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ContinuityIssue } from '../../../../shared/types';\r\n\r\ntype Sev = ContinuityIssue['severity'];\r\ntype Typ = ContinuityIssue['type'];\r\ntype WithMeta = ContinuityIssue & { _src?: string };\r\n\r\nconst TYPE_ORDER: readonly Typ[] = ['pronoun', 'character', 'plot', 'timeline', 'engagement', 'context'];\r\n\r\n/** Rank severities: must-fix(3) > should-fix(2) > consider(1) */\r\nexport function severityRank(sev: Sev): number {\r\n  switch (sev) {\r\n    case 'must-fix': return 3;\r\n    case 'should-fix': return 2;\r\n    case 'consider': return 1;\r\n    default: return 2;\r\n  }\r\n}\r\n\r\nfunction sanitizeDescription(desc: unknown): string {\r\n  const s = String(desc ?? '').replace(/\\s+/g, ' ').trim();\r\n  return s;\r\n}\r\n\r\nfunction sanitizeSpan(span: unknown): [number, number] {\r\n  if (!Array.isArray(span) || span.length < 2) return [0, 0];\r\n  let s = Number(span[0]); let e = Number(span[1]);\r\n  if (!Number.isFinite(s)) s = 0;\r\n  if (!Number.isFinite(e)) e = 0;\r\n  if (s > e) [s, e] = [e, s];\r\n  if (s < 0) s = 0;\r\n  if (e < 0) e = 0;\r\n  return [s, e];\r\n}\r\n\r\nfunction sanitizeSeverity(sev: unknown): Sev {\r\n  return sev === 'must-fix' || sev === 'should-fix' || sev === 'consider' ? sev : 'should-fix';\r\n}\r\n\r\nfunction sanitizeIssue<T extends ContinuityIssue>(issue: T): T {\r\n  const fixed = {\r\n    ...issue,\r\n    description: sanitizeDescription((issue as any).description),\r\n    textSpan: sanitizeSpan((issue as any).textSpan),\r\n    severity: sanitizeSeverity((issue as any).severity),\r\n  };\r\n  return fixed as T;\r\n}\r\n\r\n/** Normalize issues defensively; does not mutate inputs. */\r\nexport function normalizeIssues(issues: readonly ContinuityIssue[]): ContinuityIssue[] {\r\n  return issues.map((i) => sanitizeIssue(i));\r\n}\r\n\r\nfunction normForSim(s: string): string {\r\n  return s.toLowerCase().replace(/[0-9]+/g, '').replace(/[^a-z]+/g, ' ').replace(/\\s+/g, ' ').trim();\r\n}\r\n\r\nfunction prefixSimilar(a: string, b: string): boolean {\r\n  const A = normForSim(a); const B = normForSim(b);\r\n  if (!A || !B) return false;\r\n  const short = A.length <= B.length ? A : B;\r\n  const long = A.length <= B.length ? B : A;\r\n  return long.startsWith(short);\r\n}\r\n\r\n/** Build duplicate groups via connectivity using the rules in requirements. */\r\nexport function findDuplicateGroups(issues: readonly ContinuityIssue[]): number[][] {\r\n  const n = issues.length, groups: number[][] = [], visited = new Array(n).fill(false);\r\n  const getSpan = (i: number) => issues[i].textSpan ?? [0, 0];\r\n  const len = (s: [number, number]) => Math.max(0, s[1] - s[0]);\r\n  const ovl = (a: [number, number], b: [number, number]) => Math.max(0, Math.min(a[1], b[1]) - Math.max(a[0], b[0]));\r\n  const same = (a: [number, number], b: [number, number]) => a[0] === b[0] && a[1] === b[1];\r\n  const isDup = (i: number, j: number): boolean => {\r\n    const A = issues[i], B = issues[j], sa = getSpan(i), sb = getSpan(j);\r\n    if (A.description === B.description && sa[0] === sb[0]) return true;\r\n    const o = ovl(sa, sb), short = Math.min(len(sa), len(sb)), ps = prefixSimilar(A.description, B.description);\r\n    if (A.type === B.type) return same(sa, sb) || (short > 0 && o / short >= 0.5) || (ps && Math.abs(sa[0] - sb[0]) <= 30);\r\n    return ps && Math.abs(sa[0] - sb[0]) <= 10;\r\n  };\r\n  for (let i = 0; i < n; i++) {\r\n    if (visited[i]) continue;\r\n    const comp: number[] = [], q: number[] = [i]; visited[i] = true;\r\n    while (q.length) {\r\n      const u = q.shift() as number; comp.push(u);\r\n      for (let v = 0; v < n; v++) if (!visited[v] && isDup(u, v)) { visited[v] = true; q.push(v); }\r\n    }\r\n    groups.push(comp);\r\n  }\r\n  return groups;\r\n}\r\n\r\nfunction truncate(s: string, max = 220): string {\r\n  return s.length <= max ? s : s.slice(0, max).trimEnd();\r\n}\r\n\r\nfunction dominantType(issues: readonly ContinuityIssue[]): Typ {\r\n  const count = new Map<Typ, number>();\r\n  const must = new Map<Typ, number>();\r\n  for (const it of issues) {\r\n    count.set(it.type, (count.get(it.type) ?? 0) + 1);\r\n    must.set(it.type, (must.get(it.type) ?? 0) + (it.severity === 'must-fix' ? 1 : 0));\r\n  }\r\n  let primary: Typ = issues[0]?.type ?? 'pronoun';\r\n  for (const t of new Set(issues.map((i) => i.type))) {\r\n    const c = count.get(t) ?? 0;\r\n    const cm = must.get(t) ?? 0;\r\n    const bc = count.get(primary) ?? 0;\r\n    const bm = must.get(primary) ?? 0;\r\n    if (c > bc || (c === bc && cm > bm) || (c === bc && cm === bm && (TYPE_ORDER.indexOf(t) - TYPE_ORDER.indexOf(primary) < 0))) {\r\n      primary = t;\r\n    }\r\n  }\r\n  return primary;\r\n}\r\n\r\n/** Merge a group of duplicate issues into a representative issue. */\r\nexport function mergeGroup(issues: readonly ContinuityIssue[], groupIndexes: number[]): ContinuityIssue {\r\n  const group = groupIndexes.map((i) => issues[i]);\r\n  // Severity: highest\r\n  let sev: Sev = 'consider';\r\n  for (const it of group) if (severityRank(it.severity) > severityRank(sev)) sev = it.severity;\r\n  // Span: minimal covering\r\n  let start = Infinity, end = -Infinity;\r\n  for (const it of group) { const [s, e] = it.textSpan ?? [0, 0]; if (s < start) start = s; if (e > end) end = e; }\r\n  if (!Number.isFinite(start) || !Number.isFinite(end)) { start = 0; end = 0; }\r\n  // Description: longest concise, then optional detector suffix\r\n  let longestDesc = '';\r\n  for (const it of group) if (sanitizeDescription(it.description).length > longestDesc.length) longestDesc = sanitizeDescription(it.description);\r\n  longestDesc = truncate(longestDesc, 220);\r\n  const srcs = new Set<string>();\r\n  for (const it of group) { const s = (it as any)._src; if (typeof s === 'string' && s) srcs.add(s); }\r\n  if (srcs.size > 1) {\r\n    const suffix = Array.from(srcs).slice(0, 2).join(',');\r\n    longestDesc = `${longestDesc} [from: ${suffix}]`;\r\n  }\r\n  // Suggested fix: prefer shortest non-empty\r\n  let fix: string | undefined;\r\n  const fixes = group.map((g) => sanitizeDescription(g.suggestedFix)).filter((f) => f.length > 0);\r\n  if (fixes.length) fix = fixes.reduce((a, b) => (a.length <= b.length ? a : b));\r\n  // Type: dominant by frequency, then must-fix count, then stable order\r\n  const typ = dominantType(group);\r\n\r\n  return {\r\n    type: typ,\r\n    severity: sev,\r\n    description: longestDesc,\r\n    textSpan: [Math.max(0, start), Math.max(0, end)],\r\n    ...(fix ? { suggestedFix: fix } : {}),\r\n  };\r\n}\r\n\r\n/** Sort by severity desc, start asc, shorter span first, then type alpha. */\r\nexport function sortIssues(issues: readonly ContinuityIssue[]): ContinuityIssue[] {\r\n  return [...issues].sort((a, b) => {\r\n    const sr = severityRank(b.severity) - severityRank(a.severity);\r\n    if (sr !== 0) return sr;\r\n    const [as, ae] = a.textSpan ?? [0, 0]; const [bs, be] = b.textSpan ?? [0, 0];\r\n    if (as !== bs) return as - bs;\r\n    const al = Math.max(0, ae - as), bl = Math.max(0, be - bs);\r\n    if (al !== bl) return al - bl;\r\n    return a.type.localeCompare(b.type);\r\n  });\r\n}\r\n\r\n/**\r\n * Aggregates, de-duplicates, merges, prioritizes, and limits issues per UX rules.\r\n * - Flatten and tag by source\r\n * - Normalize and validate\r\n * - Group likely duplicates\r\n * - Merge groups\r\n * - Prioritize + sort\r\n * - Limit with must-fix overflow handling\r\n */\r\nexport default class IssueAggregator {\r\n  public aggregate(detectorResults: Map<string, ContinuityIssue[]>): ContinuityIssue[] {\r\n    // 1) Flatten with source tag\r\n    const flat: WithMeta[] = [];\r\n    for (const [src, arr] of detectorResults.entries()) {\r\n      if (!Array.isArray(arr)) continue;\r\n      for (const issue of arr) {\r\n        const normalized = sanitizeIssue(issue as ContinuityIssue) as WithMeta;\r\n        normalized._src = src;\r\n        flat.push(normalized);\r\n      }\r\n    }\r\n\r\n    // 2) (Already normalized above); build working copy for grouping\r\n    const working: ContinuityIssue[] = flat as ContinuityIssue[];\r\n\r\n    // 3) Duplicate grouping\r\n    const groups = findDuplicateGroups(working);\r\n\r\n    // 4) Merge per group\r\n    const merged: ContinuityIssue[] = groups.map((g) => mergeGroup(working, g));\r\n\r\n    // 5) Prioritize + sort\r\n    const sorted = sortIssues(merged);\r\n\r\n    // 6) Limit: top 10 normally; if must-fix > 10, include all must-fix then fill with should-fix up to 15\r\n    const must = sorted.filter((i) => i.severity === 'must-fix');\r\n    if (must.length > 10) {\r\n      const should = sorted.filter((i) => i.severity === 'should-fix').slice(0, Math.max(0, 15 - must.length));\r\n      return [...must, ...should];\r\n    }\r\n    return sorted.slice(0, 10);\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\PlotContextDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":188,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7012,7015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7012,7015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":119,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":122,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7446,7449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7446,7449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":478,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":478,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18516,18519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18516,18519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":482,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":482,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18663,18666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18663,18666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":486,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":486,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18792,18795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18792,18795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":487,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":487,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18839,18842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18839,18842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":503,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":503,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19449,19452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19449,19452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":518,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":518,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19889,19892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19889,19892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\n/**\r\n * Hybrid Plot/Context continuity detector (Detector 4 - Phase 2):\r\n * - Local NLP with compromise.js (safe load) + regex fallbacks\r\n * - Detects forward references, world-building assumptions, and causal gaps\r\n * - Selective AI validation for complex/ambiguous cases (analysisType: \"complex\")\r\n *\r\n * Helper functions are kept small ( 40 lines) and exported where tests need them.\r\n */\r\n\r\n// ---------- Types (exported for tests where needed) ----------\r\nexport interface SentenceSpan {\r\n  text: string;\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\ninterface Stat {\r\n  count: number;\r\n  firstSpan?: [number, number];\r\n}\r\n\r\nexport interface PreviousPlotRegistry {\r\n  signature: string;\r\n  events: Record<string, Stat>;\r\n  entities: Record<string, Stat>;\r\n  causal: Array<{ connector: string; sentence: string }>;\r\n}\r\n\r\nexport type PlotCueKind = 'definiteEvent' | 'forwardRef' | 'worldEntity' | 'causalConnector';\r\n\r\nexport interface PlotObservation {\r\n  kind: PlotCueKind;\r\n  markerText: string;\r\n  start: number;\r\n  end: number;\r\n  sentenceIndex: number;\r\n  sentenceText?: string;\r\n  head?: string;\r\n  connector?: string;\r\n}\r\n\r\nexport interface PlotDetectionTarget {\r\n  markerText: string;\r\n  sentenceText: string;\r\n  context: string;\r\n  span: [number, number];\r\n  sentenceIndex: number;\r\n  registrySummary: string[];\r\n  otherCues: string[];\r\n}\r\n\r\n// ---------- Constants ----------\r\nconst EVENT_HEADS = [\r\n  'incident','plan','attack','meeting','report','operation','secret','truth','betrayal','leak',\r\n  'accident','ambush','deal','ceremony','trial','storm','outbreak','lockdown','discovery',\r\n  'letter','note','photo','message'\r\n];\r\n\r\nconst FORWARD_ALLOW = [\r\n  'promise','plan','deal','thing','attack','note','letter','message','report','secret','truth',\r\n  'leak','accident','ambush','trial','storm','outbreak','lockdown','discovery','incident','meeting','operation','photo'\r\n];\r\n\r\nconst CONNECTORS = ['because', 'therefore', 'so that', 'as a result', 'since', 'due to'];\r\n\r\n// ---------- Caches ----------\r\nconst prevRegistryCache: Map<string, PreviousPlotRegistry> = new Map();\r\n\r\n// ---------- Small utilities ----------\r\nfunction normalizeKey(s: string): string {\r\n  return s.trim().toLowerCase();\r\n}\r\n\r\nfunction contextSnippet(text: string, start: number, end: number, radius = 120): string {\r\n  const s = Math.max(0, start - radius);\r\n  const e = Math.min(text.length, end + radius);\r\n  return text.slice(s, e).trim();\r\n}\r\n\r\nfunction previousScenesSignature(previous: readonly Scene[]): string {\r\n  return previous.map(s => s.id).join('|');\r\n}\r\n\r\nfunction registryIsEmpty(reg: PreviousPlotRegistry): boolean {\r\n  return Object.keys(reg.events).length === 0 && Object.keys(reg.entities).length === 0 && reg.causal.length === 0;\r\n}\r\n\r\n// ---------- Exported helpers (testing hooks) ----------\r\nexport function splitSentences(text: string): SentenceSpan[] {\r\n  const out: SentenceSpan[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      const start = m.index;\r\n      const end = start + m[0].length;\r\n      out.push({ text: text.slice(start, end).trim(), start, end });\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  if (out.length === 0) out.push({ text, start: 0, end: text.length });\r\n  return out;\r\n}\r\n\r\nexport function detectCausalConnectors(sentenceText: string): string[] {\r\n  const found: string[] = [];\r\n  const lower = sentenceText.toLowerCase();\r\n  for (const c of CONNECTORS) {\r\n    if (lower.includes(c)) found.push(c);\r\n  }\r\n  return found;\r\n}\r\n\r\nfunction findAllInSentence(text: string, sent: SentenceSpan, re: RegExp): Array<{ start: number; end: number; text: string }> {\r\n  const out: Array<{ start: number; end: number; text: string }> = [];\r\n  const segment = text.slice(sent.start, sent.end);\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(segment)) !== null) {\r\n    const s = sent.start + m.index;\r\n    const e = s + m[0].length;\r\n    out.push({ start: s, end: e, text: m[0] });\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function extractEventMentions(text: string, sentences: SentenceSpan[]): PlotObservation[] {\r\n  const obs: PlotObservation[] = [];\r\n  const heads = EVENT_HEADS.join('|');\r\n  const defRe = new RegExp(`\\\\bthe\\\\s+(${heads})\\\\b`, 'gi');\r\n  const thatRe = new RegExp(`\\\\bthat\\\\s+(${FORWARD_ALLOW.join('|')})\\\\b`, 'gi');\r\n  const whatRe = /\\bwhat\\s+(?:we\\s+|they\\s+|he\\s+|she\\s+|happened\\b|was\\b)/gi;\r\n\r\n  sentences.forEach((sent, si) => {\r\n    for (const m of findAllInSentence(text, sent, defRe)) {\r\n      const head = m.text.replace(/^the\\s+/i, '').toLowerCase();\r\n      obs.push({ kind: 'definiteEvent', markerText: m.text, start: m.start, end: m.end, sentenceIndex: si, sentenceText: sent.text, head });\r\n    }\r\n    for (const m of findAllInSentence(text, sent, thatRe)) {\r\n      const head = m.text.replace(/^that\\s+/i, '').toLowerCase();\r\n      obs.push({ kind: 'forwardRef', markerText: m.text, start: m.start, end: m.end, sentenceIndex: si, sentenceText: sent.text, head });\r\n    }\r\n    for (const m of findAllInSentence(text, sent, whatRe)) {\r\n      obs.push({ kind: 'forwardRef', markerText: m.text, start: m.start, end: m.end, sentenceIndex: si, sentenceText: sent.text });\r\n    }\r\n  });\r\n  return obs;\r\n}\r\n\r\n// ----- World entities helpers (keep tiny) -----\r\nfunction pushAllCapsEntities(seg: string, baseStart: number, known: Set<string>, sentText: string, si: number, out: PlotObservation[]): void {\r\n  const allCapsRe = /\\b([A-Z]{2,})\\b/g;\r\n  let m: RegExpExecArray | null;\r\n  allCapsRe.lastIndex = 0;\r\n  while ((m = allCapsRe.exec(seg)) !== null) {\r\n    const s = baseStart + m.index;\r\n    const e = s + m[0].length;\r\n    const key = normalizeKey(m[1]);\r\n    if (!known.has(key)) {\r\n      out.push({ kind: 'worldEntity', markerText: m[1], start: s, end: e, sentenceIndex: si, sentenceText: sentText });\r\n    }\r\n  }\r\n}\r\n\r\nfunction pushProperNounEntities(seg: string, baseStart: number, known: Set<string>, people: Set<string>, sentText: string, si: number, out: PlotObservation[]): void {\r\n  const personRe = /\\b([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)\\b/g;\r\n  let m: RegExpExecArray | null;\r\n  personRe.lastIndex = 0;\r\n  while ((m = personRe.exec(seg)) !== null) {\r\n    const s = baseStart + m.index;\r\n    const isStart = m.index <= 1;\r\n    const phrase = m[1];\r\n    const key = normalizeKey(phrase);\r\n    if (isStart) continue;\r\n    if (people.has(phrase)) continue;\r\n    if (!known.has(key)) {\r\n      const e = s + phrase.length;\r\n      out.push({ kind: 'worldEntity', markerText: phrase, start: s, end: e, sentenceIndex: si, sentenceText: sentText });\r\n    }\r\n  }\r\n}\r\n\r\nfunction collectPeople(nlpDoc: any | null): Set<string> {\r\n  const people = new Set<string>();\r\n  try {\r\n    if (nlpDoc && typeof nlpDoc.people === 'function') {\r\n      for (const p of nlpDoc.people().out('array') ?? []) {\r\n        if (typeof p === 'string') people.add(p);\r\n      }\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  return people;\r\n}\r\n\r\nfunction extractWorldEntitiesCurrent(text: string, sentences: SentenceSpan[], registry: PreviousPlotRegistry, nlpDoc: any | null): PlotObservation[] {\r\n  const obs: PlotObservation[] = [];\r\n  const known = new Set(Object.keys(registry.entities).map(normalizeKey));\r\n  const people = collectPeople(nlpDoc);\r\n\r\n  sentences.forEach((sent, si) => {\r\n    const seg = text.slice(sent.start, sent.end);\r\n    pushAllCapsEntities(seg, sent.start, known, sent.text, si, obs);\r\n    pushProperNounEntities(seg, sent.start, known, people, sent.text, si, obs);\r\n  });\r\n  return obs;\r\n}\r\n\r\nfunction extractCausalConnectors(text: string, sentences: SentenceSpan[]): PlotObservation[] {\r\n  const out: PlotObservation[] = [];\r\n  sentences.forEach((sent, si) => {\r\n    for (const conn of detectCausalConnectors(sent.text)) {\r\n      const idx = sent.text.toLowerCase().indexOf(conn);\r\n      if (idx >= 0) {\r\n        const s = sent.start + idx;\r\n        const e = s + conn.length;\r\n        out.push({ kind: 'causalConnector', markerText: conn, start: s, end: e, sentenceIndex: si, sentenceText: sent.text, connector: conn });\r\n      }\r\n    }\r\n  });\r\n  return out;\r\n}\r\n\r\n// ----- Previous registry scanners (kept small) -----\r\nfunction scanEventsInto(text: string, events: Record<string, Stat>): void {\r\n  const heads = EVENT_HEADS.join('|');\r\n  const eventRe = new RegExp(`\\\\bthe\\\\s+(${heads})\\\\b`, 'gi');\r\n  let m: RegExpExecArray | null;\r\n  eventRe.lastIndex = 0;\r\n  while ((m = eventRe.exec(text)) !== null) {\r\n    const head = normalizeKey(m[1]);\r\n    const s = m.index;\r\n    const e = s + m[0].length;\r\n    const stat = (events[head] ??= { count: 0 });\r\n    stat.count++;\r\n    if (!stat.firstSpan) stat.firstSpan = [s, e];\r\n  }\r\n}\r\n\r\nfunction scanAllCapsInto(text: string, entities: Record<string, Stat>): void {\r\n  const allCapsRe = /\\b([A-Z]{2,})\\b/g;\r\n  let m: RegExpExecArray | null;\r\n  allCapsRe.lastIndex = 0;\r\n  while ((m = allCapsRe.exec(text)) !== null) {\r\n    const key = normalizeKey(m[1]);\r\n    const s = m.index;\r\n    const e = s + m[0].length;\r\n    const stat = (entities[key] ??= { count: 0 });\r\n    stat.count++;\r\n    if (!stat.firstSpan) stat.firstSpan = [s, e];\r\n  }\r\n}\r\n\r\nfunction scanSentenceLevelInto(text: string, entities: Record<string, Stat>, causal: Array<{ connector: string; sentence: string }>): void {\r\n  const properRe = /\\b([A-Z][A-Za-z0-9]+(?:\\s+[A-Z][A-Za-z0-9]+){0,3})\\b/g;\r\n  const sents = splitSentences(text);\r\n  for (const sent of sents) {\r\n    const seg = text.slice(sent.start, sent.end);\r\n    let n: RegExpExecArray | null;\r\n    properRe.lastIndex = 0;\r\n    while ((n = properRe.exec(seg)) !== null) {\r\n      if (n.index <= 1) continue;\r\n      const phrase = n[1];\r\n      const key = normalizeKey(phrase);\r\n      const s = sent.start + n.index;\r\n      const e = s + phrase.length;\r\n      const stat = (entities[key] ??= { count: 0 });\r\n      stat.count++;\r\n      if (!stat.firstSpan) stat.firstSpan = [s, e];\r\n    }\r\n    for (const c of detectCausalConnectors(sent.text)) {\r\n      causal.push({ connector: c, sentence: sent.text });\r\n    }\r\n  }\r\n}\r\n\r\nexport function buildPreviousPlotRegistry(previousScenes: readonly Scene[]): PreviousPlotRegistry {\r\n  const signature = previousScenesSignature(previousScenes);\r\n  const cached = prevRegistryCache.get(signature);\r\n  if (cached) return cached;\r\n\r\n  const events: Record<string, Stat> = {};\r\n  const entities: Record<string, Stat> = {};\r\n  const causal: Array<{ connector: string; sentence: string }> = [];\r\n\r\n  for (const sc of previousScenes) {\r\n    const text = sc.text || '';\r\n    scanEventsInto(text, events);\r\n    scanAllCapsInto(text, entities);\r\n    scanSentenceLevelInto(text, entities, causal);\r\n  }\r\n\r\n  const reg: PreviousPlotRegistry = { signature, events, entities, causal };\r\n  prevRegistryCache.set(signature, reg);\r\n  return reg;\r\n}\r\n\r\nfunction summarizeRegistry(reg: PreviousPlotRegistry, maxItems = 8): string[] {\r\n  type Entry = { key: string; count: number; label: string };\r\n  const ev: Entry[] = Object.entries(reg.events).map(([k, v]) => ({ key: k, count: v.count, label: `event:${k}(${v.count})` }));\r\n  const en: Entry[] = Object.entries(reg.entities).map(([k, v]) => ({ key: k, count: v.count, label: `entity:${k}(${v.count})` }));\r\n  const all = [...ev, ...en].sort((a, b) => b.count - a.count).slice(0, maxItems);\r\n  return all.map(e => e.label);\r\n}\r\n\r\nfunction hasRecentCause(sentIndex: number, observations: PlotObservation[], sentences: SentenceSpan[]): boolean {\r\n  const prior = observations.filter(o => o.sentenceIndex === sentIndex - 1);\r\n  if (prior.some(o => o.kind === 'definiteEvent' || o.kind === 'forwardRef')) return true;\r\n  const textPrev = sentences[sentIndex - 1]?.text?.toLowerCase?.() ?? '';\r\n  return /because|since|due to/.test(textPrev);\r\n}\r\n\r\nfunction isWorldEntityAmbiguous(name: string): boolean {\r\n  const isSingleWord = !/\\s/.test(name);\r\n  const notAllCaps = !/^[A-Z]{2,}$/.test(name);\r\n  return isSingleWord && notAllCaps;\r\n}\r\n\r\n// ---------- Issue generation and detection target assembly ----------\r\nfunction generateImmediateIssues(\r\n  observations: PlotObservation[],\r\n  registry: PreviousPlotRegistry\r\n): ContinuityIssue[] {\r\n  const issues: ContinuityIssue[] = [];\r\n  const knownEvents = new Set(Object.keys(registry.events));\r\n  const isKnownEvent = (head?: string) => !!(head && knownEvents.has(normalizeKey(head)));\r\n\r\n  for (const o of observations) {\r\n    if (o.kind === 'definiteEvent' || o.kind === 'forwardRef') {\r\n      if (!isKnownEvent(o.head)) {\r\n        const opening = o.sentenceIndex <= 1;\r\n        issues.push({\r\n          type: 'plot',\r\n          severity: opening ? 'must-fix' : 'should-fix',\r\n          description: `Forward reference: \"${o.markerText}\" not previously established.`,\r\n          textSpan: [o.start, o.end],\r\n        });\r\n      }\r\n    } else if (o.kind === 'worldEntity') {\r\n      const key = normalizeKey(o.markerText);\r\n      const known = registry.entities[key]?.count > 0;\r\n      if (!known) {\r\n        const opening = o.sentenceIndex <= 1;\r\n        issues.push({\r\n          type: 'plot',\r\n          severity: opening ? 'must-fix' : 'should-fix',\r\n          description: `World-building assumption: \"${o.markerText}\" appears without prior introduction.`,\r\n          textSpan: [o.start, o.end],\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return issues;\r\n}\r\n\r\nfunction addAmbiguousEventTargets(targets: PlotDetectionTarget[], defEvents: PlotObservation[], sceneText: string, regSummary: string[]): void {\r\n  const heads = new Set(defEvents.map(o => normalizeKey(o.head ?? '')));\r\n  if (defEvents.length >= 2 && heads.size >= 2) {\r\n    for (const o of defEvents) {\r\n      targets.push({\r\n        markerText: o.markerText,\r\n        sentenceText: o.sentenceText ?? '',\r\n        context: contextSnippet(sceneText, o.start, o.end),\r\n        span: [o.start, o.end],\r\n        sentenceIndex: o.sentenceIndex,\r\n        registrySummary: regSummary,\r\n        otherCues: defEvents.filter(x => x !== o).map(x => x.markerText),\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nfunction addWorldAmbiguousTargets(targets: PlotDetectionTarget[], world: PlotObservation[], defEvents: PlotObservation[], sceneText: string, regSummary: string[]): void {\r\n  for (const o of world) {\r\n    if (isWorldEntityAmbiguous(o.markerText)) {\r\n      targets.push({\r\n        markerText: o.markerText,\r\n        sentenceText: o.sentenceText ?? '',\r\n        context: contextSnippet(sceneText, o.start, o.end),\r\n        span: [o.start, o.end],\r\n        sentenceIndex: o.sentenceIndex,\r\n        registrySummary: regSummary,\r\n        otherCues: defEvents.map(x => x.markerText),\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nfunction addCausalChainTargets(targets: PlotDetectionTarget[], causal: PlotObservation[], sceneText: string, regSummary: string[]): void {\r\n  const causalBySentence = new Set(causal.map(c => c.sentenceIndex));\r\n  if (causalBySentence.size >= 2) {\r\n    for (const o of causal) {\r\n      targets.push({\r\n        markerText: o.markerText,\r\n        sentenceText: o.sentenceText ?? '',\r\n        context: contextSnippet(sceneText, o.start, o.end),\r\n        span: [o.start, o.end],\r\n        sentenceIndex: o.sentenceIndex,\r\n        registrySummary: regSummary,\r\n        otherCues: causal.filter(x => x !== o).map(x => x.markerText),\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function assemblePlotDetectionTargets(\r\n  observations: PlotObservation[],\r\n  registry: PreviousPlotRegistry,\r\n  sceneText: string\r\n): PlotDetectionTarget[] {\r\n  const targets: PlotDetectionTarget[] = [];\r\n  const regSummary = summarizeRegistry(registry);\r\n  const defEvents = observations.filter(o => o.kind === 'definiteEvent');\r\n  const world = observations.filter(o => o.kind === 'worldEntity');\r\n  const causal = observations.filter(o => o.kind === 'causalConnector');\r\n \r\n  addAmbiguousEventTargets(targets, defEvents, sceneText, regSummary);\r\n  addWorldAmbiguousTargets(targets, world, defEvents, sceneText, regSummary);\r\n  addCausalChainTargets(targets, causal, sceneText, regSummary);\r\n  return targets;\r\n}\r\n\r\n// ---------- Detector implementation ----------\r\nexport default class PlotContextDetector extends BaseDetector<PlotDetectionTarget> {\r\n  public readonly detectorType = 'plot' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<PlotDetectionTarget>> {\r\n    if (!scene?.text || typeof scene.text !== 'string' || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n \r\n    const doc = await this.prepareDoc(scene.text);\r\n    const sentences = splitSentences(scene.text);\r\n    const registry = buildPreviousPlotRegistry(previousScenes);\r\n \r\n    const { observations, eventObs, worldObs, causalObs } = this.collectObservations(scene.text, sentences, registry, doc);\r\n    if (observations.length === 0 && registryIsEmpty(registry)) {\r\n      console.debug('[PlotContextDetector] No observations and empty registry; early exit.');\r\n      return { issues: [], requiresAI: false, targets: [], stats: { observations: 0 } };\r\n    }\r\n \r\n    const { issues, targets } = this.buildIssuesAndTargets(scene.text, sentences, observations, registry, eventObs, worldObs, causalObs);\r\n \r\n    console.debug('[PlotContextDetector] local counts:', {\r\n      sentences: sentences.length,\r\n      obs: observations.length,\r\n      events: eventObs.length,\r\n      world: worldObs.length,\r\n      causal: causalObs.length,\r\n      issues: issues.length,\r\n      targets: targets.length,\r\n    });\r\n \r\n    const requiresAI = targets.length > 0;\r\n    return { issues, requiresAI, targets, stats: { observations: observations.length } };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly PlotDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n    const summary = (targets[0]?.registrySummary ?? []).slice(0, 8);\r\n    console.debug('[PlotContextDetector] invoking AI for targets:', targets.length);\r\n\r\n    const baseReq = this.buildAIRequestComplex(scene, previousScenes, targets, summary) as any;\r\n    const enriched = enrichAnalysisRequest(baseReq, {\r\n      scene,\r\n      detectorType: 'plot',\r\n      flags: { critical: Boolean((scene as any)?.critical) },\r\n    });\r\n\r\n    try {\r\n      const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n      const mapped = this.mapAIPlotResponse({ issues }, targets, scene.text, summary);\r\n      console.debug('[PlotContextDetector] AI returned plot issues:', mapped.length);\r\n      return mapped;\r\n    } catch (err) {\r\n      console.debug('[PlotContextDetector] AI analyzeContinuity failed; degrading to local-only.', err);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ---- Local helper methods (keep small) ----\r\n  private async prepareDoc(text: string): Promise<any | null> {\r\n    try {\r\n      const doc = await this.safeNLP(text);\r\n      if (!doc) console.debug('[PlotContextDetector] NLP failed, using regex fallback.');\r\n      return doc;\r\n    } catch {\r\n      console.debug('[PlotContextDetector] NLP failed, using regex fallback.');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private collectObservations(\r\n    text: string,\r\n    sentences: SentenceSpan[],\r\n    registry: PreviousPlotRegistry,\r\n    doc: any | null\r\n  ): { observations: PlotObservation[]; eventObs: PlotObservation[]; worldObs: PlotObservation[]; causalObs: PlotObservation[] } {\r\n    const eventObs = extractEventMentions(text, sentences);\r\n    const worldObs = extractWorldEntitiesCurrent(text, sentences, registry, doc);\r\n    const causalObs = extractCausalConnectors(text, sentences);\r\n    return { observations: [...eventObs, ...worldObs, ...causalObs], eventObs, worldObs, causalObs };\r\n  }\r\n\r\n  private buildIssuesAndTargets(\r\n    sceneText: string,\r\n    sentences: SentenceSpan[],\r\n    observations: PlotObservation[],\r\n    registry: PreviousPlotRegistry,\r\n    eventObs: PlotObservation[],\r\n    _worldObs: PlotObservation[],\r\n    causalObs: PlotObservation[]\r\n  ): { issues: ContinuityIssue[]; targets: PlotDetectionTarget[] } {\r\n    const issues: ContinuityIssue[] = generateImmediateIssues(observations, registry);\r\n    for (const o of causalObs) {\r\n      const knownCausal = registry.causal.length > 0;\r\n      if (o.sentenceIndex > 0 && !hasRecentCause(o.sentenceIndex, observations, sentences) && !knownCausal) {\r\n        issues.push({\r\n          type: 'plot',\r\n          severity: 'should-fix',\r\n          description: `Causal gap: \"${o.markerText}\" lacks a stated prior cause.`,\r\n          textSpan: [o.start, o.end],\r\n        });\r\n      }\r\n    }\r\n    const targets = assemblePlotDetectionTargets(observations, registry, sceneText);\r\n    // Opening forward refs are must-fix already; keep detection targets only for ambiguous contexts\r\n    return { issues, targets };\r\n  }\r\n\r\n  // ---- AI helpers (kept small and mock-friendly) ----\r\n  private buildAIRequestComplex(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    targets: readonly PlotDetectionTarget[],\r\n    registrySummary: string[]\r\n  ) {\r\n    const headerLines = [\r\n      '[[Plot detection targets]]',\r\n      ...targets.slice(0, 6).map(c => {\r\n        const sent = (c.sentenceText || '').slice(0, 180);\r\n        return `- marker:\"${c.markerText}\" @[${c.span[0]},${c.span[1]}] | sent:\"${sent}\" | cues:${c.otherCues.slice(0, 6).join(', ')}`;\r\n      }),\r\n      '[[Previous registry]]',\r\n      registrySummary.slice(0, 8).join(' | '),\r\n      '[[Scene excerpts]]',\r\n    ];\r\n    const header = headerLines.join('\\n');\r\n \r\n    // Truncate scene near first detection target (~1200 around markers)\r\n    const first = targets[0]?.span ?? [0, 0];\r\n    const excerpt = contextSnippet(scene.text, first[0], first[1], 600);\r\n    const prevExcerpt = previousScenes.length > 0 ? (previousScenes[previousScenes.length - 1].text || '').slice(0, 800) : '';\r\n \r\n    const sceneForAI: Scene = { ...scene, text: `${header}\\n\\n${excerpt}\\n\\n[[Prev]]\\n${prevExcerpt}` };\r\n    const readerContext: ReaderKnowledge = {\r\n      knownCharacters: new Set<string>(),\r\n      establishedTimeline: [],\r\n      revealedPlotPoints: [],\r\n      establishedSettings: [],\r\n    };\r\n    return {\r\n      scene: sceneForAI,\r\n      previousScenes: previousScenes.slice(-1),\r\n      analysisType: 'complex' as const,\r\n      readerContext,\r\n    };\r\n  }\r\n\r\n  private mapAIPlotResponse(\r\n    resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n    targets: readonly PlotDetectionTarget[],\r\n    sceneText: string,\r\n    registrySummary: string[]\r\n  ): ContinuityIssue[] {\r\n    const targetKeys = new Map<string, PlotDetectionTarget>();\r\n    for (const c of targets) targetKeys.set(`${c.span[0]}|${c.span[1]}`, c);\r\n \r\n    const out: ContinuityIssue[] = [];\r\n    for (const it of resp?.issues ?? []) {\r\n      const type = it.type ?? 'plot';\r\n      if (type !== 'plot') continue;\r\n      const [s, e] = it.textSpan ?? [NaN, NaN];\r\n      if (!Number.isFinite(s) || !Number.isFinite(e) || s >= e) {\r\n        const c = targets[0];\r\n        out.push({\r\n          type: 'plot',\r\n          severity: it.severity ?? 'should-fix',\r\n          description: (it.description ?? 'Plot/context issue') + (c ? ` [marker:\"${c.markerText}\" reg:${registrySummary.slice(0, 4).join(', ')}]` : ''),\r\n          textSpan: c ? c.span : [0, Math.min(1, sceneText.length)],\r\n          suggestedFix: it.suggestedFix,\r\n        });\r\n      } else {\r\n        const key = `${s}|${e}`;\r\n        const c = targetKeys.get(key);\r\n        out.push({\r\n          type: 'plot',\r\n          severity: it.severity ?? 'should-fix',\r\n          description: (it.description ?? 'Plot/context issue') + (c ? ` [marker:\"${c.markerText}\" reg:${registrySummary.slice(0, 4).join(', ')}]` : ''),\r\n          textSpan: [s, e],\r\n          suggestedFix: it.suggestedFix,\r\n        });\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\PronounDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3049,3052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3049,3052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5232,5235],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5232,5235],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":370,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12904,12907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12904,12907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":373,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":373,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13001,13004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13001,13004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":376,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":376,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13117,13120],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13117,13120],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":377,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":377,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13162,13165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13162,13165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\n/**\r\n * Hybrid pronoun continuity detector:\r\n * - Local heuristics via compromise.js (with safe fallbacks)\r\n * - Selective AI validation for ambiguous cases\r\n */\r\n\r\n// ---------- Internal types (exported for tests) ----------\r\nexport interface SentenceInfo {\r\n  text: string;\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\nexport interface PronounInstance {\r\n  pronoun: string;\r\n  start: number;\r\n  end: number;\r\n  sentenceIndex: number;\r\n}\r\n\r\nexport interface PronounDetectionTarget {\r\n  pronoun: string;\r\n  sentenceText: string;\r\n  context: string;\r\n  antecedents: string[];\r\n  span: [number, number];\r\n  sentenceIndex: number;\r\n}\r\n\r\n// Pronouns considered (exclude first-person to avoid false flags)\r\nconst PRONOUNS = [\r\n  'he','she','him','her','his','hers',\r\n  'they','them','their','theirs',\r\n  'it','its',\r\n  'this','that','these','those'\r\n];\r\nconst THEY_GROUP = new Set(['they','them','their','theirs']);\r\n\r\n// Cache of previous scene people by signature of scene ids\r\nconst prevPeopleCache: Map<string, string[]> = new Map();\r\n\r\n// ---------- Small, pure helpers (exported for tests) ----------\r\nexport function splitSentences(text: string): SentenceInfo[] {\r\n  const out: SentenceInfo[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      out.push({ text: text.slice(m.index, m.index + m[0].length).trim(), start: m.index, end: m.index + m[0].length });\r\n    }\r\n  } catch {\r\n    // no-op\r\n  }\r\n  if (out.length === 0) out.push({ text, start: 0, end: text.length });\r\n  return out;\r\n}\r\n\r\nexport function findPronouns(text: string, sentences: SentenceInfo[]): PronounInstance[] {\r\n  const list: PronounInstance[] = [];\r\n  const re = new RegExp(`\\\\b(${PRONOUNS.join('|')})\\\\b`, 'gi');\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text)) !== null) {\r\n    const start = m.index;\r\n    const end = start + m[0].length;\r\n    let si = sentences.findIndex(s => start >= s.start && start < s.end);\r\n    if (si < 0) si = 0;\r\n    list.push({ pronoun: m[0].toLowerCase(), start, end, sentenceIndex: si });\r\n  }\r\n  return list;\r\n}\r\n\r\nexport function tokenIndexAtOffset(text: string, offset: number): number {\r\n  const re = /\\b[\\w']+\\b/g;\r\n  let idx = 0;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text)) !== null) {\r\n    if (m.index >= offset) return idx;\r\n    idx++;\r\n  }\r\n  return idx;\r\n}\r\n\r\nexport function contextSnippet(text: string, start: number, end: number, radius = 100): string {\r\n  const s = Math.max(0, start - radius);\r\n  const e = Math.min(text.length, end + radius);\r\n  return text.slice(s, e).trim();\r\n}\r\n\r\nexport function extractPeopleNames(text: string, nlpDoc?: any): string[] {\r\n  const names = new Set<string>();\r\n  try {\r\n    if (nlpDoc && typeof nlpDoc.people === 'function') {\r\n      const arr: string[] = nlpDoc.people().out('array') ?? [];\r\n      for (const n of arr) if (n && typeof n === 'string') names.add(n.trim());\r\n    } else {\r\n      const re = /\\b([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)\\b/g;\r\n      let m: RegExpExecArray | null;\r\n      while ((m = re.exec(text)) !== null) names.add(m[1]);\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  return Array.from(names);\r\n}\r\n\r\nexport function extractNearbyProperNouns(text: string, sentences: SentenceInfo[], si: number): string[] {\r\n  const startIdx = Math.max(0, si - 2);\r\n  const endIdx = Math.min(sentences.length - 1, si + 2);\r\n  const spanStart = sentences[startIdx].start;\r\n  const spanEnd = sentences[endIdx].end;\r\n  const seg = text.slice(spanStart, spanEnd);\r\n  const set = new Set<string>();\r\n  const re = /\\b([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)\\b/g;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(seg)) !== null) set.add(m[1]);\r\n  return Array.from(set);\r\n}\r\n\r\nexport function previousScenesSignature(previous: readonly Scene[]): string {\r\n  return previous.map(s => s.id).join('|');\r\n}\r\n\r\nexport function getOrBuildPreviousPeople(previous: readonly Scene[], signature: string): string[] {\r\n  const cached = prevPeopleCache.get(signature);\r\n  if (cached) return cached;\r\n  const set = new Set<string>();\r\n  for (const sc of previous) {\r\n    for (const n of extractPeopleNames(sc.text)) set.add(n);\r\n  }\r\n  const arr = Array.from(set);\r\n  prevPeopleCache.set(signature, arr);\r\n  return arr;\r\n}\r\n\r\nexport function dedupeNormalize(names: readonly string[]): string[] {\r\n  const norm = new Set<string>();\r\n  for (const n of names) {\r\n    const t = n.trim();\r\n    if (!t) continue;\r\n    norm.add(t);\r\n  }\r\n  return Array.from(norm);\r\n}\r\n\r\nexport function buildReaderContext(known: readonly string[]): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(known),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\n// Compromise-assisted hinting (words only; offsets found via regex)\r\nexport function collectPronounHints(nlpDoc: any): string[] {\r\n  try {\r\n    if (nlpDoc && typeof nlpDoc.match === 'function') {\r\n      const arr: string[] = nlpDoc.match('#Pronoun').out('array') ?? [];\r\n      return Array.isArray(arr) ? arr : [];\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  return [];\r\n}\r\n\r\n// Aggregate local issues/targets\r\nexport function analyzeLocalPronouns(\r\n  sceneText: string,\r\n  sentences: SentenceInfo[],\r\n  pronouns: PronounInstance[],\r\n  currentPeople: string[],\r\n  previousPeople: string[]\r\n): { issues: ContinuityIssue[]; targets: PronounDetectionTarget[] } {\r\n  const issues: ContinuityIssue[] = [];\r\n  const targets: PronounDetectionTarget[] = [];\r\n  for (const p of pronouns) {\r\n    const res = assessPronounInstance(p, sceneText, sentences, currentPeople, previousPeople);\r\n    if (res.issues.length) issues.push(...res.issues);\r\n    if (res.target) targets.push(res.target);\r\n  }\r\n  return { issues, targets };\r\n}\r\n\r\n// Per-pronoun assessment\r\nexport function assessPronounInstance(\r\n  p: PronounInstance,\r\n  sceneText: string,\r\n  sentences: SentenceInfo[],\r\n  currentPeople: string[],\r\n  previousPeople: string[]\r\n): { issues: ContinuityIssue[]; target?: PronounDetectionTarget } {\r\n  const issues: ContinuityIssue[] = [];\r\n  const isOpening = p.sentenceIndex === 0;\r\n  const tokenIdx = tokenIndexAtOffset(sceneText, p.start);\r\n  const near = extractNearbyProperNouns(sceneText, sentences, p.sentenceIndex);\r\n  const plausibleLocal = dedupeNormalize([...near, ...currentPeople]);\r\n  const hasLocal = plausibleLocal.length > 0;\r\n  const hasPrev = previousPeople.length > 0;\r\n\r\n  if (isOpening && !hasLocal && !hasPrev) {\r\n    issues.push({\r\n      type: 'pronoun',\r\n      severity: 'must-fix',\r\n      description: `Opening sentence uses pronoun \"${p.pronoun}\" without a clear antecedent.`,\r\n      textSpan: [p.start, p.end],\r\n    });\r\n    return { issues };\r\n  }\r\n\r\n  if (tokenIdx < 25 && !hasLocal) {\r\n    issues.push({\r\n      type: 'pronoun',\r\n      severity: 'should-fix',\r\n      description: `Early pronoun \"${p.pronoun}\" lacks a nearby antecedent.`,\r\n      textSpan: [p.start, p.end],\r\n    });\r\n  }\r\n\r\n  const ambiguousLocal = plausibleLocal.length >= 2;\r\n  const groupAmbiguity = THEY_GROUP.has(p.pronoun) && (plausibleLocal.length + previousPeople.length) >= 2;\r\n  if (ambiguousLocal || groupAmbiguity) {\r\n    const si = Math.max(0, Math.min(p.sentenceIndex, sentences.length - 1));\r\n    return {\r\n      issues,\r\n      target: {\r\n        pronoun: p.pronoun,\r\n        sentenceText: sentences[si]?.text ?? '',\r\n        context: contextSnippet(sceneText, p.start, p.end),\r\n        antecedents: dedupeNormalize([...plausibleLocal, ...previousPeople]),\r\n        span: [p.start, p.end],\r\n        sentenceIndex: si,\r\n      },\r\n    };\r\n  }\r\n  return { issues };\r\n}\r\n\r\n// Known-people assembly\r\nexport function assembleKnownPeople(previousScenes: readonly Scene[], sceneText: string): string[] {\r\n  const sig = previousScenesSignature(previousScenes);\r\n  const previousPeople = getOrBuildPreviousPeople(previousScenes, sig);\r\n  const currentPeople = extractPeopleNames(sceneText);\r\n  return dedupeNormalize([...previousPeople, ...currentPeople]);\r\n}\r\n\r\n// Compose compact AI scene text including detection targets (bounded)\r\nexport function buildAIText(original: string, targets: readonly PronounDetectionTarget[], maxTargets = 6): string {\r\n  const chosen = targets.slice(0, maxTargets);\r\n  const headerLines = [\r\n    '[[Pronoun detection targets]]',\r\n    ...chosen.map(c => {\r\n      const ant = c.antecedents.slice(0, 6).join(', ') || 'none';\r\n      const sent = (c.sentenceText || '').slice(0, 160);\r\n      return `- \"${c.pronoun}\" @ [${c.span[0]},${c.span[1]}] | sentence: \"${sent}\" | antecedents: ${ant}`;\r\n    }),\r\n    '[[Scene]]',\r\n  ];\r\n  const header = headerLines.join('\\n');\r\n  return `${header}\\n\\n${original}`;\r\n}\r\n\r\n// Build AI request with detection target summary embedded into scene.text\r\nexport function buildAIRequest(\r\n  scene: Scene,\r\n  prevForAI: readonly Scene[],\r\n  targets: readonly PronounDetectionTarget[],\r\n  known: readonly string[]\r\n) {\r\n  const sceneForAI: Scene = { ...scene, text: buildAIText(scene.text, targets) };\r\n  return {\r\n    scene: sceneForAI,\r\n    previousScenes: prevForAI as Scene[],\r\n    analysisType: 'simple' as const,\r\n    readerContext: buildReaderContext(known),\r\n  };\r\n}\r\n\r\n// Map AI response back to ContinuityIssue[], filtered to known targets when spans are present\r\nexport function mapAIResponseToIssues(\r\n  resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n  sceneText: string,\r\n  targets: readonly PronounDetectionTarget[]\r\n): ContinuityIssue[] {\r\n  const targetKeys = new Set(targets.map(c => `${c.span[0]}|${c.span[1]}`));\r\n  const out: ContinuityIssue[] = [];\r\n  for (const it of resp?.issues ?? []) {\r\n    const type = it.type ?? 'pronoun';\r\n    if (type !== 'pronoun') continue;\r\n    const [s, e] = it.textSpan ?? [NaN, NaN];\r\n    if (!Number.isFinite(s) || !Number.isFinite(e) || s >= e) {\r\n      out.push({\r\n        type: 'pronoun',\r\n        severity: it.severity ?? 'should-fix',\r\n        description: it.description ?? 'Pronoun ambiguity detected',\r\n        textSpan: it.textSpan ?? [0, Math.min(1, sceneText.length)],\r\n        suggestedFix: it.suggestedFix,\r\n      });\r\n    } else if (targetKeys.has(`${s}|${e}`)) {\r\n      out.push({\r\n        type: 'pronoun',\r\n        severity: it.severity ?? 'should-fix',\r\n        description: it.description ?? 'Pronoun ambiguity detected',\r\n        textSpan: [s, e],\r\n        suggestedFix: it.suggestedFix,\r\n      });\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\n// ---------- Detector implementation ----------\r\nexport default class PronounDetector extends BaseDetector<PronounDetectionTarget> {\r\n  public readonly detectorType = 'pronoun' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<PronounDetectionTarget>> {\r\n    if (!scene?.text || typeof scene.text !== 'string' || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n\r\n    const doc = await this.safeNLP(scene.text);\r\n    const sentences = splitSentences(scene.text);\r\n    const pronouns = findPronouns(scene.text, sentences);\r\n    const currentPeople = extractPeopleNames(scene.text, doc);\r\n    const sig = previousScenesSignature(previousScenes);\r\n    const previousPeople = getOrBuildPreviousPeople(previousScenes, sig);\r\n\r\n    const hints = doc ? collectPronounHints(doc) : [];\r\n    console.debug('[PronounDetector] pronouns found:', pronouns.length, 'compromise hints:', hints.length);\r\n\r\n    const { issues, targets } = analyzeLocalPronouns(\r\n      scene.text,\r\n      sentences,\r\n      pronouns,\r\n      currentPeople,\r\n      previousPeople\r\n    );\r\n\r\n    console.debug('[PronounDetector] local issues:', issues.length, 'targets:', targets.length);\r\n    return {\r\n      issues,\r\n      requiresAI: targets.length > 0,\r\n      targets,\r\n      stats: { pronouns: pronouns.length },\r\n    };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly PronounDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n\r\n    const known = assembleKnownPeople(previousScenes, scene.text);\r\n    const prevForAI = previousScenes.slice(-2).map(s => ({ ...s, text: s.text?.slice(0, 600) ?? '' }));\r\n\r\n    console.debug('[PronounDetector] invoking AI for targets:', targets.length);\r\n    const baseReq = buildAIRequest(scene, prevForAI, targets, known);\r\n    const enriched = enrichAnalysisRequest(baseReq as any, {\r\n      scene,\r\n      detectorType: 'pronoun',\r\n      flags: { critical: Boolean((scene as any)?.critical) },\r\n    });\r\n\r\n    const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n      critical: Boolean((enriched as any)?.flags?.critical),\r\n      consensusCount: 2,\r\n      acceptThreshold: 0.5,\r\n      humanReviewThreshold: 0.9,\r\n      maxModels: 2,\r\n    });\r\n\r\n    const out = mapAIResponseToIssues({ issues }, scene.text, targets);\r\n    console.debug('[PronounDetector] AI returned pronoun issues:', out.length);\r\n    return out;\r\n  }\r\n\r\n  // Mock-friendly indirection for AI calls\r\n  protected async aiAnalyzeSimple(\r\n    aiManager: AIServiceManager,\r\n    req: Parameters<AIServiceManager['analyzeContinuity']>[0]\r\n  ) {\r\n    try {\r\n      return await aiManager.analyzeContinuity(req);\r\n    } catch (err) {\r\n      console.debug('[PronounDetector] AI analyzeContinuity failed; degrading to local-only.', err);\r\n      return { issues: [], metadata: { modelUsed: 'none', provider: 'openai', costEstimate: 0, durationMs: 0, confidence: 0, cached: false } };\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\detectors\\TimelineDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6815,6818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6815,6818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6993,6996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6993,6996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8224,8227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8224,8227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sceneText' is defined but never used. Allowed unused args must match /^_/u.","line":372,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":372,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":596,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":596,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24481,24484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24481,24484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":599,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":599,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24585,24588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24585,24588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":603,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":603,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24804,24807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24804,24807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":604,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":604,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24851,24854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24851,24854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport { enrichAnalysisRequest, runAnalysisWithOptionalConsensus } from '../../../../services/ai/consensus/ConsensusAdapter';\r\nimport BaseDetector, { LocalDetectionResult } from './BaseDetector';\r\n\r\n// ---------- Types (exported testing hooks) ----------\r\nexport interface SentenceSpan { text: string; start: number; end: number }\r\n\r\nexport interface BasicMarker {\r\n  text: string;\r\n  start: number;\r\n  end: number;\r\n  sentenceIndex: number;\r\n}\r\n\r\ntype MarkerCategory =\r\n  | 'relative'\r\n  | 'absolute'\r\n  | 'time'\r\n  | 'season'\r\n  | 'weekday'\r\n  | 'holiday'\r\n  | 'sequence'\r\n  | 'month';\r\n\r\ninterface TemporalMarker extends BasicMarker {\r\n  category: MarkerCategory;\r\n  normalized?: string;\r\n  deltaDays?: number | null;\r\n  anchor?: 'morning' | 'afternoon' | 'evening' | 'night' | 'day';\r\n}\r\n\r\nexport interface PreviousTimelineRegistry {\r\n  lastAnchor: string | null;\r\n  lastDayOffset: number | null; // approximate cumulative day offset\r\n  seasons: Set<string>; // e.g., winter, summer\r\n  months: Set<string>; // e.g., january\r\n  recentSequences: string[]; // e.g., then, after that\r\n  hasMeanwhile: boolean;\r\n}\r\n\r\nexport interface TimelineDetectionTarget {\r\n  markerText: string;\r\n  sentenceText: string;\r\n  context: string;\r\n  start: number;\r\n  end: number;\r\n  prevSummary: { lastAnchor: string | null; lastDayOffset: number | null; seasons: string[]; months: string[] };\r\n  otherMarkers: string[];\r\n  sentenceIndex: number;\r\n}\r\n\r\n// ---------- Constants ----------\r\nconst MONTHS = [\r\n  'january','february','march','april','may','june','july','august','september','october','november','december'\r\n];\r\nconst WEEKDAYS = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];\r\nconst SEASONS = ['spring','summer','fall','autumn','winter'];\r\nconst HOLIDAYS = ['christmas','new year','new year\\'s','easter','thanksgiving','halloween','hanukkah','ramadan','diwali'];\r\nconst TIME_OF_DAY = ['dawn','morning','noon','afternoon','dusk','evening','midnight','night','tonight'];\r\nconst SEQUENCE_TERMS = ['then','after that','later that day','soon after','meanwhile','at the same time','moments later'];\r\n\r\nconst RELATIVE_TERMS = [\r\n  'next day','the following day','tomorrow','yesterday','earlier that day','that night','tonight',\r\n  'the previous night','next morning','this morning','last night','later that day'\r\n];\r\n\r\nconst WEATHER_SEASONAL = ['snow','blizzard','sleet','heatwave','scorching','sweltering','icy','frost','hail'];\r\n\r\n// ---------- Module cache ----------\r\nconst registryCache: Map<string, PreviousTimelineRegistry> = new Map();\r\n\r\n// ---------- Small utilities (&#x2264; 40 lines) ----------\r\nfunction sig(previous: readonly Scene[]): string {\r\n  return previous.map(s => s.id).join('|');\r\n}\r\n\r\nfunction clamp(n: number, a: number, b: number): number {\r\n  return Math.max(a, Math.min(b, n));\r\n}\r\n\r\nfunction snippet(text: string, start: number, end: number, r = 120): string {\r\n  const s = clamp(start - r, 0, text.length);\r\n  const e = clamp(end + r, 0, text.length);\r\n  return text.slice(s, e).trim();\r\n}\r\n\r\nfunction monthToSeason(month: string): string | null {\r\n  const m = month.toLowerCase();\r\n  if (['december','january','february'].includes(m)) return 'winter';\r\n  if (['march','april','may'].includes(m)) return 'spring';\r\n  if (['june','july','august'].includes(m)) return 'summer';\r\n  if (['september','october','november'].includes(m)) return 'fall';\r\n  return null;\r\n}\r\n\r\nexport function computeRelativeDelta(phrase: string): number | null {\r\n  const low = phrase.toLowerCase();\r\n  const numMatch = /(\\d+)\\s+(day|week|month|year)s?\\s+(later|earlier|before|after)/i.exec(low);\r\n  if (numMatch) {\r\n    const n = parseInt(numMatch[1], 10);\r\n    const unit = numMatch[2];\r\n    const dir = numMatch[3];\r\n    const mult = unit === 'day' ? 1 : unit === 'week' ? 7 : unit === 'month' ? 30 : 365;\r\n    const sign = (dir === 'later' || dir === 'after') ? 1 : -1;\r\n    return sign * n * mult;\r\n  }\r\n  if (/\\b(next day|the following day|tomorrow|next morning)\\b/i.test(low)) return 1;\r\n  if (/\\b(previous day|yesterday|the previous night|last night)\\b/i.test(low)) return -1;\r\n  if (/\\b(earlier that day|that night|tonight|this morning|later that day)\\b/i.test(low)) return 0;\r\n  return null;\r\n}\r\n\r\nfunction anchorFromPhrase(phrase: string): TemporalMarker['anchor'] | undefined {\r\n  const low = phrase.toLowerCase();\r\n  if (low.includes('morning') || low.includes('dawn') || low.includes('this morning') || low.includes('next morning')) return 'morning';\r\n  if (low.includes('afternoon') || low.includes('noon')) return 'afternoon';\r\n  if (low.includes('evening') || low.includes('dusk')) return 'evening';\r\n  if (low.includes('night') || low.includes('midnight') || low.includes('tonight') || low.includes('last night')) return 'night';\r\n  return undefined;\r\n}\r\n\r\nexport function splitSentences(text: string): SentenceSpan[] {\r\n  const spans: SentenceSpan[] = [];\r\n  try {\r\n    const re = /[^.!?]+(?:[.!?]+|\\n+|$)/g;\r\n    let m: RegExpExecArray | null;\r\n    while ((m = re.exec(text)) !== null) {\r\n      const raw = text.slice(m.index, m.index + m[0].length);\r\n      spans.push({ text: raw.trim(), start: m.index, end: m.index + m[0].length });\r\n    }\r\n  } catch { /* noop */ }\r\n  if (spans.length === 0) spans.push({ text: text, start: 0, end: text.length });\r\n  return spans;\r\n}\r\n\r\nfunction sentenceIndexFor(pos: number, sentences: readonly SentenceSpan[]): number {\r\n  let lo = 0, hi = sentences.length - 1, ans = 0;\r\n  while (lo <= hi) {\r\n    const mid = (lo + hi) >> 1;\r\n    const s = sentences[mid];\r\n    if (pos < s.start) hi = mid - 1;\r\n    else if (pos >= s.end) lo = mid + 1;\r\n    else { ans = mid; break; }\r\n  }\r\n  return ans;\r\n}\r\n\r\n// ---------- Marker extraction (compromise + regex) ----------\r\nfunction pushMatch(\r\n  arr: TemporalMarker[],\r\n  text: string,\r\n  start: number,\r\n  end: number,\r\n  sentences: readonly SentenceSpan[],\r\n  category: MarkerCategory\r\n): void {\r\n  const si = sentenceIndexFor(start, sentences);\r\n  const phrase = text.slice(start, end);\r\n  arr.push({\r\n    text: phrase,\r\n    start,\r\n    end,\r\n    sentenceIndex: si,\r\n    category,\r\n    deltaDays: category === 'relative' ? computeRelativeDelta(phrase) : null,\r\n    anchor: category === 'relative' || category === 'time' ? anchorFromPhrase(phrase) : undefined,\r\n  });\r\n}\r\n\r\nfunction regexFindAll(text: string, re: RegExp, sentences: readonly SentenceSpan[], cat: MarkerCategory, out: TemporalMarker[]) {\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text)) !== null) {\r\n    const s = m.index;\r\n    const e = s + m[0].length;\r\n    pushMatch(out, text, s, e, sentences, cat);\r\n  }\r\n}\r\n\r\nfunction extractWithCompromise(doc: any | null, text: string, sentences: readonly SentenceSpan[]): TemporalMarker[] {\r\n  const out: TemporalMarker[] = [];\r\n  if (!doc) return out;\r\n  try {\r\n    const toArr = (sel: any): string[] => (sel && typeof sel.out === 'function') ? (sel.out('array') ?? []) : [];\r\n    const datePhrases: string[] = toArr(doc.match ? doc.match('#Date') : null).concat(toArr(doc.dates ? doc.dates() : null));\r\n    const timePhrases: string[] = toArr(doc.match ? doc.match('#Time') : null);\r\n    const seen = new Set<string>();\r\n    const addStrings = (phrases: string[], cat: MarkerCategory) => {\r\n      for (const p of phrases) {\r\n        const phrase = (p || '').toString().trim();\r\n        if (!phrase) continue;\r\n        if (seen.has(`${cat}|${phrase}`)) continue;\r\n        seen.add(`${cat}|${phrase}`);\r\n        // search within each sentence to avoid duping earlier matches\r\n        for (const s of sentences) {\r\n          const relIdx = s.text.indexOf(phrase);\r\n          if (relIdx >= 0) {\r\n            const start = s.start + relIdx;\r\n            const end = start + phrase.length;\r\n            pushMatch(out, text, start, end, sentences, cat);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    addStrings(datePhrases, 'absolute');\r\n    addStrings(timePhrases, 'time');\r\n    return out;\r\n  } catch {\r\n    return out;\r\n  }\r\n}\r\n\r\nexport function extractTemporalMarkers(\r\n  sceneText: string,\r\n  doc: any | null = null\r\n): { markers: BasicMarker[]; sentences: SentenceSpan[] } {\r\n  if (!sceneText || typeof sceneText !== 'string') return { markers: [], sentences: [{ text: '', start: 0, end: 0 }] };\r\n  const sentences = splitSentences(sceneText);\r\n  const tmp: TemporalMarker[] = [];\r\n  // Compromise-based\r\n  const comp = extractWithCompromise(doc, sceneText, sentences);\r\n  tmp.push(...comp);\r\n  // Regex-based relative amounts\r\n  regexFindAll(sceneText, /\\b(\\d+)\\s+(?:day|week|month|year)s?\\s+(?:later|earlier|before|after)\\b/gi, sentences, 'relative', tmp);\r\n  // Simple relative terms\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + RELATIVE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'relative', tmp);\r\n  // Sequence terms\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + SEQUENCE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'sequence', tmp);\r\n  // Absolute months, weekdays, seasons, holidays, time-of-day, weather\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + MONTHS.join('|') + ')\\\\b', 'gi'), sentences, 'month', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + WEEKDAYS.join('|') + ')\\\\b', 'gi'), sentences, 'weekday', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + SEASONS.join('|') + ')\\\\b', 'gi'), sentences, 'season', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + HOLIDAYS.join('|') + ')\\\\b', 'gi'), sentences, 'holiday', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + TIME_OF_DAY.join('|') + ')\\\\b', 'gi'), sentences, 'time', tmp);\r\n  regexFindAll(sceneText, new RegExp('\\\\b(?:' + WEATHER_SEASONAL.join('|') + ')\\\\b', 'gi'), sentences, 'season', tmp);\r\n  // Return as BasicMarker list (testing contract)\r\n  const basics: BasicMarker[] = tmp.map(m => ({ text: m.text, start: m.start, end: m.end, sentenceIndex: m.sentenceIndex }));\r\n  return { markers: basics, sentences };\r\n}\r\n\r\n// ---------- Previous registry builder + caching ----------\r\nfunction getOrBuildRegistry(previous: readonly Scene[]): PreviousTimelineRegistry {\r\n  const s = sig(previous);\r\n  const c = registryCache.get(s);\r\n  if (c) return c;\r\n  const reg = buildPreviousTimelineRegistry(previous);\r\n  registryCache.set(s, reg);\r\n  return reg;\r\n}\r\n\r\nexport function buildPreviousTimelineRegistry(previousScenes: readonly Scene[]): PreviousTimelineRegistry {\r\n  const seasons = new Set<string>();\r\n  const months = new Set<string>();\r\n  const recentSequences: string[] = [];\r\n  let lastAnchor: string | null = null;\r\n  let cumOffset = 0;\r\n  let hasMeanwhile = false;\r\n\r\n  for (const sc of previousScenes) {\r\n    const text = sc.text ?? '';\r\n    const sentences = splitSentences(text);\r\n    const markers = extractWithCompromise(null, text, sentences);\r\n    // Regex fallback markers too\r\n    const all: TemporalMarker[] = [];\r\n    all.push(...markers);\r\n    regexFindAll(text, /\\b(\\d+)\\s+(?:day|week|month|year)s?\\s+(?:later|earlier|before|after)\\b/gi, sentences, 'relative', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + RELATIVE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'relative', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + SEQUENCE_TERMS.join('|').replace(/ /g, '\\\\s+') + ')\\\\b', 'gi'), sentences, 'sequence', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + MONTHS.join('|') + ')\\\\b', 'gi'), sentences, 'month', all);\r\n    regexFindAll(text, new RegExp('\\\\b(?:' + SEASONS.join('|') + ')\\\\b', 'gi'), sentences, 'season', all);\r\n    for (const m of all) {\r\n      if (m.category === 'relative' && m.deltaDays != null) {\r\n        cumOffset += m.deltaDays;\r\n        if (m.anchor) lastAnchor = m.anchor;\r\n      }\r\n      if (m.category === 'time' && m.anchor) lastAnchor = m.anchor;\r\n      if (m.category === 'season') seasons.add(m.text.toLowerCase().replace('autumn', 'fall'));\r\n      if (m.category === 'month') {\r\n        const mon = m.text.toLowerCase();\r\n        months.add(mon);\r\n        const seas = monthToSeason(mon);\r\n        if (seas) seasons.add(seas);\r\n      }\r\n      if (m.category === 'sequence') {\r\n        const low = m.text.toLowerCase();\r\n        recentSequences.push(low);\r\n        if (low.includes('meanwhile') || low.includes('at the same time')) hasMeanwhile = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    lastAnchor,\r\n    lastDayOffset: Number.isNaN(cumOffset) ? null : cumOffset,\r\n    seasons,\r\n    months,\r\n    recentSequences: recentSequences.slice(-20),\r\n    hasMeanwhile,\r\n  };\r\n}\r\n\r\n// ---------- Detection target assembly (exported) ----------\r\nexport function assembleTimelineDetectionTargets(\r\n  markers: readonly BasicMarker[],\r\n  sceneText: string,\r\n  sentences: readonly SentenceSpan[],\r\n  reg: PreviousTimelineRegistry\r\n): TimelineDetectionTarget[] {\r\n  const lowMarkers = markers.map(m => ({ ...m, low: m.text.toLowerCase() }));\r\n  const otherTexts = (skipIdx: number) =>\r\n    lowMarkers.filter((_, i) => i !== skipIdx).slice(0, 6).map(mm => mm.text);\r\n\r\n  const targets: TimelineDetectionTarget[] = [];\r\n  const hasMeanwhile = lowMarkers.some(m => m.low.includes('meanwhile') || m.low.includes('at the same time'));\r\n  const relativeCount = lowMarkers.filter(m => /\\b(day|week|month|year|morning|night|yesterday|tomorrow|earlier|later)\\b/.test(m.low)).length;\r\n\r\n  for (let i = 0; i < lowMarkers.length; i++) {\r\n    const m = lowMarkers[i];\r\n    const isAmbiguousSeason =\r\n      (SEASONS.some(s => m.low.includes(s)) && reg.months.size > 0) ||\r\n      (MONTHS.some(mon => m.low.includes(mon)) && reg.seasons.size > 0);\r\n\r\n    const triggers =\r\n      hasMeanwhile ||\r\n      relativeCount >= 2 ||\r\n      isAmbiguousSeason ||\r\n      /\\bearlier that day\\b/.test(m.low);\r\n\r\n    if (!triggers) continue;\r\n\r\n    const sent = sentences[m.sentenceIndex]?.text ?? '';\r\n    targets.push({\r\n      markerText: m.text,\r\n      sentenceText: sent,\r\n      context: snippet(sceneText, m.start, m.end),\r\n      start: m.start,\r\n      end: m.end,\r\n      prevSummary: {\r\n        lastAnchor: reg.lastAnchor,\r\n        lastDayOffset: reg.lastDayOffset,\r\n        seasons: Array.from(reg.seasons).slice(0, 6),\r\n        months: Array.from(reg.months).slice(0, 6),\r\n      },\r\n      otherMarkers: otherTexts(i),\r\n      sentenceIndex: m.sentenceIndex,\r\n    });\r\n  }\r\n  return targets;\r\n}\r\n\r\n// ---------- Local conflict detection ----------\r\nfunction seasonBucketSet(markers: readonly BasicMarker[]): Set<string> {\r\n  const set = new Set<string>();\r\n  for (const m of markers) {\r\n    const low = m.text.toLowerCase();\r\n    for (const s of SEASONS) if (low.includes(s)) set.add(s === 'autumn' ? 'fall' : s);\r\n    for (const mon of MONTHS) if (low.includes(mon)) {\r\n      const sb = monthToSeason(mon); if (sb) set.add(sb);\r\n    }\r\n    for (const w of WEATHER_SEASONAL) if (low.includes(w)) {\r\n      if (['snow','blizzard','sleet','icy','frost','hail'].some(x => low.includes(x))) set.add('winter');\r\n      if (['heatwave','scorching','sweltering'].some(x => low.includes(x))) set.add('summer');\r\n    }\r\n  }\r\n  return set;\r\n}\r\n\r\nfunction detectTimelineIssues(\r\n  markers: readonly BasicMarker[],\r\n  reg: PreviousTimelineRegistry,\r\n  sceneText: string\r\n): ContinuityIssue[] {\r\n  const issues: ContinuityIssue[] = [];\r\n  const lowMarks = markers.map(m => ({ ...m, low: m.text.toLowerCase() }));\r\n  const hasEarlierToday = lowMarks.some(m => m.low.includes('earlier that day'));\r\n  const hasNextMorning = lowMarks.some(m => m.low.includes('next morning'));\r\n  const hasMultiDayJump = lowMarks.some(m => /(\\d+)\\s+(day|week|month|year)s?\\s+(later|after)/.test(m.low));\r\n  const curSeasons = seasonBucketSet(markers);\r\n\r\n  // Hard contradiction: \"earlier that day\" but previous indicates we're past same-day context\r\n  if (hasEarlierToday && (reg.lastDayOffset !== null && reg.lastDayOffset > 0)) {\r\n    const m = lowMarks.find(x => x.low.includes('earlier that day'))!;\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'must-fix',\r\n      description: 'Temporal rewind: \"earlier that day\" after prior scenes advanced beyond same-day.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  // Likely gap: large jump while recent threads suggest simultaneity\r\n  if (reg.hasMeanwhile && hasMultiDayJump) {\r\n    const m = lowMarks.find(x => /(\\d+)\\s+(day|week|month|year)s?\\s+(later|after)/.test(x.low))!;\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'should-fix',\r\n      description: 'Potential gap: multi-day jump despite ongoing \"meanwhile\" threads in prior scenes.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  // Soft contradiction: \"next morning\" after cumulative offset suggests longer gap context\r\n  if (hasNextMorning && (reg.lastDayOffset !== null && reg.lastDayOffset >= 2)) {\r\n    const m = lowMarks.find(x => x.low.includes('next morning'))!;\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'should-fix',\r\n      description: 'Possible misalignment: \"next morning\" but earlier scenes imply a multi-day gap.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  // Seasonal inconsistency\r\n  const prevSeasons = new Set(Array.from(reg.seasons));\r\n  const winterPrev = prevSeasons.has('winter');\r\n  const summerPrev = prevSeasons.has('summer');\r\n  const winterCur = curSeasons.has('winter');\r\n  const summerCur = curSeasons.has('summer');\r\n\r\n  if ((winterPrev && summerCur) || (summerPrev && winterCur)) {\r\n    const m = lowMarks.find(x => seasonBucketSet([x]).size > 0) ?? lowMarks[0];\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'should-fix',\r\n      description: 'Seasonal inconsistency: prior scenes indicate different season without transition.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  } else if (curSeasons.size && prevSeasons.size && Array.from(curSeasons).some(s => !prevSeasons.has(s))) {\r\n    const m = lowMarks.find(x => seasonBucketSet([x]).size > 0) ?? lowMarks[0];\r\n    issues.push({\r\n      type: 'timeline',\r\n      severity: 'consider',\r\n      description: 'Seasonal drift detected; consider adding transition context.',\r\n      textSpan: [m.start, m.end],\r\n    });\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n// ---------- AI request helpers ----------\r\nfunction buildReaderContextMinimal(): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\nfunction buildAIHeader(scene: Scene, targets: readonly TimelineDetectionTarget[], reg: PreviousTimelineRegistry): string {\r\n  const lines: string[] = [];\r\n  lines.push('[[Timeline detection targets]]');\r\n  lines.push(`scene: id=${scene.id} pos=${scene.position}`);\r\n  for (const c of targets.slice(0, 8)) {\r\n    const sent = (c.sentenceText || '').slice(0, 140).replace(/\\n+/g, ' ');\r\n    const others = c.otherMarkers.slice(0, 6).join(' | ') || 'none';\r\n    lines.push(`- marker=\"${c.markerText}\" span=[${c.start},${c.end}] sent=\"${sent}\" localMarkers=[${others}]`);\r\n  }\r\n  lines.push('[[Previous registry]]');\r\n  lines.push(`lastAnchor=${reg.lastAnchor ?? 'none'} lastDayOffset=${reg.lastDayOffset ?? 'n/a'}`);\r\n  lines.push(`seasons: ${Array.from(reg.seasons).slice(0, 8).join(' | ')}`);\r\n  lines.push(`months: ${Array.from(reg.months).slice(0, 8).join(' | ')}`);\r\n  lines.push('[[Scene excerpt]]');\r\n  return lines.join('\\n');\r\n}\r\n\r\nfunction buildSceneExcerptAroundTargets(text: string, targets: readonly TimelineDetectionTarget[], maxLen = 1200): string {\r\n  if (!targets.length) return text.slice(0, maxLen);\r\n  const parts: string[] = [];\r\n  for (const c of targets) {\r\n    parts.push(snippet(text, c.start, c.end, 220));\r\n    const len = parts.join('\\n---\\n').length;\r\n    if (len > maxLen) break;\r\n  }\r\n  return parts.join('\\n---\\n').slice(0, maxLen);\r\n}\r\n\r\nfunction mapAITimelineIssues(\r\n  resp: { issues?: ContinuityIssue[] } | null | undefined,\r\n  sceneText: string,\r\n  targets: readonly TimelineDetectionTarget[]\r\n): ContinuityIssue[] {\r\n  const out: ContinuityIssue[] = [];\r\n  const byMarker = new Map<string, TimelineDetectionTarget>();\r\n  for (const c of targets) byMarker.set(c.markerText.toLowerCase(), c);\r\n \r\n  for (const it of resp?.issues ?? []) {\r\n    if ((it.type ?? 'timeline') !== 'timeline') continue;\r\n    const hasSpan = Array.isArray(it.textSpan) && Number.isFinite(it.textSpan[0]) && Number.isFinite(it.textSpan[1]);\r\n    if (hasSpan) {\r\n      out.push({\r\n        type: 'timeline',\r\n        severity: it.severity ?? 'should-fix',\r\n        description: it.description ?? 'Timeline consistency issue',\r\n        textSpan: it.textSpan as [number, number],\r\n        suggestedFix: it.suggestedFix,\r\n      });\r\n      continue;\r\n    }\r\n    // Fallback to closest detection target by marker mention\r\n    const key = (it.description ?? '').toLowerCase();\r\n    let chosen: TimelineDetectionTarget | undefined;\r\n    for (const [mk, c] of byMarker) { if (key.includes(mk)) { chosen = c; break; } }\r\n    chosen ??= targets[0];\r\n    const span: [number, number] = chosen ? [chosen.start, chosen.end] : [0, Math.min(1, sceneText.length)];\r\n    out.push({\r\n      type: 'timeline',\r\n      severity: it.severity ?? 'should-fix',\r\n      description: it.description ?? `Timeline issue near \"${chosen?.markerText ?? 'marker'}\"`,\r\n      textSpan: span,\r\n      suggestedFix: it.suggestedFix,\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\n// ---------- Detector implementation ----------\r\nexport default class TimelineDetector extends BaseDetector<TimelineDetectionTarget> {\r\n  public readonly detectorType = 'timeline' as const;\r\n\r\n  protected async localDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    _aiManager: AIServiceManager\r\n  ): Promise<LocalDetectionResult<TimelineDetectionTarget>> {\r\n    if (!scene?.text || typeof scene.text !== 'string' || scene.text.trim().length === 0) {\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n \r\n    const doc = await this.safeNLP(scene.text);\r\n    if (!doc) console.debug('[TimelineDetector] compromise not available, using regex-only fallback.');\r\n    const sentences = splitSentences(scene.text);\r\n    const extracted = extractTemporalMarkers(scene.text, doc);\r\n    const basicMarkers = extracted.markers;\r\n    const reg = getOrBuildRegistry(previousScenes);\r\n \r\n    if (basicMarkers.length === 0 && reg.seasons.size === 0 && reg.months.size === 0 && reg.lastDayOffset === null) {\r\n      console.debug('[TimelineDetector] Fast path: no markers and empty registry.');\r\n      return { issues: [], requiresAI: false, targets: [] };\r\n    }\r\n \r\n    const issues = detectTimelineIssues(basicMarkers, reg, scene.text);\r\n    const targets = assembleTimelineDetectionTargets(basicMarkers, scene.text, sentences, reg);\r\n \r\n    console.debug(\r\n      '[TimelineDetector] markers:',\r\n      basicMarkers.length,\r\n      'issues:',\r\n      issues.length,\r\n      'targets:',\r\n      targets.length,\r\n      'reg[lastAnchor,lastDayOffset,seasons,months]:',\r\n      reg.lastAnchor,\r\n      reg.lastDayOffset,\r\n      Array.from(reg.seasons).join(','),\r\n      Array.from(reg.months).join(',')\r\n    );\r\n \r\n    return {\r\n      issues,\r\n      requiresAI: targets.length > 0,\r\n      targets,\r\n      stats: {\r\n        markers: basicMarkers.length,\r\n        seasonsCurrent: seasonBucketSet(basicMarkers).size,\r\n        hasMeanwhilePrev: reg.hasMeanwhile ? 1 : 0,\r\n        targets: targets.length,\r\n      },\r\n    };\r\n  }\r\n\r\n  protected async aiDetection(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[],\r\n    aiManager: AIServiceManager,\r\n    targets: readonly TimelineDetectionTarget[]\r\n  ): Promise<ContinuityIssue[]> {\r\n    if (!targets || targets.length === 0) return [];\r\n    try {\r\n      const reg = getOrBuildRegistry(previousScenes);\r\n      const header = buildAIHeader(scene, targets, reg);\r\n      const excerpt = buildSceneExcerptAroundTargets(scene.text, targets, 1200);\r\n      const prevExcerpt = previousScenes.length\r\n        ? [{ ...previousScenes[previousScenes.length - 1], text: (previousScenes[previousScenes.length - 1].text ?? '').slice(0, 700) }]\r\n        : [];\r\n\r\n      const baseReq = {\r\n        scene: { ...scene, text: `${header}\\n\\n${excerpt}` },\r\n        previousScenes: prevExcerpt as Scene[],\r\n        analysisType: 'consistency' as const,\r\n        readerContext: buildReaderContextMinimal(),\r\n      } as Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\n      const enriched = enrichAnalysisRequest(baseReq as any, {\r\n        scene,\r\n        detectorType: 'timeline',\r\n        flags: { critical: Boolean((scene as any)?.critical) },\r\n      });\r\n\r\n      console.debug('[TimelineDetector] invoking AI (consistency) for targets:', targets.length);\r\n      const { issues } = await runAnalysisWithOptionalConsensus(aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n\r\n      const out = mapAITimelineIssues({ issues }, scene.text, targets);\r\n      console.debug('[TimelineDetector] AI returned timeline issues:', out.length);\r\n      return out;\r\n    } catch (err) {\r\n      console.debug('[TimelineDetector] AI analyzeContinuity failed; degrading to local-only.', err);\r\n      return [];\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\hooks\\useAnalysis.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\hooks\\useIssueHighlighting.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\services\\ContinuityAnalyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[926,929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[926,929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2720,2723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2720,2723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4319,4322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4319,4322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4935,4938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4935,4938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4949,4952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4949,4952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5578,5581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5578,5581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7281,7284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7281,7284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7334,7337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7334,7337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":182,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7380,7383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7380,7383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":183,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7430,7433],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7430,7433],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":188,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7673,7676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7673,7676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":212,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8666,8669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8666,8669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9199,9202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9199,9202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":225,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9252,9255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9252,9255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9298,9301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9298,9301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":227,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9348,9351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9348,9351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":231,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9511,9514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9511,9514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10611,10614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10611,10614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":264,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10695,10698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10695,10698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12475,12478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12475,12478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":319,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":319,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12630,12633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12630,12633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ContinuityAnalysis, ReaderKnowledge } from '../../../../shared/types';\r\nimport AIServiceManager from '../../../../services/ai/AIServiceManager';\r\nimport AnalysisCache from '../../../../services/cache/AnalysisCache';\r\nimport BaseDetector from '../detectors/BaseDetector';\r\nimport PronounDetector from '../detectors/PronounDetector';\r\nimport TimelineDetector from '../detectors/TimelineDetector';\r\nimport CharacterDetector from '../detectors/CharacterDetector';\r\nimport PlotContextDetector from '../detectors/PlotContextDetector';\r\nimport EngagementDetector from '../detectors/EngagementDetector';\r\nimport IssueAggregator from '../detectors/IssueAggregator';\r\n\r\n/**\r\n * Small tuple describing a detector entry for orchestration/testing.\r\n */\r\nexport interface DetectorEntry {\r\n  readonly key: 'pronoun' | 'character' | 'timeline' | 'plot' | 'engagement';\r\n  readonly instance: BaseDetector<any>;\r\n}\r\n\r\n/**\r\n * Pure test hook: builds an ordered detector list with fresh instances.\r\n * Default order: pronoun, character, timeline, plot, [engagement?].\r\n */\r\nexport function buildDetectorList(includeEngagement: boolean): readonly DetectorEntry[] {\r\n  const list: DetectorEntry[] = [\r\n    { key: 'pronoun', instance: new PronounDetector() },\r\n    { key: 'character', instance: new CharacterDetector() },\r\n    { key: 'timeline', instance: new TimelineDetector() },\r\n    { key: 'plot', instance: new PlotContextDetector() },\r\n  ];\r\n  if (includeEngagement) list.push({ key: 'engagement', instance: new EngagementDetector() });\r\n  return list;\r\n}\r\n\r\n/**\r\n * Pure helper: run detectors sequentially with timing and error isolation.\r\n * Returns a Map keyed by detector key; attaches __durations on the Map for meta.\r\n */\r\nexport async function runDetectorsSequential(\r\n  scene: Scene,\r\n  previousScenes: readonly Scene[],\r\n  aiManager: AIServiceManager,\r\n  detectors: readonly DetectorEntry[]\r\n): Promise<Map<string, ContinuityIssue[]>> {\r\n  const perDetector = new Map<string, ContinuityIssue[]>();\r\n  const durations: Record<string, number> = {};\r\n  for (const { key, instance } of detectors) {\r\n    const started = Date.now();\r\n    try {\r\n      const issues = await instance.detect(scene, previousScenes, aiManager);\r\n      perDetector.set(key, Array.isArray(issues) ? issues : []);\r\n      durations[key] = Date.now() - started;\r\n      console.debug(`[ContinuityAnalyzer] ${key} finished in ${durations[key]}ms; ${issues.length} issue(s).`);\r\n    } catch (err) {\r\n      durations[key] = Date.now() - started;\r\n      console.debug(`[ContinuityAnalyzer] Detector ${instance.constructor.name} failed; recorded as empty.`, err);\r\n      perDetector.set(key, []);\r\n    }\r\n  }\r\n  (perDetector as any).__durations = durations;\r\n  return perDetector;\r\n}\r\n\r\n/**\r\n * Future-proof helper: limited-concurrency runner (max 2).\r\n * Not used by default; available for tuning and tests.\r\n */\r\nexport async function runDetectorsWithLimit(\r\n  scene: Scene,\r\n  previousScenes: readonly Scene[],\r\n  aiManager: AIServiceManager,\r\n  detectors: readonly DetectorEntry[],\r\n  maxConcurrent = 2\r\n): Promise<Map<string, ContinuityIssue[]>> {\r\n  const perDetector = new Map<string, ContinuityIssue[]>();\r\n  const durations: Record<string, number> = {};\r\n  const queue = detectors.slice();\r\n  const runOne = async (entry: DetectorEntry) => {\r\n    const started = Date.now();\r\n    try {\r\n      const issues = await entry.instance.detect(scene, previousScenes, aiManager);\r\n      perDetector.set(entry.key, Array.isArray(issues) ? issues : []);\r\n      durations[entry.key] = Date.now() - started;\r\n      console.debug(`[ContinuityAnalyzer] ${entry.key} finished in ${durations[entry.key]}ms; ${issues.length} issue(s).`);\r\n    } catch (err) {\r\n      durations[entry.key] = Date.now() - started;\r\n      console.debug(`[ContinuityAnalyzer] Detector ${entry.instance.constructor.name} failed; recorded as empty.`, err);\r\n      perDetector.set(entry.key, []);\r\n    }\r\n  };\r\n  const workers: Promise<void>[] = [];\r\n  for (let i = 0; i < Math.min(maxConcurrent, queue.length); i++) {\r\n    workers.push((async function loop() {\r\n      while (queue.length) {\r\n        const next = queue.shift();\r\n        if (!next) break;\r\n        await runOne(next);\r\n      }\r\n    })());\r\n  }\r\n  await Promise.all(workers);\r\n  (perDetector as any).__durations = durations;\r\n  return perDetector;\r\n}\r\n\r\n/**\r\n * Small helper: convert Map<string, ContinuityIssue[]> to plain Record.\r\n */\r\nexport function toRecord(map: Map<string, ContinuityIssue[]>): Record<string, ContinuityIssue[]> {\r\n  const out: Record<string, ContinuityIssue[]> = {};\r\n  for (const [k, v] of map.entries()) out[k] = v;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Lightweight mock AI manager for unit tests.\r\n * resolver may return ContinuityIssue[] or { issues: ContinuityIssue[] }.\r\n */\r\nexport function createMockAIManager(\r\n  resolver?: (req: Parameters<AIServiceManager['analyzeContinuity']>[0]) => any | Promise<any>\r\n): Pick<AIServiceManager, 'analyzeContinuity'> {\r\n  return {\r\n    async analyzeContinuity(req: Parameters<AIServiceManager['analyzeContinuity']>[0]): Promise<Awaited<ReturnType<AIServiceManager['analyzeContinuity']>>> {\r\n      const val = resolver ? await resolver(req) : [];\r\n      const issues: ContinuityIssue[] = Array.isArray(val) ? val : (val?.issues ?? []);\r\n      return {\r\n        issues,\r\n        metadata: {\r\n          modelUsed: 'mock',\r\n          provider: 'openai',\r\n          costEstimate: 0,\r\n          durationMs: 0,\r\n          confidence: 0,\r\n          cached: true,\r\n        },\r\n      };\r\n    },\r\n  } as any;\r\n}\r\n\r\n/**\r\n * Coordinates all detectors for a single scene and aggregates results.\r\n * Persistent detector instances preserve internal caches across calls.\r\n */\r\nexport default class ContinuityAnalyzer {\r\n  private readonly pronoun = new PronounDetector();\r\n  private readonly character = new CharacterDetector();\r\n  private readonly timeline = new TimelineDetector();\r\n  private readonly plot = new PlotContextDetector();\r\n  private readonly engagement = new EngagementDetector();\r\n  private readonly aggregator = new IssueAggregator();\r\n  private analysisCache?: AnalysisCache;\r\n\r\n  constructor(options?: { enableCache: boolean }) {\r\n    if (options?.enableCache) {\r\n      // Lazy cache creation; async init deferred until first use\r\n      this.analysisCache = new AnalysisCache();\r\n    }\r\n  }\r\n\r\n  public async analyzeScene(\r\n    scene: Scene,\r\n    previousScenes: readonly Scene[] | undefined,\r\n    aiManager: AIServiceManager,\r\n    options: { readonly includeEngagement: boolean }\r\n  ): Promise<ContinuityAnalysis> {\r\n    this.ensureValidOptions(options);\r\n    const prev: readonly Scene[] = Array.isArray(previousScenes) ? previousScenes : [];\r\n    const prevArr: Scene[] = [...prev] as Scene[];\r\n    if (!scene?.text || typeof scene.text !== 'string' || scene.text.trim().length === 0) {\r\n      return this.buildEmptyResult(scene?.id ?? 'unknown');\r\n    }\r\n\r\n    // Cache: lazy init and try to return early on hit\r\n    if (this.analysisCache) {\r\n      await this.ensureCacheInit(); // Lazy cache initialization\r\n      try {\r\n        // Position fallback: prefer scene.position; else scene.index; else previousScenes.length\r\n        const positionForGet: number =\r\n          typeof (scene as any)?.position === 'number'\r\n            ? (scene as any).position\r\n            : typeof (scene as any)?.index === 'number'\r\n            ? (scene as any).index\r\n            : prevArr.length; // fallback to number of previous scenes\r\n\r\n        // Reader context fallback: use provided, otherwise empty typed object\r\n        const readerContextForGet: ReaderKnowledge =\r\n          ((options as any)?.readerContext as ReaderKnowledge) ??\r\n          {\r\n            knownCharacters: new Set<string>(),\r\n            establishedTimeline: [],\r\n            revealedPlotPoints: [],\r\n            establishedSettings: [],\r\n          };\r\n\r\n        const cached = await this.analysisCache.get(scene, positionForGet, prevArr, readerContextForGet);\r\n        if (cached) {\r\n          return cached;\r\n        }\r\n      } catch (err) {\r\n        console.debug('[ContinuityAnalyzer] cache.get failed; proceeding without cache.', err);\r\n      }\r\n    }\r\n\r\n    const started = Date.now();\r\n    const detectors = this.getPersistentDetectorList(options.includeEngagement);\r\n    console.debug('[ContinuityAnalyzer] detectors selected:', detectors.map(d => d.key).join(','));\r\n\r\n    const perDetector = await runDetectorsSequential(scene, prev, aiManager, detectors);\r\n    const aggregated = this.aggregator.aggregate(perDetector);\r\n    const totalMs = Date.now() - started;\r\n    const durations = (perDetector as any).__durations as Record<string, number> | undefined;\r\n\r\n    this.logSummary(scene.id, aggregated.length, durations, totalMs);\r\n\r\n    const result = this.buildBaseResult();\r\n    this.attachMeta(result, scene.id, detectors.map(d => d.key), perDetector, durations, totalMs);\r\n\r\n    // After successful analysis, best-effort write to cache\r\n    if (this.analysisCache) {\r\n      try {\r\n        // Recompute position and reader context deterministically for cache set\r\n        const positionForSet: number =\r\n          typeof (scene as any)?.position === 'number'\r\n            ? (scene as any).position\r\n            : typeof (scene as any)?.index === 'number'\r\n            ? (scene as any).index\r\n            : prevArr.length; // fallback to number of previous scenes\r\n\r\n        const readerContextForSet: ReaderKnowledge =\r\n          ((options as any)?.readerContext as ReaderKnowledge) ??\r\n          {\r\n            knownCharacters: new Set<string>(),\r\n            establishedTimeline: [],\r\n            revealedPlotPoints: [],\r\n            establishedSettings: [],\r\n          };\r\n\r\n        await this.analysisCache.set(scene, positionForSet, prevArr, readerContextForSet, result, totalMs);\r\n      } catch (err) {\r\n        console.debug('[ContinuityAnalyzer] cache.set failed; ignoring.', err);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private getPersistentDetectorList(includeEngagement: boolean): readonly DetectorEntry[] {\r\n    const list: DetectorEntry[] = [\r\n      { key: 'pronoun', instance: this.pronoun },\r\n      { key: 'character', instance: this.character },\r\n      { key: 'timeline', instance: this.timeline },\r\n      { key: 'plot', instance: this.plot },\r\n    ];\r\n    if (includeEngagement) list.push({ key: 'engagement', instance: this.engagement });\r\n    return list;\r\n  }\r\n\r\n  // Lazy cache initialization; idempotent\r\n  private async ensureCacheInit(): Promise<void> {\r\n    if (!this.analysisCache) return;\r\n    if ((this as any)._cacheInitialized) return;\r\n    await this.analysisCache.init();\r\n    (this as any)._cacheInitialized = true;\r\n  }\r\n\r\n  private ensureValidOptions(opts: { readonly includeEngagement: boolean }): void {\r\n    if (!opts || typeof opts.includeEngagement !== 'boolean') {\r\n      throw new Error('ContinuityAnalyzer: invalid options.includeEngagement; expected boolean');\r\n    }\r\n  }\r\n\r\n  private buildBaseResult(): ContinuityAnalysis {\r\n    const readerContext: ReaderKnowledge = {\r\n      knownCharacters: new Set<string>(),\r\n      establishedTimeline: [],\r\n      revealedPlotPoints: [],\r\n      establishedSettings: [],\r\n    };\r\n    return {\r\n      issues: [], // populated by meta attachment for consumers via byDetector/meta; typed shape remains minimal here\r\n      timestamp: Date.now(),\r\n      modelUsed: 'hybrid-local-ai',\r\n      confidence: 0,\r\n      readerContext,\r\n    };\r\n  }\r\n\r\n  private buildEmptyResult(sceneId: string): ContinuityAnalysis {\r\n    const res = this.buildBaseResult();\r\n    const perDetector = new Map<string, ContinuityIssue[]>();\r\n    this.attachMeta(res, sceneId, [], perDetector, {}, 0);\r\n    console.debug('[ContinuityAnalyzer] empty input; returning no issues.', { sceneId });\r\n    return res;\r\n  }\r\n\r\n  private attachMeta(\r\n    result: ContinuityAnalysis,\r\n    sceneId: string,\r\n    detectors: readonly string[],\r\n    perDetector: Map<string, ContinuityIssue[]>,\r\n    durations: Record<string, number> | undefined,\r\n    totalMs: number\r\n  ): void {\r\n    const byDetector = toRecord(perDetector);\r\n    const issues = this.aggregator.aggregate(perDetector);\r\n    const meta = {\r\n      sceneId,\r\n      analyzedAt: new Date().toISOString(),\r\n      detectors: [...detectors],\r\n      stats: {\r\n        durationsMs: durations ?? {},\r\n        totalMs,\r\n      },\r\n    };\r\n    // Persist aggregated list into the typed field\r\n    (result as any).issues = issues;\r\n    // Attach raw breakdown + meta as non-enumerable properties for advanced consumers/tests\r\n    Object.defineProperties(result as any, {\r\n      byDetector: { value: byDetector, enumerable: false, configurable: false, writable: false },\r\n      meta: { value: meta, enumerable: false, configurable: false, writable: false },\r\n    });\r\n  }\r\n\r\n  private logSummary(\r\n    sceneId: string,\r\n    finalCount: number,\r\n    durations: Record<string, number> | undefined,\r\n    totalMs: number\r\n  ): void {\r\n    const policy = finalCount > 10 ? 'mustfix_overflow' : 'top10';\r\n    console.debug('[ContinuityAnalyzer] aggregate complete:', {\r\n      sceneId,\r\n      issues: finalCount,\r\n      limitPolicy: policy,\r\n      durationsMs: durations ?? {},\r\n      totalMs,\r\n    });\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\analyze\\stores\\analysisStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\export\\__tests__\\ExportDialog.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[640,643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[640,643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[658,661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[658,661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1587,1590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1587,1590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2006,2009],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2006,2009],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2043,2046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2043,2046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":108,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2889,2892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2889,2892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3217,3220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3217,3220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3420,3423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3420,3423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment jsdom\r\nimport React from 'react';\r\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\r\nimport '@testing-library/jest-dom';\r\nimport { render, screen, fireEvent } from '@testing-library/react';\r\nimport ExportDialog from '../components/ExportDialog';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useRewriteStore from '../../rewrite/stores/rewriteStore';\r\nimport type { Manuscript, Scene, RewriteVersion } from '../../../../shared/types';\r\n\r\ndeclare global {\r\n  interface Window {\r\n    electron: {\r\n      ipcRenderer: {\r\n        invoke: (channel: string, ...args: any[]) => Promise<any>;\r\n      };\r\n    };\r\n  }\r\n}\r\n\r\nfunction makeManuscript(): Manuscript {\r\n  const s1: Scene = {\r\n    id: 's1',\r\n    text: 'Scene one text',\r\n    wordCount: 3,\r\n    position: 0,\r\n    originalPosition: 0,\r\n    characters: [],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending'\r\n  };\r\n  const s2: Scene = {\r\n    id: 's2',\r\n    text: 'Scene two text',\r\n    wordCount: 3,\r\n    position: 1,\r\n    originalPosition: 1,\r\n    characters: [],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'generated'\r\n  };\r\n  return {\r\n    id: 'm1',\r\n    title: 'Test',\r\n    scenes: [s1, s2],\r\n    originalOrder: ['s1', 's2'],\r\n    currentOrder: ['s1', 's2']\r\n  };\r\n}\r\n\r\nbeforeEach(() => {\r\n  // Reset stores\r\n  useManuscriptStore.setState({\r\n    manuscript: makeManuscript(),\r\n    selectedSceneId: null,\r\n    isLoading: false,\r\n    error: null\r\n  } as any);\r\n\r\n  const rewriteVersion: RewriteVersion = {\r\n    id: 'rv1',\r\n    sceneId: 's2',\r\n    timestamp: Date.now(),\r\n    rewrittenText: 'Scene two new text',\r\n    issuesAddressed: [],\r\n    changesExplanation: '',\r\n    modelUsed: 'mock',\r\n    userEdited: false,\r\n    appliedToManuscript: false\r\n  };\r\n  useRewriteStore.setState({\r\n    sceneRewrites: new Map<string, RewriteVersion[]>([['s2', [rewriteVersion]]])\r\n  } as any);\r\n\r\n  // Mock IPC\r\n  (window as any).electron = {\r\n    ipcRenderer: {\r\n      invoke: vi.fn()\r\n    }\r\n  };\r\n});\r\n\r\nafterEach(() => {\r\n  vi.restoreAllMocks();\r\n});\r\n\r\ndescribe('ExportDialog', () => {\r\n  it('renders stats and allows option selection', () => {\r\n    const onClose = vi.fn();\r\n    render(<ExportDialog isOpen={true} onClose={onClose} />);\r\n\r\n    // Stats visible\r\n    expect(screen.getByText('Total Scenes:')).toBeInTheDocument();\r\n    expect(screen.getByText('2')).toBeInTheDocument();\r\n\r\n    // Change log detail appears when changelog selected\r\n    const changelogRadio = screen.getByDisplayValue('changelog') as HTMLInputElement;\r\n    fireEvent.click(changelogRadio);\r\n    expect(screen.getByText('Change Log Detail:')).toBeInTheDocument();\r\n  });\r\n\r\n  it('invokes IPC on Export and closes on success', async () => {\r\n    const onClose = vi.fn();\r\n    (window as any).electron.ipcRenderer.invoke = vi.fn().mockResolvedValue({\r\n      success: true,\r\n      filePath: 'C:/tmp/export.txt'\r\n    });\r\n\r\n    render(<ExportDialog isOpen={true} onClose={onClose} />);\r\n\r\n    fireEvent.click(screen.getByText('Export'));\r\n\r\n    // Wait microtask\r\n    await Promise.resolve();\r\n\r\n    expect((window as any).electron.ipcRenderer.invoke).toHaveBeenCalled();\r\n    expect(onClose).toHaveBeenCalled();\r\n  });\r\n\r\n  it('shows error when export fails', async () => {\r\n    const onClose = vi.fn();\r\n    (window as any).electron.ipcRenderer.invoke = vi.fn().mockResolvedValue({\r\n      success: false,\r\n      canceled: false,\r\n      error: 'Export failed'\r\n    });\r\n\r\n    render(<ExportDialog isOpen={true} onClose={onClose} />);\r\n\r\n    fireEvent.click(screen.getByText('Export'));\r\n    await Promise.resolve();\r\n\r\n    expect(screen.getByText('Export failed')).toBeInTheDocument();\r\n    expect(onClose).not.toHaveBeenCalled();\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\export\\components\\ExportDialog.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1227,1230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1227,1230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1378,1381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1378,1381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useRewriteStore from '../../rewrite/stores/rewriteStore';\r\nimport { IPC_CHANNELS } from '../../../../shared/constants';\r\nimport type { ExportOptions } from '../../../../services/export/ManuscriptExporter';\r\n\r\ninterface ExportDialogProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n}\r\n\r\nconst ExportDialog: React.FC<ExportDialogProps> = ({ isOpen, onClose }) => {\r\n  const manuscript = useManuscriptStore(state => state.manuscript);\r\n  const sceneRewrites = useRewriteStore(state => state.sceneRewrites);\r\n  \r\n  const [exportOptions, setExportOptions] = useState<ExportOptions>({\r\n    format: 'rewritten',\r\n    includeMetadata: true,\r\n    includeChangeLog: false,\r\n    changeLogDetail: 'summary'\r\n  });\r\n  \r\n  const [isExporting, setIsExporting] = useState(false);\r\n  const [exportError, setExportError] = useState<string | null>(null);\r\n  \r\n  if (!isOpen) return null;\r\n  \r\n  const handleExport = async () => {\r\n    if (!manuscript) return;\r\n    \r\n    setIsExporting(true);\r\n    setExportError(null);\r\n    \r\n    try {\r\n      // Convert Map to serializable format\r\n      const rewritesObj: Record<string, any> = {};\r\n      sceneRewrites.forEach((value, key) => {\r\n        rewritesObj[key] = value;\r\n      });\r\n      \r\n      const result = await (window as any).electron.ipcRenderer.invoke(\r\n        IPC_CHANNELS.EXPORT_WITH_REWRITES,\r\n        {\r\n          manuscript,\r\n          rewrites: rewritesObj,\r\n          options: exportOptions\r\n        }\r\n      );\r\n      \r\n      if (result.success) {\r\n        onClose();\r\n      } else if (!result.canceled) {\r\n        setExportError(result.error || 'Export failed');\r\n      }\r\n    } catch (error) {\r\n       \r\n      console.error('[ExportDialog] Export error:', error);\r\n      setExportError('An error occurred during export');\r\n    } finally {\r\n      setIsExporting(false);\r\n    }\r\n  };\r\n  \r\n  // Calculate stats\r\n  const stats = {\r\n    totalScenes: manuscript?.scenes.length || 0,\r\n    rewrittenScenes:\r\n      manuscript?.scenes.filter(s =>\r\n        s.rewriteStatus === 'approved' || sceneRewrites.has(s.id)\r\n      ).length || 0\r\n  };\r\n  \r\n  return (\r\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n      <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full\">\r\n        {/* Header */}\r\n        <div className=\"px-6 py-4 border-b border-gray-200\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <h3 className=\"text-lg font-semibold text-gray-900\">\r\n              Export Manuscript\r\n            </h3>\r\n            <button\r\n              onClick={onClose}\r\n              className=\"text-gray-400 hover:text-gray-600\"\r\n              disabled={isExporting}\r\n              aria-label=\"Close export dialog\"\r\n            >\r\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\r\n              </svg>\r\n            </button>\r\n          </div>\r\n        </div>\r\n        \r\n        {/* Content */}\r\n        <div className=\"px-6 py-4\">\r\n          {/* Stats */}\r\n          <div className=\"mb-6 p-3 bg-gray-50 rounded-lg\">\r\n            <div className=\"text-sm text-gray-600\">\r\n              <div className=\"flex justify-between mb-1\">\r\n                <span>Total Scenes:</span>\r\n                <span className=\"font-medium\">{stats.totalScenes}</span>\r\n              </div>\r\n              <div className=\"flex justify-between\">\r\n                <span>Rewritten Scenes:</span>\r\n                <span className=\"font-medium text-green-600\">{stats.rewrittenScenes}</span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          \r\n          {/* Format Options */}\r\n          <div className=\"mb-6\">\r\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n              Export Format\r\n            </label>\r\n            <div className=\"space-y-2\">\r\n              <label className=\"flex items-center\">\r\n                <input\r\n                  type=\"radio\"\r\n                  value=\"original\"\r\n                  checked={exportOptions.format === 'original'}\r\n                  onChange={(e) => setExportOptions({\r\n                    ...exportOptions,\r\n                    format: e.target.value as ExportOptions['format']\r\n                  })}\r\n                  className=\"mr-2\"\r\n                />\r\n                <span className=\"text-sm\">Original (reordered only)</span>\r\n              </label>\r\n              <label className=\"flex items-center\">\r\n                <input\r\n                  type=\"radio\"\r\n                  value=\"rewritten\"\r\n                  checked={exportOptions.format === 'rewritten'}\r\n                  onChange={(e) => setExportOptions({\r\n                    ...exportOptions,\r\n                    format: e.target.value as ExportOptions['format']\r\n                  })}\r\n                  className=\"mr-2\"\r\n                />\r\n                <span className=\"text-sm\">Rewritten (with all fixes applied)</span>\r\n              </label>\r\n              <label className=\"flex items-center\">\r\n                <input\r\n                  type=\"radio\"\r\n                  value=\"both\"\r\n                  checked={exportOptions.format === 'both'}\r\n                  onChange={(e) => setExportOptions({\r\n                    ...exportOptions,\r\n                    format: e.target.value as ExportOptions['format']\r\n                  })}\r\n                  className=\"mr-2\"\r\n                />\r\n                <span className=\"text-sm\">Both versions (side by side)</span>\r\n              </label>\r\n              <label className=\"flex items-center\">\r\n                <input\r\n                  type=\"radio\"\r\n                  value=\"changelog\"\r\n                  checked={exportOptions.format === 'changelog'}\r\n                  onChange={(e) => setExportOptions({\r\n                    ...exportOptions,\r\n                    format: e.target.value as ExportOptions['format']\r\n                  })}\r\n                  className=\"mr-2\"\r\n                />\r\n                <span className=\"text-sm\">Change log only</span>\r\n              </label>\r\n            </div>\r\n          </div>\r\n          \r\n          {/* Additional Options */}\r\n          <div className=\"space-y-3\">\r\n            <label className=\"flex items-center\">\r\n              <input\r\n                type=\"checkbox\"\r\n                checked={exportOptions.includeMetadata}\r\n                onChange={(e) => setExportOptions({\r\n                  ...exportOptions,\r\n                  includeMetadata: e.target.checked\r\n                })}\r\n                className=\"mr-2\"\r\n              />\r\n              <span className=\"text-sm\">Include metadata header</span>\r\n            </label>\r\n            \r\n            {exportOptions.format !== 'changelog' && (\r\n              <label className=\"flex items-center\">\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={exportOptions.includeChangeLog}\r\n                  onChange={(e) => setExportOptions({\r\n                    ...exportOptions,\r\n                    includeChangeLog: e.target.checked\r\n                  })}\r\n                  className=\"mr-2\"\r\n                />\r\n                <span className=\"text-sm\">Append change log</span>\r\n              </label>\r\n            )}\r\n            \r\n            {(exportOptions.includeChangeLog || exportOptions.format === 'changelog') && (\r\n              <div className=\"ml-6\">\r\n                <label className=\"text-xs text-gray-600\">Change Log Detail:</label>\r\n                <div className=\"mt-1 space-y-1\">\r\n                  <label className=\"flex items-center\">\r\n                    <input\r\n                      type=\"radio\"\r\n                      value=\"summary\"\r\n                      checked={exportOptions.changeLogDetail === 'summary'}\r\n                      onChange={(e) => setExportOptions({\r\n                        ...exportOptions,\r\n                        changeLogDetail: e.target.value as ExportOptions['changeLogDetail']\r\n                      })}\r\n                      className=\"mr-2\"\r\n                    />\r\n                    <span className=\"text-xs\">Summary</span>\r\n                  </label>\r\n                  <label className=\"flex items-center\">\r\n                    <input\r\n                      type=\"radio\"\r\n                      value=\"detailed\"\r\n                      checked={exportOptions.changeLogDetail === 'detailed'}\r\n                      onChange={(e) => setExportOptions({\r\n                        ...exportOptions,\r\n                        changeLogDetail: e.target.value as ExportOptions['changeLogDetail']\r\n                      })}\r\n                      className=\"mr-2\"\r\n                    />\r\n                    <span className=\"text-xs\">Detailed</span>\r\n                  </label>\r\n                </div>\r\n              </div>\r\n            )}\r\n          </div>\r\n          \r\n          {/* Error Message */}\r\n          {exportError && (\r\n            <div className=\"mt-4 p-3 bg-red-50 border border-red-200 rounded\">\r\n              <p className=\"text-sm text-red-600\">{exportError}</p>\r\n            </div>\r\n          )}\r\n        </div>\r\n        \r\n        {/* Footer */}\r\n        <div className=\"px-6 py-4 bg-gray-50 border-t border-gray-200\">\r\n          <div className=\"flex justify-end gap-3\">\r\n            <button\r\n              onClick={onClose}\r\n              disabled={isExporting}\r\n              className=\"px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50\"\r\n            >\r\n              Cancel\r\n            </button>\r\n            <button\r\n              onClick={handleExport}\r\n              disabled={isExporting}\r\n              className=\"px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50\"\r\n            >\r\n              {isExporting ? 'Exporting...' : 'Export'}\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ExportDialog;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\reorder\\SceneReorderer.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[473,476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[473,476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef } from 'react';\r\nimport { useManuscriptStore } from '../../stores/manuscriptStore';\r\nimport { draggable, dropTargetForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';\r\nimport { combine } from '@atlaskit/pragmatic-drag-and-drop/combine';\r\nimport { reorder } from '@atlaskit/pragmatic-drag-and-drop/reorder';\r\nimport useRewriteStore from '../rewrite/stores/rewriteStore';\r\n\r\ninterface DraggableSceneItemProps {\r\n  scene: any;\r\n  index: number;\r\n  isSelected: boolean;\r\n  onSelect: () => void;\r\n}\r\n\r\nconst DraggableSceneItem: React.FC<DraggableSceneItemProps> = ({ \r\n  scene, \r\n  index, \r\n  isSelected, \r\n  onSelect \r\n}) => {\r\n  const ref = useRef<HTMLDivElement>(null);\r\n  const [isDragging, setIsDragging] = React.useState(false);\r\n  const [isDropTarget, setIsDropTarget] = React.useState(false);\r\n  const { hasRewrite } = useRewriteStore();\r\n  const hasRewriteReady = hasRewrite(scene.id);\r\n\r\n  useEffect(() => {\r\n    const element = ref.current;\r\n    if (!element) return;\r\n\r\n    return combine(\r\n      draggable({\r\n        element,\r\n        getInitialData: () => ({ sceneId: scene.id, index }),\r\n        onDragStart: () => setIsDragging(true),\r\n        onDrop: () => setIsDragging(false),\r\n      }),\r\n      dropTargetForElements({\r\n        element,\r\n        canDrop: ({ source }) => source.data.sceneId !== scene.id,\r\n        onDragEnter: () => setIsDropTarget(true),\r\n        onDragLeave: () => setIsDropTarget(false),\r\n        onDrop: () => setIsDropTarget(false),\r\n      })\r\n    );\r\n  }, [scene.id, index]);\r\n\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      onClick={onSelect}\r\n      className={`p-3 rounded-lg border cursor-pointer transition-all duration-200 ${\r\n        isDragging \r\n          ? 'opacity-50 scale-95 border-blue-300 bg-blue-50' \r\n          : isDropTarget\r\n          ? 'border-blue-500 bg-blue-50 scale-105'\r\n          : isSelected\r\n          ? 'border-blue-500 bg-blue-50'\r\n          : 'border-gray-200 bg-white hover:bg-gray-50 hover:border-gray-300'\r\n      }`}\r\n      style={{\r\n        transform: isDragging ? 'rotate(2deg)' : 'none',\r\n      }}\r\n    >\r\n      <div className=\"flex items-center justify-between\">\r\n        <div className=\"flex items-center gap-3\">\r\n          <div className=\"flex-shrink-0 w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center text-sm font-medium text-gray-600\">\r\n            {index + 1}\r\n          </div>\r\n          <div className=\"min-w-0 flex-1\">\r\n            <div className=\"text-sm font-medium text-gray-900 truncate\">\r\n              Scene {index + 1}\r\n            </div>\r\n            <div className=\"text-xs text-gray-500\">\r\n              {scene.wordCount} words\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"flex items-center gap-2\">\r\n          {scene.hasBeenMoved && (\r\n            <div className=\"w-2 h-2 bg-yellow-400 rounded-full\" title=\"Scene has been moved\" />\r\n          )}\r\n          <div className=\"text-gray-400 cursor-grab active:cursor-grabbing\">\r\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6h16M4 12h16M4 18h16\" />\r\n            </svg>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      \r\n      {/* Scene preview */}\r\n      <div className=\"mt-2 text-xs text-gray-600 line-clamp-2\">\r\n        {scene.text.substring(0, 100)}...\r\n      </div>\r\n\r\n      {/* Rewrite status indicators */}\r\n      {scene.hasBeenMoved && (\r\n        <div className=\"flex items-center gap-2 mt-1\">\r\n          <span className=\"text-xs text-amber-600\">Moved</span>\r\n          {hasRewriteReady && (\r\n            <span className=\"text-xs text-green-600\">Rewrite Available</span>\r\n          )}\r\n          {scene.rewriteStatus === 'approved' && (\r\n            <span className=\"text-xs text-blue-600\">Applied</span>\r\n          )}\r\n          {scene.rewriteStatus === 'rejected' && (\r\n            <span className=\"text-xs text-red-600\">Rejected</span>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nconst SceneReorderer: React.FC = () => {\r\n  const { manuscript, selectedSceneId, selectScene, reorderScenes } = useManuscriptStore();\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  useEffect(() => {\r\n    const element = containerRef.current;\r\n    if (!element) return;\r\n\r\n    return dropTargetForElements({\r\n      element,\r\n      onDrop: ({ source, location }) => {\r\n        const target = location.current.dropTargets[0];\r\n        if (!target) return;\r\n\r\n        const sourceIndex = source.data.index as number;\r\n        const targetIndex = target.data.index as number;\r\n\r\n        if (sourceIndex === targetIndex) return;\r\n\r\n        if (!manuscript) return;\r\n\r\n        // Reorder the scenes\r\n        const newOrder = reorder({\r\n          list: manuscript.currentOrder,\r\n          startIndex: sourceIndex,\r\n          finishIndex: targetIndex,\r\n        });\r\n\r\n        reorderScenes(newOrder);\r\n      },\r\n    });\r\n  }, [manuscript, reorderScenes]);\r\n\r\n  if (!manuscript) {\r\n    return null;\r\n  }\r\n\r\n  // Get scenes in current order\r\n  const orderedScenes = manuscript.currentOrder.map(id => \r\n    manuscript.scenes.find(scene => scene.id === id)\r\n  ).filter(Boolean);\r\n\r\n  return (\r\n    <div className=\"h-full overflow-auto\">\r\n      <div className=\"p-4\">\r\n        <div className=\"flex items-center justify-between mb-3\">\r\n          <h3 className=\"text-sm font-medium text-gray-900\">Scene Order</h3>\r\n          <div className=\"text-xs text-gray-500\">\r\n            Drag to reorder\r\n          </div>\r\n        </div>\r\n        <div ref={containerRef} className=\"space-y-2\">\r\n          {orderedScenes.map((scene, index) => (\r\n            <DraggableSceneItem\r\n              key={scene!.id}\r\n              scene={scene}\r\n              index={index}\r\n              isSelected={selectedSceneId === scene!.id}\r\n              onSelect={() => selectScene(scene!.id)}\r\n            />\r\n          ))}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SceneReorderer;\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\RewriteProgress.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2319,2322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2319,2322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment jsdom\r\nimport React from 'react';\r\nimport { describe, it, expect, vi } from 'vitest';\r\nimport '@testing-library/jest-dom';\r\nimport { render, screen, fireEvent } from '@testing-library/react';\r\nimport RewriteProgress from '../../rewrite/components/RewriteProgress';\r\nimport type { BatchRewriteProgress } from '../../../../services/rewrite/RewriteOrchestrator';\r\n\r\nfunction makeProgress(overrides: Partial<BatchRewriteProgress> = {}): BatchRewriteProgress {\r\n  return {\r\n    totalScenes: 5,\r\n    completedScenes: 2,\r\n    phase: 'rewriting',\r\n    message: 'Rewriting scene 3 of 5',\r\n    currentSceneId: 's3',\r\n    currentSceneTitle: 'Scene 3 Title',\r\n    results: new Map(),\r\n    errors: new Map(),\r\n    ...overrides,\r\n  };\r\n}\r\n\r\ndescribe('RewriteProgress component', () => {\r\n  it('renders start prompt when no progress and not running', () => {\r\n    const onStart = vi.fn();\r\n    render(\r\n      <RewriteProgress\r\n        progress={undefined}\r\n        isRunning={false}\r\n        onCancel={() => {}}\r\n        onStart={onStart}\r\n      />\r\n    );\r\n    expect(screen.getByText('Batch Rewrite Process')).toBeInTheDocument();\r\n    fireEvent.click(screen.getByText('Start Batch Rewrite'));\r\n    expect(onStart).toHaveBeenCalled();\r\n  });\r\n\r\n  it('shows progress bar and current scene when running', () => {\r\n    const progress = makeProgress();\r\n    render(\r\n      <RewriteProgress\r\n        progress={progress}\r\n        isRunning={true}\r\n        onCancel={() => {}}\r\n        onStart={() => {}}\r\n      />\r\n    );\r\n\r\n    // Header and message\r\n    expect(screen.getByText('Processing Rewrites')).toBeInTheDocument();\r\n    expect(screen.getByText(progress.message)).toBeInTheDocument();\r\n\r\n    // Scene counters\r\n    expect(screen.getByText(/2 \\/ 5 scenes/)).toBeInTheDocument();\r\n\r\n    // Current scene title\r\n    expect(screen.getByText(/Currently rewriting:/)).toBeInTheDocument();\r\n    expect(screen.getByText(progress.currentSceneTitle!)).toBeInTheDocument();\r\n\r\n    // Progress bar width should reflect 40%\r\n    const bar = document.querySelector('div.h-full.transition-all') as HTMLDivElement | null;\r\n    expect(bar).toBeTruthy();\r\n    if (bar) {\r\n      expect(bar.style.width).toBe('40%');\r\n    }\r\n  });\r\n\r\n  it('shows completion summary when complete', () => {\r\n    const results = new Map<string, any>([['s1', {}], ['s2', {}], ['s3', {}]]);\r\n    const errors = new Map<string, string>([['s4', 'fail']]);\r\n    const progress = makeProgress({\r\n      phase: 'complete',\r\n      message: 'Done',\r\n      completedScenes: 5,\r\n      totalScenes: 5,\r\n      results,\r\n      errors,\r\n      currentSceneId: undefined,\r\n      currentSceneTitle: undefined\r\n    });\r\n    render(\r\n      <RewriteProgress\r\n        progress={progress}\r\n        isRunning={false}\r\n        onCancel={() => {}}\r\n        onStart={() => {}}\r\n      />\r\n    );\r\n\r\n    expect(screen.getByText('Batch Complete')).toBeInTheDocument();\r\n    // Success/failed cards\r\n    expect(screen.getByText(results.size.toString())).toBeInTheDocument();\r\n    expect(screen.getByText(errors.size.toString())).toBeInTheDocument();\r\n  });\r\n\r\n  it('shows cancel button when running', () => {\r\n    const onCancel = vi.fn();\r\n    const progress = makeProgress();\r\n    render(\r\n      <RewriteProgress\r\n        progress={progress}\r\n        isRunning={true}\r\n        onCancel={onCancel}\r\n        onStart={() => {}}\r\n      />\r\n    );\r\n    fireEvent.click(screen.getByText('Cancel'));\r\n    expect(onCancel).toHaveBeenCalled();\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\RewriteStats.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1452,1455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1452,1455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1994,1997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1994,1997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\batchStore.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vi' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4260,4263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4260,4263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4520,4523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4520,4523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5818,5821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5818,5821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, beforeEach, expect, vi } from 'vitest';\r\nimport useRewriteStore from '../stores/rewriteStore';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport type { Manuscript, Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\nimport type { BatchRewriteProgress, BatchRewriteOptions } from '../../../../services/rewrite/RewriteOrchestrator';\r\nimport type { RewriteResult } from '../../../../services/rewrite/SceneRewriter';\r\n\r\nfunction buildIssue(): ContinuityIssue {\r\n  return {\r\n    type: 'pronoun',\r\n    severity: 'must-fix',\r\n    description: 'Ambiguous pronoun reference',\r\n    textSpan: [0, 5],\r\n    suggestedFix: 'Clarify subject'\r\n  };\r\n}\r\n\r\nfunction buildScene(id: string, position: number): Scene {\r\n  const readerContext: ReaderKnowledge = {\r\n    knownCharacters: new Set(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: []\r\n  };\r\n\r\n  return {\r\n    id,\r\n    text: `Original ${id}`,\r\n    wordCount: 2,\r\n    position,\r\n    originalPosition: position,\r\n    characters: [],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: true,\r\n    rewriteStatus: 'pending',\r\n    continuityAnalysis: {\r\n      issues: [buildIssue()],\r\n      timestamp: Date.now(),\r\n      modelUsed: 'test',\r\n      confidence: 0.9,\r\n      readerContext\r\n    }\r\n  };\r\n}\r\n\r\nfunction buildManuscript(ids: string[]): Manuscript {\r\n  const scenes = ids.map((id, idx) => buildScene(id, idx));\r\n  return {\r\n    id: 'm-batch',\r\n    title: 'Batch Manuscript',\r\n    scenes,\r\n    originalOrder: scenes.map(s => s.id),\r\n    currentOrder: scenes.map(s => s.id)\r\n  };\r\n}\r\n\r\nclass OrchestratorFake {\r\n  cancelled = false;\r\n\r\n  cancelBatch() {\r\n    this.cancelled = true;\r\n  }\r\n\r\n  async rewriteMovedScenes(\r\n    manuscript: Pick<Manuscript, 'scenes' | 'currentOrder'>,\r\n    options: BatchRewriteOptions = {}\r\n  ): Promise<BatchRewriteProgress> {\r\n    const sceneIds = manuscript.currentOrder;\r\n\r\n    const progress: BatchRewriteProgress = {\r\n      totalScenes: sceneIds.length,\r\n      completedScenes: 0,\r\n      phase: 'preparing',\r\n      message: 'Preparing batch rewrite...',\r\n      results: new Map(),\r\n      errors: new Map()\r\n    };\r\n\r\n    options.progressCallback?.(progress);\r\n\r\n    // Simulate sequential processing\r\n    for (const id of sceneIds) {\r\n      if (this.cancelled) {\r\n        progress.phase = 'error';\r\n        progress.message = 'Batch rewrite cancelled';\r\n        break;\r\n      }\r\n\r\n      progress.currentSceneId = id;\r\n      progress.currentSceneTitle = manuscript.scenes.find(s => s.id === id)?.text.split('\\n')[0];\r\n      progress.phase = 'rewriting';\r\n      progress.message = `Rewriting scene ${progress.completedScenes + 1} of ${progress.totalScenes}`;\r\n      options.progressCallback?.(progress);\r\n\r\n      // Simulate result\r\n      const result: RewriteResult = {\r\n        success: true,\r\n        rewrittenText: `Rewritten ${id}`,\r\n        issuesAddressed: manuscript.scenes.find(s => s.id === id)?.continuityAnalysis?.issues ?? [],\r\n        changesExplanation: `Fixed issues in ${id}`,\r\n        preservedElements: [],\r\n        diffData: [],\r\n        modelUsed: 'fake-model'\r\n      };\r\n      progress.results.set(id, result);\r\n      progress.completedScenes += 1;\r\n      options.progressCallback?.(progress);\r\n    }\r\n\r\n    if (!this.cancelled) {\r\n      progress.phase = 'complete';\r\n      progress.message = `Successfully rewrote ${progress.results.size} scenes`;\r\n    }\r\n\r\n    return progress;\r\n  }\r\n}\r\n\r\ndescribe('Rewrite Store  batch operations', () => {\r\n  beforeEach(() => {\r\n    // Reset manuscript\r\n    const manuscript = buildManuscript(['s1', 's2', 's3']);\r\n    useManuscriptStore.setState({\r\n      manuscript,\r\n      selectedSceneId: manuscript.scenes[0].id,\r\n      isLoading: false,\r\n      error: null\r\n    });\r\n\r\n    // Reset rewrite store state\r\n    useRewriteStore.setState({\r\n      isRewriting: false,\r\n      currentRewriteSceneId: undefined,\r\n      rewriteProgress: { stage: 'idle', message: '' },\r\n      sceneRewrites: new Map(),\r\n      activeEdits: new Map(),\r\n      diffCache: new Map(),\r\n      batchProgress: undefined,\r\n      isBatchRewriting: false,\r\n      batchOrchestrator: undefined,\r\n      showHistory: new Map(),\r\n    } as any);\r\n  });\r\n\r\n  it('startBatchRewrite updates progress and stores per-scene results', async () => {\r\n    const orchestrator = new OrchestratorFake();\r\n    // Inject orchestrator into store\r\n    useRewriteStore.setState({ batchOrchestrator: orchestrator } as any);\r\n\r\n    const { startBatchRewrite } = useRewriteStore.getState();\r\n\r\n    await startBatchRewrite({ skipIfNoIssues: false });\r\n\r\n    const state = useRewriteStore.getState();\r\n    expect(state.isBatchRewriting).toBe(false);\r\n    expect(state.batchProgress?.phase).toBe('complete');\r\n    expect(state.batchProgress?.results.size).toBe(3);\r\n\r\n    // Rewrites map should contain ONE rewrite per scene (replace behavior)\r\n    for (const id of ['s1', 's2', 's3']) {\r\n      expect(state.sceneRewrites.has(id)).toBe(true);\r\n      const history = state.sceneRewrites.get(id)!;\r\n      expect(history.length).toBe(1);\r\n      expect(history[0].rewrittenText).toBe(`Rewritten ${id}`);\r\n    }\r\n\r\n    // Manuscript scenes should be marked generated with currentRewrite populated\r\n    const manuscript = useManuscriptStore.getState().manuscript!;\r\n    for (const id of manuscript.currentOrder) {\r\n      const scene = manuscript.scenes.find(s => s.id === id)!;\r\n      expect(scene.rewriteStatus).toBe('generated');\r\n      expect(scene.currentRewrite).toBe(`Rewritten ${id}`);\r\n    }\r\n  });\r\n\r\n  it('cancelBatchRewrite calls orchestrator.cancelBatch and marks state cancelled', async () => {\r\n    const orchestrator = new OrchestratorFake();\r\n    useRewriteStore.setState({ batchOrchestrator: orchestrator } as any);\r\n\r\n    const { startBatchRewrite, cancelBatchRewrite } = useRewriteStore.getState();\r\n\r\n    // Start but immediately cancel; our fake will pick up the cancelled flag\r\n    const startPromise = startBatchRewrite({ skipIfNoIssues: false });\r\n    cancelBatchRewrite();\r\n    await startPromise;\r\n\r\n    const state = useRewriteStore.getState();\r\n    expect(orchestrator.cancelled).toBe(true);\r\n    expect(state.isBatchRewriting).toBe(false);\r\n    expect(state.batchProgress?.phase).toBe('error');\r\n    expect(state.batchProgress?.message).toContain('cancelled');\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\__tests__\\rewriteStore.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1893,1896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1893,1896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2360,2363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2360,2363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2389,2392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2389,2392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2424,2427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2424,2427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2451,2454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2451,2454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2488,2491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2488,2491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2574,2577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2574,2577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, beforeEach, expect, vi } from 'vitest';\r\nimport useRewriteStore from '../../rewrite/stores/rewriteStore';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport type { Manuscript, Scene, ContinuityIssue, ReaderKnowledge } from '../../../../shared/types';\r\n\r\n// Helper: build a baseline scene with continuity analysis issues\r\nfunction buildScene(overrides: Partial<Scene> = {}): Scene {\r\n  const issues: ContinuityIssue[] = [\r\n    {\r\n      type: 'pronoun',\r\n      severity: 'must-fix',\r\n      description: 'Ambiguous pronoun reference',\r\n      textSpan: [0, 10],\r\n      suggestedFix: 'Clarify the subject',\r\n    },\r\n  ];\r\n\r\n  const readerContext: ReaderKnowledge = {\r\n    knownCharacters: new Set<string>(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n\r\n  const base: Scene = {\r\n    id: 's1',\r\n    text: 'Original scene text.',\r\n    wordCount: 3,\r\n    position: 0,\r\n    originalPosition: 0,\r\n    characters: [],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: true,\r\n    rewriteStatus: 'pending',\r\n    continuityAnalysis: {\r\n      issues,\r\n      timestamp: Date.now(),\r\n      modelUsed: 'test-model',\r\n      confidence: 0.8,\r\n      readerContext,\r\n    },\r\n  };\r\n\r\n  return { ...base, ...overrides };\r\n}\r\n\r\nfunction buildManuscript(scene: Scene): Manuscript {\r\n  return {\r\n    id: 'm1',\r\n    title: 'Test Manuscript',\r\n    scenes: [scene],\r\n    originalOrder: [scene.id],\r\n    currentOrder: [scene.id],\r\n  };\r\n}\r\n\r\n// Reset Zustand stores between tests by clearing only state fields (not methods)\r\nfunction resetRewriteStoreState() {\r\n  useRewriteStore.setState({\r\n    isRewriting: false,\r\n    currentRewriteSceneId: undefined,\r\n    rewriteProgress: { stage: 'idle', message: '' },\r\n    sceneRewrites: new Map(),\r\n    activeEdits: new Map(),\r\n    diffCache: new Map(),\r\n  } as any);\r\n}\r\n\r\ndescribe('Rewrite Store - Phase 3.2 workflow', () => {\r\n  beforeEach(() => {\r\n    resetRewriteStoreState();\r\n\r\n    // Fresh manuscript with one scene\r\n    const scene = buildScene();\r\n    const manuscript = buildManuscript(scene);\r\n    useManuscriptStore.setState({\r\n      manuscript,\r\n      selectedSceneId: scene.id,\r\n      isLoading: false,\r\n      error: null,\r\n    });\r\n\r\n    // Mock IPC invoke: window.electron.ipcRenderer.invoke\r\n    (globalThis as any).window = (globalThis as any).window ?? {};\r\n    (window as any).electron = (window as any).electron ?? {};\r\n    (window as any).electron.ipcRenderer = {\r\n      invoke: vi.fn(async (_channel: string, _payload: any) => {\r\n        return {\r\n          success: true,\r\n          rewrittenText: 'Rewritten scene text.',\r\n          issuesAddressed: manuscript.scenes[0].continuityAnalysis?.issues ?? [],\r\n          changesExplanation: 'Fixed pronoun ambiguity.',\r\n          modelUsed: 'unit-test-model',\r\n        };\r\n      }),\r\n    };\r\n  });\r\n\r\n  it('generateRewrite creates a single latest version and updates manuscript flags', async () => {\r\n    const sceneId = 's1';\r\n    const { generateRewrite, getLatestRewrite, getDiff } = useRewriteStore.getState();\r\n\r\n    await generateRewrite(sceneId);\r\n\r\n    const latest = getLatestRewrite(sceneId);\r\n    expect(latest).toBeTruthy();\r\n    expect(latest?.sceneId).toBe(sceneId);\r\n    expect(latest?.rewrittenText).toBe('Rewritten scene text.');\r\n    expect(latest?.userEdited).toBe(false);\r\n    expect(latest?.appliedToManuscript).toBe(false);\r\n\r\n    const diff = getDiff(sceneId);\r\n    expect(diff).toBeTruthy();\r\n    expect(Array.isArray(diff)).toBe(true);\r\n\r\n    const manuscript = useManuscriptStore.getState().manuscript!;\r\n    const scene = manuscript.scenes.find(s => s.id === sceneId)!;\r\n    expect(scene.rewriteStatus).toBe('generated');\r\n    expect(scene.currentRewrite).toBe('Rewritten scene text.');\r\n    // Ensure original is preserved until apply\r\n    expect(scene.text).toBe('Original scene text.');\r\n  });\r\n\r\n  it('edit tracking works: updateEditedText + saveEdit creates a userEdited version and updates currentRewrite', async () => {\r\n    const sceneId = 's1';\r\n    const store = useRewriteStore.getState();\r\n\r\n    await store.generateRewrite(sceneId);\r\n\r\n    store.updateEditedText(sceneId, 'User edited rewrite.');\r\n    store.saveEdit(sceneId);\r\n\r\n    const latest = store.getLatestRewrite(sceneId);\r\n    expect(latest?.userEdited).toBe(true);\r\n    expect(latest?.rewrittenText).toBe('User edited rewrite.');\r\n\r\n    const scene = useManuscriptStore.getState().manuscript!.scenes.find(s => s.id === sceneId)!;\r\n    expect(scene.currentRewrite).toBe('User edited rewrite.');\r\n    // Original still preserved\r\n    expect(scene.text).toBe('Original scene text.');\r\n  });\r\n\r\n  it('applyRewrite applies final text to manuscript and marks approved', async () => {\r\n    const sceneId = 's1';\r\n    const store = useRewriteStore.getState();\r\n\r\n    await store.generateRewrite(sceneId);\r\n    // Simulate user edit before applying\r\n    store.updateEditedText(sceneId, 'User edited rewrite.');\r\n    store.saveEdit(sceneId);\r\n\r\n    store.applyRewrite(sceneId);\r\n\r\n    const manuscript = useManuscriptStore.getState().manuscript!;\r\n    const scene = manuscript.scenes.find(s => s.id === sceneId)!;\r\n    expect(scene.text).toBe('User edited rewrite.');\r\n    expect(scene.rewriteStatus).toBe('approved');\r\n    expect(scene.currentRewrite).toBeUndefined();\r\n\r\n    const latest = store.getLatestRewrite(sceneId);\r\n    expect(latest?.appliedToManuscript).toBe(true);\r\n  });\r\n\r\n  it('rejectRewrite sets status to rejected and preserves original text', async () => {\r\n    const sceneId = 's1';\r\n    const store = useRewriteStore.getState();\r\n\r\n    await store.generateRewrite(sceneId);\r\n    store.rejectRewrite(sceneId);\r\n\r\n    const manuscript = useManuscriptStore.getState().manuscript!;\r\n    const scene = manuscript.scenes.find(s => s.id === sceneId)!;\r\n    expect(scene.rewriteStatus).toBe('rejected');\r\n    expect(scene.text).toBe('Original scene text.');\r\n    expect(scene.currentRewrite).toBeUndefined();\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\ChangeExplanation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\DiffViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteEditor.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'editedText', 'isEditing', 'latestRewrite?.rewrittenText', and 'loadRewriteForEdit'. Either include them or remove the dependency array.","line":46,"column":6,"nodeType":"ArrayExpression","endLine":46,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [editedText, isEditMode, isEditing, latestRewrite?.rewrittenText, loadRewriteForEdit, scene.id]","fix":{"range":[1481,1503],"text":"[editedText, isEditMode, isEditing, latestRewrite?.rewrittenText, loadRewriteForEdit, scene.id]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteHistory.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewritePanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ChangeExplanation' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useMemo } from 'react';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useRewriteStore from '../stores/rewriteStore';\r\nimport RewriteProgress from './RewriteProgress';\r\nimport RewriteHistory from './RewriteHistory';\r\nimport ChangeExplanation from './ChangeExplanation';\r\nimport type { Scene } from '../../../../shared/types';\r\n\r\ninterface RewritePanelProps {\r\n  className?: string;\r\n}\r\n\r\nconst RewritePanel: React.FC<RewritePanelProps> = ({ className = '' }) => {\r\n  const manuscript = useManuscriptStore(state => state.manuscript);\r\n  const [selectedTab, setSelectedTab] = useState<'overview' | 'batch' | 'history'>('overview');\r\n  \r\n  const {\r\n    sceneRewrites,\r\n    isBatchRewriting,\r\n    batchProgress,\r\n    startBatchRewrite,\r\n    cancelBatchRewrite,\r\n    clearAllRewrites,\r\n  } = useRewriteStore();\r\n  \r\n  // Calculate statistics\r\n  const stats = useMemo(() => {\r\n    if (!manuscript) return null;\r\n    \r\n    const movedScenes = manuscript.scenes.filter(s => s.hasBeenMoved);\r\n    const scenesWithIssues = movedScenes.filter(s =>\r\n      (s.continuityAnalysis?.issues?.length ?? 0) > 0\r\n    );\r\n    const scenesWithRewrites = Array.from(sceneRewrites.keys());\r\n    const appliedRewrites = manuscript.scenes.filter(s => s.rewriteStatus === 'approved');\r\n    \r\n    return {\r\n      moved: movedScenes.length,\r\n      withIssues: scenesWithIssues.length,\r\n      rewritten: scenesWithRewrites.length,\r\n      applied: appliedRewrites.length\r\n    };\r\n  }, [manuscript, sceneRewrites]);\r\n  \r\n  const handleStartBatch = useCallback(async () => {\r\n    await startBatchRewrite({\r\n      skipIfNoIssues: true\r\n    });\r\n  }, [startBatchRewrite]);\r\n  \r\n  if (!manuscript || !stats) {\r\n    return (\r\n      <div className={`p-4 text-center text-gray-500 ${className}`}>\r\n        Load a manuscript to begin rewriting\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  return (\r\n    <div className={`flex flex-col h-full ${className}`}>\r\n      {/* Header with tabs */}\r\n      <div className=\"bg-white border-b border-gray-200\">\r\n        <div className=\"px-4 pt-4\">\r\n          <h2 className=\"text-lg font-semibold text-gray-900\">\r\n            Rewrite Management\r\n          </h2>\r\n        </div>\r\n        <div className=\"flex mt-4\">\r\n          <button\r\n            onClick={() => setSelectedTab('overview')}\r\n            className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${\r\n              selectedTab === 'overview'\r\n                ? 'text-blue-600 border-blue-600'\r\n                : 'text-gray-600 border-transparent hover:text-gray-900'\r\n            }`}\r\n          >\r\n            Overview\r\n          </button>\r\n          <button\r\n            onClick={() => setSelectedTab('batch')}\r\n            className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${\r\n              selectedTab === 'batch'\r\n                ? 'text-blue-600 border-blue-600'\r\n                : 'text-gray-600 border-transparent hover:text-gray-900'\r\n            }`}\r\n          >\r\n            Batch Process\r\n          </button>\r\n          <button\r\n            onClick={() => setSelectedTab('history')}\r\n            className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${\r\n              selectedTab === 'history'\r\n                ? 'text-blue-600 border-blue-600'\r\n                : 'text-gray-600 border-transparent hover:text-gray-900'\r\n            }`}\r\n          >\r\n            History\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      {/* Content */}\r\n      <div className=\"flex-1 overflow-auto\">\r\n        {selectedTab === 'overview' && (\r\n          <div className=\"p-4\">\r\n            {/* Statistics Cards */}\r\n            <div className=\"grid grid-cols-2 gap-4 mb-6\">\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-gray-900\">{stats.moved}</div>\r\n                <div className=\"text-sm text-gray-600\">Moved Scenes</div>\r\n              </div>\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-amber-600\">{stats.withIssues}</div>\r\n                <div className=\"text-sm text-gray-600\">Need Rewriting</div>\r\n              </div>\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-blue-600\">{stats.rewritten}</div>\r\n                <div className=\"text-sm text-gray-600\">Rewrites Ready</div>\r\n              </div>\r\n              <div className=\"bg-white p-4 rounded-lg border border-gray-200\">\r\n                <div className=\"text-2xl font-bold text-green-600\">{stats.applied}</div>\r\n                <div className=\"text-sm text-gray-600\">Applied</div>\r\n              </div>\r\n            </div>\r\n            \r\n            {/* Scene List with Status */}\r\n            <div className=\"bg-white rounded-lg border border-gray-200\">\r\n              <div className=\"px-4 py-3 border-b border-gray-200\">\r\n                <h3 className=\"text-sm font-semibold text-gray-900\">\r\n                  Scenes Requiring Attention\r\n                </h3>\r\n              </div>\r\n              <div className=\"divide-y divide-gray-200\">\r\n                {manuscript.scenes\r\n                  .filter(scene => scene.hasBeenMoved && ((scene.continuityAnalysis?.issues?.length ?? 0) > 0))\r\n                  .map(scene => (\r\n                    <SceneRewriteStatus key={scene.id} scene={scene} />\r\n                  ))}\r\n                {stats.withIssues === 0 && (\r\n                  <div className=\"px-4 py-8 text-center text-gray-500\">\r\n                    No scenes require rewriting\r\n                  </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n            \r\n            {/* Quick Actions */}\r\n            <div className=\"mt-6 flex gap-3\">\r\n              <button\r\n                onClick={handleStartBatch}\r\n                disabled={stats.withIssues === 0 || isBatchRewriting}\r\n                className=\"px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed\"\r\n              >\r\n                Rewrite All ({stats.withIssues} scenes)\r\n              </button>\r\n              {stats.rewritten > 0 && (\r\n                <button\r\n                  onClick={clearAllRewrites}\r\n                  className=\"px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50\"\r\n                >\r\n                  Clear All Rewrites\r\n                </button>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n        \r\n        {selectedTab === 'batch' && (\r\n          <div className=\"p-4\">\r\n            <RewriteProgress\r\n              progress={batchProgress}\r\n              isRunning={isBatchRewriting}\r\n              onCancel={cancelBatchRewrite}\r\n              onStart={handleStartBatch}\r\n            />\r\n          </div>\r\n        )}\r\n        \r\n        {selectedTab === 'history' && (\r\n          <div className=\"p-4\">\r\n            <RewriteHistory\r\n              sceneRewrites={sceneRewrites}\r\n              manuscript={manuscript}\r\n            />\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Sub-component for scene status in overview\r\nconst SceneRewriteStatus: React.FC<{ scene: Scene }> = ({ scene }) => {\r\n  const { hasRewrite, generateRewrite } = useRewriteStore();\r\n  const hasRewriteReady = hasRewrite(scene.id);\r\n  const issueCount = scene.continuityAnalysis?.issues?.length || 0;\r\n  \r\n  return (\r\n    <div className=\"px-4 py-3 flex items-center justify-between hover:bg-gray-50\">\r\n      <div>\r\n        <div className=\"text-sm font-medium text-gray-900\">\r\n          Scene {scene.position + 1}\r\n        </div>\r\n        <div className=\"text-xs text-gray-600 mt-1\">\r\n          {issueCount} issue{issueCount !== 1 ? 's' : ''} to fix\r\n        </div>\r\n      </div>\r\n      <div className=\"flex items-center gap-2\">\r\n        {scene.rewriteStatus === 'approved' && (\r\n          <span className=\"text-xs px-2 py-1 bg-green-100 text-green-800 rounded\">\r\n            Applied\r\n          </span>\r\n        )}\r\n        {hasRewriteReady && scene.rewriteStatus !== 'approved' && (\r\n          <span className=\"text-xs px-2 py-1 bg-blue-100 text-blue-800 rounded\">\r\n            Ready\r\n          </span>\r\n        )}\r\n        {!hasRewriteReady && (\r\n          <button\r\n            onClick={() => generateRewrite(scene.id)}\r\n            className=\"text-xs px-3 py-1 text-blue-600 hover:bg-blue-50 rounded\"\r\n          >\r\n            Generate\r\n          </button>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RewritePanel;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\components\\RewriteStats.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'batchProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":10,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport useRewriteStore from '../stores/rewriteStore';\r\nimport PerformanceOptimizer from '../../../../services/rewrite/PerformanceOptimizer';\r\n\r\nconst performanceOptimizer = new PerformanceOptimizer();\r\n\r\nconst RewriteStats: React.FC = () => {\r\n  const manuscript = useManuscriptStore(state => state.manuscript);\r\n  const { sceneRewrites, batchProgress } = useRewriteStore();\r\n\r\n  const stats = React.useMemo(() => {\r\n    if (!manuscript) return null;\r\n\r\n    const totalScenes = manuscript.scenes.length;\r\n    const movedScenes = manuscript.scenes.filter(s => s.hasBeenMoved).length;\r\n    const rewrittenScenes = Array.from(sceneRewrites.keys()).length;\r\n    const appliedRewrites = manuscript.scenes.filter(s => s.rewriteStatus === 'approved').length;\r\n\r\n    // Calculate issue resolution rate\r\n    let totalIssues = 0;\r\n    let resolvedIssues = 0;\r\n\r\n    manuscript.scenes.forEach(scene => {\r\n      const issues = scene.continuityAnalysis?.issues || [];\r\n      totalIssues += issues.length;\r\n\r\n      if (scene.rewriteStatus === 'approved') {\r\n        resolvedIssues += issues.length;\r\n      }\r\n    });\r\n\r\n    const resolutionRate = totalIssues > 0 ? (resolvedIssues / totalIssues) * 100 : 0;\r\n\r\n    return {\r\n      totalScenes,\r\n      movedScenes,\r\n      rewrittenScenes,\r\n      appliedRewrites,\r\n      totalIssues,\r\n      resolvedIssues,\r\n      resolutionRate\r\n    };\r\n  }, [manuscript, sceneRewrites]);\r\n\r\n  const metrics = performanceOptimizer.getMetrics();\r\n  const suggestions = performanceOptimizer.getSuggestions();\r\n\r\n  if (!stats) return null;\r\n\r\n  return (\r\n    <div className=\"p-4 space-y-4\">\r\n      {/* Main Stats */}\r\n      <div className=\"grid grid-cols-2 lg:grid-cols-4 gap-4\">\r\n        <StatCard\r\n          label=\"Scenes Moved\"\r\n          value={stats.movedScenes}\r\n          total={stats.totalScenes}\r\n          color=\"amber\"\r\n        />\r\n        <StatCard\r\n          label=\"Rewrites Ready\"\r\n          value={stats.rewrittenScenes}\r\n          total={stats.movedScenes}\r\n          color=\"blue\"\r\n        />\r\n        <StatCard\r\n          label=\"Applied\"\r\n          value={stats.appliedRewrites}\r\n          total={stats.rewrittenScenes}\r\n          color=\"green\"\r\n        />\r\n        <StatCard\r\n          label=\"Issues Fixed\"\r\n          value={`${stats.resolutionRate.toFixed(0)}%`}\r\n          subtitle={`${stats.resolvedIssues}/${stats.totalIssues}`}\r\n          color=\"purple\"\r\n        />\r\n      </div>\r\n\r\n      {/* Performance Metrics */}\r\n      {metrics.lastUpdated > 0 && (\r\n        <div className=\"bg-white rounded-lg border border-gray-200 p-4\">\r\n          <h3 className=\"text-sm font-semibold text-gray-700 mb-3\">\r\n            Performance\r\n          </h3>\r\n          <div className=\"grid grid-cols-2 gap-4 text-sm\">\r\n            <div>\r\n              <span className=\"text-gray-600\">Avg. Rewrite Time:</span>\r\n              <span className=\"ml-2 font-medium\">\r\n                {(metrics.avgRewriteTime / 1000).toFixed(1)}s\r\n              </span>\r\n            </div>\r\n            <div>\r\n              <span className=\"text-gray-600\">Cache Hit Rate:</span>\r\n              <span className=\"ml-2 font-medium\">\r\n                {(metrics.cacheHitRate * 100).toFixed(0)}%\r\n              </span>\r\n            </div>\r\n          </div>\r\n\r\n          {suggestions.length > 0 && (\r\n            <div className=\"mt-3 pt-3 border-t border-gray-100\">\r\n              <div className=\"text-xs text-gray-600\">Suggestions:</div>\r\n              <ul className=\"mt-1 space-y-1\">\r\n                {suggestions.map((suggestion, index) => (\r\n                  <li key={index} className=\"text-xs text-amber-600\">\r\n                     {suggestion}\r\n                  </li>\r\n                ))}\r\n              </ul>\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\n// Helper component\r\nconst StatCard: React.FC<{\r\n  label: string;\r\n  value: string | number;\r\n  total?: number;\r\n  subtitle?: string;\r\n  color: 'amber' | 'blue' | 'green' | 'purple';\r\n}> = ({ label, value, total, subtitle, color }) => {\r\n  const colorClasses = {\r\n    amber: 'bg-amber-50 text-amber-600',\r\n    blue: 'bg-blue-50 text-blue-600',\r\n    green: 'bg-green-50 text-green-600',\r\n    purple: 'bg-purple-50 text-purple-600'\r\n  };\r\n\r\n  return (\r\n    <div className={`p-4 rounded-lg ${colorClasses[color]}`}>\r\n      <div className=\"text-2xl font-bold\">\r\n        {value}\r\n        {total !== undefined && (\r\n          <span className=\"text-sm font-normal opacity-75\">/{total}</span>\r\n        )}\r\n      </div>\r\n      <div className=\"text-sm mt-1\">{label}</div>\r\n      {subtitle && (\r\n        <div className=\"text-xs opacity-75 mt-1\">{subtitle}</div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RewriteStats;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\hooks\\useRewrite.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\rewrite\\stores\\rewriteStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4860,4863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4860,4863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\r\nimport type { RewriteVersion, DiffSegment, Scene } from '../../../../shared/types';\r\nimport { useManuscriptStore } from '../../../stores/manuscriptStore';\r\nimport { IPC_CHANNELS } from '../../../../shared/constants';\r\nimport DiffEngine from '../../../../services/rewrite/DiffEngine';\r\nimport RewriteOrchestrator from '../../../../services/rewrite/RewriteOrchestrator';\r\nimport type { BatchRewriteProgress, BatchRewriteOptions } from '../../../../services/rewrite/RewriteOrchestrator';\r\n\r\ninterface RewriteState {\r\n  // Current rewrite operation state\r\n  isRewriting: boolean;\r\n  currentRewriteSceneId?: string;\r\n  rewriteProgress: {\r\n    stage: 'idle' | 'analyzing' | 'generating' | 'formatting' | 'complete' | 'error';\r\n    message: string;\r\n  };\r\n  \r\n  // Rewrite storage - Map<sceneId, RewriteVersion[]>\r\n  sceneRewrites: Map<string, RewriteVersion[]>;\r\n  \r\n  // Active edits - Map<sceneId, edited text>\r\n  activeEdits: Map<string, string>;\r\n  \r\n  // Diff data cache for performance\r\n  diffCache: Map<string, DiffSegment[]>;\r\n\r\n  // Batch operations\r\n  batchProgress?: BatchRewriteProgress;\r\n  isBatchRewriting: boolean;\r\n  batchOrchestrator?: RewriteOrchestrator;\r\n  batchCancelled: boolean;\r\n\r\n  // History management\r\n  showHistory: Map<string, boolean>;\r\n  \r\n  // Actions\r\n  generateRewrite: (sceneId: string) => Promise<void>;\r\n  loadRewriteForEdit: (sceneId: string) => void;\r\n  updateEditedText: (sceneId: string, text: string) => void;\r\n  saveEdit: (sceneId: string) => void;\r\n  applyRewrite: (sceneId: string) => void;\r\n  rejectRewrite: (sceneId: string) => void;\r\n  clearRewrite: (sceneId: string) => void;\r\n\r\n  // Batch actions\r\n  startBatchRewrite: (options?: BatchRewriteOptions) => Promise<void>;\r\n  cancelBatchRewrite: () => void;\r\n  toggleHistory: (sceneId: string) => void;\r\n  clearAllRewrites: () => void;\r\n  getRewriteHistory: (sceneId: string) => RewriteVersion[];\r\n  \r\n  // Getters\r\n  getLatestRewrite: (sceneId: string) => RewriteVersion | undefined;\r\n  getEditedText: (sceneId: string) => string | undefined;\r\n  getDiff: (sceneId: string) => DiffSegment[] | undefined;\r\n  hasRewrite: (sceneId: string) => boolean;\r\n  isEditing: (sceneId: string) => boolean;\r\n}\r\n\r\nconst useRewriteStore = create<RewriteState>((set, get) => ({\r\n  isRewriting: false,\r\n  currentRewriteSceneId: undefined,\r\n  rewriteProgress: {\r\n    stage: 'idle',\r\n    message: ''\r\n  },\r\n  sceneRewrites: new Map(),\r\n  activeEdits: new Map(),\r\n  diffCache: new Map(),\r\n\r\n  // Batch defaults\r\n  batchProgress: undefined,\r\n  isBatchRewriting: false,\r\n  batchOrchestrator: undefined,\r\n  batchCancelled: false,\r\n\r\n  // History UI tracking\r\n  showHistory: new Map(),\r\n  \r\n  generateRewrite: async (sceneId: string) => {\r\n    const manuscript = useManuscriptStore.getState().manuscript;\r\n    const scene = manuscript?.scenes.find(s => s.id === sceneId);\r\n    if (!scene || !scene.continuityAnalysis?.issues?.length) {\r\n      console.warn('[RewriteStore] No scene or issues to rewrite');\r\n      return;\r\n    }\r\n\r\n    // Ensure manuscript is loaded to satisfy TS nullability and runtime safety\r\n    if (!manuscript) {\r\n      console.warn('[RewriteStore] Manuscript not loaded');\r\n      set({\r\n        isRewriting: false,\r\n        currentRewriteSceneId: undefined,\r\n        rewriteProgress: { stage: 'error', message: 'No manuscript loaded' }\r\n      });\r\n      return;\r\n    }\r\n    \r\n    set({\r\n      isRewriting: true,\r\n      currentRewriteSceneId: sceneId,\r\n      rewriteProgress: { stage: 'analyzing', message: 'Analyzing issues...' }\r\n    });\r\n    \r\n    try {\r\n      // Get previous scenes for context\r\n      const currentOrder = manuscript.currentOrder || [];\r\n      const sceneIndex = currentOrder.indexOf(sceneId);\r\n      const previousSceneIds = currentOrder.slice(Math.max(0, sceneIndex - 3), sceneIndex);\r\n      const previousScenes = previousSceneIds\r\n        .map(id => manuscript.scenes.find(s => s.id === id))\r\n        .filter(Boolean) as Scene[];\r\n      \r\n      // Build reader context\r\n      const readerContext = {\r\n        knownCharacters: new Set<string>(),\r\n        establishedTimeline: [] as Array<{ label: string }>,\r\n        revealedPlotPoints: [] as string[],\r\n        establishedSettings: [] as Array<{ name: string }>\r\n      };\r\n      \r\n      previousScenes.forEach(s => {\r\n        s.characters?.forEach(char => readerContext.knownCharacters.add(char));\r\n        s.timeMarkers?.forEach(marker => {\r\n          readerContext.establishedTimeline.push({ label: marker });\r\n        });\r\n        s.locationMarkers?.forEach(loc => {\r\n          readerContext.establishedSettings.push({ name: loc });\r\n        });\r\n      });\r\n      \r\n      set({ rewriteProgress: { stage: 'generating', message: 'Generating rewrite...' } });\r\n      \r\n      // Call IPC handler (support both preload patterns)\r\n      const ipcInvoke = (window as any)?.electron?.ipcRenderer?.invoke;\r\n      if (!ipcInvoke || typeof ipcInvoke !== 'function') {\r\n        throw new Error('IPC invoke not available. Ensure preload exposes ipcRenderer.invoke or adjust store.');\r\n      }\r\n\r\n      const result = await ipcInvoke(\r\n        IPC_CHANNELS.GENERATE_REWRITE,\r\n        {\r\n          sceneId,\r\n          scene,\r\n          issues: scene.continuityAnalysis.issues,\r\n          previousScenes,\r\n          readerContext,\r\n          preserveElements: []\r\n        }\r\n      );\r\n      \r\n      if (result.success && result.rewrittenText) {\r\n        // Create RewriteVersion\r\n        const rewriteVersion: RewriteVersion = {\r\n          id: `${sceneId}-${Date.now()}`,\r\n          sceneId,\r\n          timestamp: Date.now(),\r\n          rewrittenText: result.rewrittenText,\r\n          issuesAddressed: result.issuesAddressed || [],\r\n          changesExplanation: result.changesExplanation || '',\r\n          modelUsed: result.modelUsed || 'unknown',\r\n          userEdited: false,\r\n          appliedToManuscript: false\r\n        };\r\n        \r\n        // Update store\r\n        set(state => {\r\n          const rewrites = new Map(state.sceneRewrites);\r\n          // Regenerate replaces existing rewrite for this scene (Phase 3.2 requirement)\r\n          rewrites.set(sceneId, [rewriteVersion]);\r\n\r\n          // Clear any active edit for this scene on regeneration\r\n          const activeEdits = new Map(state.activeEdits);\r\n          activeEdits.delete(sceneId);\r\n          \r\n          // Generate and cache diff\r\n          const diffSegments = DiffEngine.generateDiff(scene.text, result.rewrittenText!,\r\n            { granularity: 'word', includeReasons: true }\r\n          );\r\n          \r\n          const diffCache = new Map(state.diffCache);\r\n          diffCache.set(sceneId, diffSegments);\r\n          \r\n          return {\r\n            sceneRewrites: rewrites,\r\n            activeEdits,\r\n            diffCache,\r\n            rewriteProgress: { stage: 'complete', message: 'Rewrite generated successfully' }\r\n          };\r\n        });\r\n        \r\n        // Update manuscript store to mark scene as having a rewrite\r\n        useManuscriptStore.getState().updateScene(sceneId, {\r\n          rewriteStatus: 'generated',\r\n          currentRewrite: result.rewrittenText\r\n        });\r\n        \r\n      } else {\r\n        set({ \r\n          rewriteProgress: { \r\n            stage: 'error', \r\n            message: result.error || 'Failed to generate rewrite' \r\n          } \r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('[RewriteStore] Generation error:', error);\r\n      set({ \r\n        rewriteProgress: { \r\n          stage: 'error', \r\n          message: 'An error occurred while generating the rewrite' \r\n        } \r\n      });\r\n    } finally {\r\n      set({ isRewriting: false, currentRewriteSceneId: undefined });\r\n    }\r\n  },\r\n  \r\n  loadRewriteForEdit: (sceneId: string) => {\r\n    const latest = get().getLatestRewrite(sceneId);\r\n    if (latest) {\r\n      set(state => {\r\n        const edits = new Map(state.activeEdits);\r\n        edits.set(sceneId, latest.rewrittenText);\r\n        return { activeEdits: edits };\r\n      });\r\n    }\r\n  },\r\n  \r\n  updateEditedText: (sceneId: string, text: string) => {\r\n    set(state => {\r\n      const edits = new Map(state.activeEdits);\r\n      edits.set(sceneId, text);\r\n      \r\n      // Update diff cache with edited version\r\n      const manuscript = useManuscriptStore.getState().manuscript;\r\n      const scene = manuscript?.scenes.find(s => s.id === sceneId);\r\n      if (scene) {\r\n        const diffSegments = DiffEngine.generateDiff(\r\n          scene.text,\r\n          text,\r\n          { granularity: 'word', includeReasons: true }\r\n        );\r\n        const diffCache = new Map(state.diffCache);\r\n        diffCache.set(sceneId, diffSegments);\r\n        return { activeEdits: edits, diffCache };\r\n      }\r\n      \r\n      return { activeEdits: edits };\r\n    });\r\n  },\r\n  \r\n  saveEdit: (sceneId: string) => {\r\n    const editedText = get().activeEdits.get(sceneId);\r\n    const latest = get().getLatestRewrite(sceneId);\r\n    \r\n    if (!editedText || !latest) return;\r\n    \r\n    // Create new version marked as user-edited\r\n    const editedVersion: RewriteVersion = {\r\n      ...latest,\r\n      id: `${sceneId}-edited-${Date.now()}`,\r\n      rewrittenText: editedText,\r\n      userEdited: true,\r\n      timestamp: Date.now()\r\n    };\r\n    \r\n    set(state => {\r\n      const rewrites = new Map(state.sceneRewrites);\r\n      const history = rewrites.get(sceneId) || [];\r\n      rewrites.set(sceneId, [...history, editedVersion]);\r\n      \r\n      // Clear active edit\r\n      const edits = new Map(state.activeEdits);\r\n      edits.delete(sceneId);\r\n      \r\n      return { sceneRewrites: rewrites, activeEdits: edits };\r\n    });\r\n    \r\n    // Update manuscript\r\n    useManuscriptStore.getState().updateScene(sceneId, {\r\n      currentRewrite: editedText\r\n    });\r\n  },\r\n  \r\n  applyRewrite: (sceneId: string) => {\r\n    const latest = get().getLatestRewrite(sceneId);\r\n    const editedText = get().activeEdits.get(sceneId);\r\n    const finalText = editedText || latest?.rewrittenText;\r\n    \r\n    if (!finalText) return;\r\n    \r\n    // Update manuscript with rewritten text\r\n    useManuscriptStore.getState().updateScene(sceneId, {\r\n      text: finalText,\r\n      rewriteStatus: 'approved',\r\n      currentRewrite: undefined, // Clear temporary rewrite\r\n      hasBeenMoved: false // Scene is now adapted to new position\r\n    });\r\n    \r\n    // Mark as applied\r\n    if (latest) {\r\n      set(state => {\r\n        const rewrites = new Map(state.sceneRewrites);\r\n        const history = rewrites.get(sceneId) || [];\r\n        if (history.length > 0) {\r\n          history[history.length - 1].appliedToManuscript = true;\r\n        }\r\n        rewrites.set(sceneId, history);\r\n        return { sceneRewrites: rewrites };\r\n      });\r\n    }\r\n    \r\n    // Clear active edit\r\n    set(state => {\r\n      const edits = new Map(state.activeEdits);\r\n      edits.delete(sceneId);\r\n      return { activeEdits: edits };\r\n    });\r\n  },\r\n  \r\n  rejectRewrite: (sceneId: string) => {\r\n    // Update manuscript status\r\n    useManuscriptStore.getState().updateScene(sceneId, {\r\n      rewriteStatus: 'rejected',\r\n      currentRewrite: undefined\r\n    });\r\n    \r\n    // Clear active edit\r\n    set(state => {\r\n      const edits = new Map(state.activeEdits);\r\n      edits.delete(sceneId);\r\n      return { activeEdits: edits };\r\n    });\r\n  },\r\n  \r\n  clearRewrite: (sceneId: string) => {\r\n    set(state => {\r\n      const rewrites = new Map(state.sceneRewrites);\r\n      rewrites.delete(sceneId);\r\n      \r\n      const edits = new Map(state.activeEdits);\r\n      edits.delete(sceneId);\r\n      \r\n      const diffCache = new Map(state.diffCache);\r\n      diffCache.delete(sceneId);\r\n      \r\n      return { sceneRewrites: rewrites, activeEdits: edits, diffCache };\r\n    });\r\n    \r\n    // Reset scene status\r\n    useManuscriptStore.getState().updateScene(sceneId, {\r\n      rewriteStatus: 'pending',\r\n      currentRewrite: undefined\r\n    });\r\n  },\r\n  \r\n  // Batch operations\r\n  startBatchRewrite: async (options: BatchRewriteOptions = {}) => {\r\n    const manuscript = useManuscriptStore.getState().manuscript;\r\n    if (!manuscript) {\r\n      console.warn('[RewriteStore] No manuscript for batch rewrite');\r\n      return;\r\n    }\r\n    \r\n    // Create orchestrator if needed\r\n    let orchestrator = get().batchOrchestrator;\r\n    if (!orchestrator) {\r\n      orchestrator = new RewriteOrchestrator();\r\n      set({ batchOrchestrator: orchestrator });\r\n    }\r\n    \r\n    set({\r\n      isBatchRewriting: true,\r\n      batchCancelled: false,\r\n      batchProgress: {\r\n        totalScenes: 0,\r\n        completedScenes: 0,\r\n        phase: 'preparing',\r\n        message: 'Starting batch rewrite...',\r\n        results: new Map(),\r\n        errors: new Map()\r\n      }\r\n    });\r\n    \r\n    try {\r\n      // Set up progress callback\r\n      const progressCallback = (progress: BatchRewriteProgress) => {\r\n        set({ batchProgress: progress });\r\n        \r\n        // Update individual scene rewrites as they complete\r\n        progress.results.forEach((result, sceneId) => {\r\n          if (result.success && result.rewrittenText) {\r\n            const rewriteVersion: RewriteVersion = {\r\n              id: `${sceneId}-batch-${Date.now()}`,\r\n              sceneId,\r\n              timestamp: Date.now(),\r\n              rewrittenText: result.rewrittenText,\r\n              issuesAddressed: result.issuesAddressed || [],\r\n              changesExplanation: result.changesExplanation || '',\r\n              modelUsed: result.modelUsed || 'unknown',\r\n              userEdited: false,\r\n              appliedToManuscript: false\r\n            };\r\n            \r\n            set(state => {\r\n              const rewrites = new Map(state.sceneRewrites);\r\n              // Batch also replaces existing rewrites (ONE rewrite rule)\r\n              rewrites.set(sceneId, [rewriteVersion]);\r\n              \r\n              // Update diff cache\r\n              const manuscriptLocal = useManuscriptStore.getState().manuscript;\r\n              const scene = manuscriptLocal?.scenes.find(s => s.id === sceneId);\r\n              if (scene) {\r\n                const diffSegments = DiffEngine.generateDiff(scene.text, result.rewrittenText!,\r\n                  { granularity: 'word', includeReasons: true }\r\n                );\r\n                const diffCache = new Map(state.diffCache);\r\n                diffCache.set(sceneId, diffSegments);\r\n                return { sceneRewrites: rewrites, diffCache };\r\n              }\r\n              \r\n              return { sceneRewrites: rewrites };\r\n            });\r\n            \r\n            // Update manuscript scene status\r\n            useManuscriptStore.getState().updateScene(sceneId, {\r\n              rewriteStatus: 'generated',\r\n              currentRewrite: result.rewrittenText\r\n            });\r\n          }\r\n        });\r\n      };\r\n      \r\n      // Run batch rewrite\r\n      const finalProgress = await orchestrator.rewriteMovedScenes(\r\n        manuscript,\r\n        {\r\n          ...options,\r\n          progressCallback,\r\n          skipIfNoIssues: options.skipIfNoIssues ?? true\r\n        }\r\n      );\r\n      \r\n      // Only set final progress if not cancelled in the meantime\r\n      if (!get().batchCancelled) {\r\n        set({ batchProgress: finalProgress });\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('[RewriteStore] Batch rewrite error:', error);\r\n      set(state => ({\r\n        batchProgress: state.batchProgress ? {\r\n          ...state.batchProgress,\r\n          phase: 'error',\r\n          message: 'Batch rewrite failed'\r\n        } : undefined\r\n      }));\r\n    } finally {\r\n      set({ isBatchRewriting: false });\r\n    }\r\n  },\r\n  \r\n  cancelBatchRewrite: () => {\r\n    const orchestrator = get().batchOrchestrator;\r\n    orchestrator?.cancelBatch();\r\n    \r\n    set(state => ({\r\n      isBatchRewriting: false,\r\n      batchCancelled: true,\r\n      batchProgress: state.batchProgress ? {\r\n        ...state.batchProgress,\r\n        phase: 'error',\r\n        message: 'Batch rewrite cancelled'\r\n      } : undefined\r\n    }));\r\n  },\r\n  \r\n  toggleHistory: (sceneId: string) => {\r\n    set(state => {\r\n      const showHistory = new Map(state.showHistory);\r\n      showHistory.set(sceneId, !showHistory.get(sceneId));\r\n      return { showHistory };\r\n    });\r\n  },\r\n  \r\n  clearAllRewrites: () => {\r\n    set({\r\n      sceneRewrites: new Map(),\r\n      activeEdits: new Map(),\r\n      diffCache: new Map(),\r\n      showHistory: new Map(),\r\n      batchProgress: undefined\r\n    });\r\n    \r\n    // Reset all scene statuses\r\n    const manuscript = useManuscriptStore.getState().manuscript;\r\n    manuscript?.scenes.forEach(scene => {\r\n      if (scene.currentRewrite || scene.rewriteStatus !== 'pending') {\r\n        useManuscriptStore.getState().updateScene(scene.id, {\r\n          rewriteStatus: 'pending',\r\n          currentRewrite: undefined\r\n        });\r\n      }\r\n    });\r\n  },\r\n  \r\n  getRewriteHistory: (sceneId: string) => {\r\n    // Store currently only keeps latest, but structure supports history\r\n    return get().sceneRewrites.get(sceneId) || [];\r\n  },\r\n  \r\n  // Getters\r\n  getLatestRewrite: (sceneId: string) => {\r\n    const history = get().sceneRewrites.get(sceneId);\r\n    return history?.[history.length - 1];\r\n  },\r\n  \r\n  getEditedText: (sceneId: string) => {\r\n    return get().activeEdits.get(sceneId);\r\n  },\r\n  \r\n  getDiff: (sceneId: string) => {\r\n    return get().diffCache.get(sceneId);\r\n  },\r\n  \r\n  hasRewrite: (sceneId: string) => {\r\n    return get().sceneRewrites.has(sceneId);\r\n  },\r\n  \r\n  isEditing: (sceneId: string) => {\r\n    return get().activeEdits.has(sceneId);\r\n  }\r\n}));\r\n\r\nexport default useRewriteStore;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\APIKeyForm.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'defaultModel' is defined but never used. Allowed unused args must match /^_/u.","line":48,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isApiKeyValid' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\n\r\ninterface ValidationErrors {\r\n  apiKey?: string;\r\n  model?: string;\r\n  baseUrl?: string;\r\n}\r\n\r\ninterface APIKeyFormProps {\r\n  apiKey: string;\r\n  model?: string;\r\n  baseUrl?: string;\r\n  disabled?: boolean;\r\n  isTesting?: boolean;\r\n  // New props\r\n  modelOptions: string[];\r\n  defaultModel: string;\r\n  validationErrors?: ValidationErrors;\r\n  isApiKeyValid?: boolean;\r\n\r\n  onApiKeyChange: (value: string) => void;\r\n  onModelChange: (value: string) => void;\r\n  onBaseUrlChange: (value: string) => void;\r\n  onTest: () => void;\r\n}\r\n\r\nconst inputClass =\r\n  'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';\r\n\r\nconst inputErrorClass =\r\n  'w-full px-3 py-2 border border-red-300 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500';\r\n\r\nconst primaryButtonClass =\r\n  'px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-60 disabled:cursor-not-allowed';\r\n\r\nconst neutralButtonClass =\r\n  'px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-60 disabled:cursor-not-allowed';\r\n\r\nconst errorTextClass = 'mt-1 text-xs text-red-600';\r\n\r\nconst APIKeyForm: React.FC<APIKeyFormProps> = ({\r\n  apiKey,\r\n  model,\r\n  baseUrl,\r\n  disabled,\r\n  isTesting,\r\n  modelOptions,\r\n  defaultModel,\r\n  validationErrors,\r\n  isApiKeyValid,\r\n  onApiKeyChange,\r\n  onModelChange,\r\n  onBaseUrlChange,\r\n  onTest,\r\n}) => {\r\n  const [showKey, setShowKey] = useState(false);\r\n\r\n  // Accessible IDs for errors\r\n  const apiKeyErrId = 'api-key-error';\r\n  const modelErrId = 'model-error';\r\n  const baseUrlErrId = 'base-url-error';\r\n\r\n  const apiKeyHasError = !!validationErrors?.apiKey;\r\n  const modelHasError = !!validationErrors?.model;\r\n  const baseUrlHasError = !!validationErrors?.baseUrl;\r\n\r\n  const testDisabled = !!disabled || !!isTesting || !!validationErrors?.apiKey;\r\n\r\n  return (\r\n    <div className=\"space-y-4\">\r\n      <div>\r\n        <label className=\"block text-sm font-medium text-gray-700 mb-1\" htmlFor=\"api-key-input\">\r\n          API Key\r\n        </label>\r\n        <div className=\"flex gap-2\">\r\n          <input\r\n            id=\"api-key-input\"\r\n            type={showKey ? 'text' : 'password'}\r\n            className={apiKeyHasError ? inputErrorClass : inputClass}\r\n            value={apiKey}\r\n            onChange={(e) => onApiKeyChange(e.target.value)}\r\n            placeholder=\"Enter API key\"\r\n            disabled={disabled}\r\n            autoComplete=\"off\"\r\n            aria-invalid={apiKeyHasError}\r\n            aria-describedby={apiKeyHasError ? apiKeyErrId : undefined}\r\n          />\r\n          <button\r\n            type=\"button\"\r\n            className={neutralButtonClass}\r\n            onClick={() => setShowKey((v) => !v)}\r\n            disabled={disabled}\r\n            aria-label={showKey ? 'Hide API key' : 'Show API key'}\r\n            title={showKey ? 'Hide' : 'Show'}\r\n          >\r\n            {showKey ? 'Hide' : 'Show'}\r\n          </button>\r\n        </div>\r\n        {apiKeyHasError ? <p id={apiKeyErrId} className={errorTextClass}>{validationErrors?.apiKey}</p> : null}\r\n      </div>\r\n\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\" htmlFor=\"model-select\">\r\n            Model\r\n          </label>\r\n          <select\r\n            id=\"model-select\"\r\n            className={modelHasError ? inputErrorClass : inputClass}\r\n            value={model ?? ''}\r\n            onChange={(e) => onModelChange(e.target.value)}\r\n            disabled={disabled}\r\n            aria-invalid={modelHasError}\r\n            aria-describedby={modelHasError ? modelErrId : undefined}\r\n          >\r\n            <option value=\"\">Select a model</option>\r\n            {modelOptions.map((opt) => (\r\n              <option key={opt} value={opt}>{opt}</option>\r\n            ))}\r\n          </select>\r\n          {modelHasError ? <p id={modelErrId} className={errorTextClass}>{validationErrors?.model}</p> : null}\r\n        </div>\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\" htmlFor=\"base-url-input\">\r\n            Base URL (optional)\r\n          </label>\r\n          <input\r\n            id=\"base-url-input\"\r\n            type=\"text\"\r\n            className={baseUrlHasError ? inputErrorClass : inputClass}\r\n            value={baseUrl ?? ''}\r\n            onChange={(e) => onBaseUrlChange(e.target.value)}\r\n            placeholder=\"https://api.example.com\"\r\n            disabled={disabled}\r\n            autoComplete=\"off\"\r\n            aria-invalid={baseUrlHasError}\r\n            aria-describedby={baseUrlHasError ? baseUrlErrId : undefined}\r\n          />\r\n          {baseUrlHasError ? <p id={baseUrlErrId} className={errorTextClass}>{validationErrors?.baseUrl}</p> : null}\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"flex justify-end\">\r\n        <button\r\n          type=\"button\"\r\n          className={primaryButtonClass}\r\n          onClick={onTest}\r\n          disabled={testDisabled}\r\n          aria-disabled={testDisabled}\r\n        >\r\n          {isTesting ? 'Testing' : 'Test Connection'}\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default APIKeyForm;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\ProviderSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\SettingsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\hooks\\useAPIConfiguration.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[362,365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[362,365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1184,1187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1184,1187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ProvidersConfigMap, ProviderName } from '../types';\r\n\r\nexport type ConfigInvokeResult =\r\n  | { ok: true }\r\n  | { ok: false; error: { message: string; code: string } };\r\n\r\nexport function useAPIConfiguration() {\r\n  async function configureProviders(config: ProvidersConfigMap): Promise<ConfigInvokeResult> {\r\n    try {\r\n      const api = (window as any)?.electronAPI;\r\n      if (api?.configureProviders) {\r\n        const res = await api.configureProviders(config);\r\n        if (res && typeof res === 'object' && 'ok' in res) {\r\n          return res as ConfigInvokeResult;\r\n        }\r\n        // If preload returns void or unknown, assume success to keep renderer stable.\r\n        return { ok: true };\r\n      }\r\n      // Dev fallback: assume success when bridge not present.\r\n      return { ok: true };\r\n    } catch {\r\n      // Do not log secrets or configs; return sanitized error.\r\n      return { ok: false, error: { message: 'Configuration failed', code: 'CONFIGURE_FAILED' } };\r\n    }\r\n  }\r\n\r\n  async function testConnection(\r\n    provider: ProviderName,\r\n    config?: ProvidersConfigMap[ProviderName]\r\n  ): Promise<boolean> {\r\n    try {\r\n      const api = (window as any)?.electronAPI;\r\n      if (api?.testProvider) {\r\n        const res = await api.testProvider(provider, config);\r\n        return !!(res && res.ok === true);\r\n      }\r\n      // Dev fallback: keep UI stable when bridge not present.\r\n      return true;\r\n    } catch {\r\n      // Avoid logging secrets or configs.\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return {\r\n    configureProviders,\r\n    testConnection,\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\stores\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\stores\\useSettingsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\features\\settings\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\src\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\stores\\historyStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\renderer\\stores\\manuscriptStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\AIServiceManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1626,1629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1626,1629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":352,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11707,11710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11707,11710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":452,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":452,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15353,15356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15353,15356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":454,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":454,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15467,15470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15467,15470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":454,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":454,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15493,15496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15493,15496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":459,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":459,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15645,15648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15645,15648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  AnalysisType,\r\n  ClaudeConfig,\r\n  OpenAIConfig,\r\n  GeminiConfig,\r\n  ModelCapabilities,\r\n  ProviderError,\r\n  ProviderName,\r\n} from './types';\r\nimport PromptCache from './cache/PromptCache';\r\nimport CircuitBreaker from './utils/CircuitBreaker';\r\nimport ClaudeProvider from './providers/ClaudeProvider';\r\nimport OpenAIProvider from './providers/OpenAIProvider';\r\nimport GeminiProvider from './providers/GeminiProvider';\r\nimport BaseProvider from './providers/BaseProvider';\r\nimport ModelPerformanceTracker from './optimization/ModelPerformanceTracker';\r\n\r\n/**\r\n * Model capability registry used for routing and fallbacks.\r\n */\r\nconst CAPABILITIES: Record<string, ModelCapabilities> = {\r\n  'claude-3-5-haiku': {\r\n    model: 'claude-3-5-haiku',\r\n    provider: 'anthropic',\r\n    strengths: ['narrative-flow', 'character-voice', 'instruction-following'],\r\n    costTier: 'low',\r\n  },\r\n  'claude-sonnet-4': {\r\n    model: 'claude-sonnet-4',\r\n    provider: 'anthropic',\r\n    strengths: ['narrative-flow', 'character-voice'],\r\n    costTier: 'medium',\r\n  },\r\n  'claude-opus-4-1': {\r\n    model: 'claude-opus-4-1',\r\n    provider: 'anthropic',\r\n    strengths: ['complex-reasoning', 'deep-analysis'],\r\n    costTier: 'high',\r\n  },\r\n  'gpt-5': {\r\n    model: 'gpt-5',\r\n    provider: 'openai',\r\n    strengths: ['instruction-following', 'validation'],\r\n    costTier: 'low',\r\n  },\r\n  'gemini-2-5-pro': {\r\n    model: 'gemini-2-5-pro',\r\n    provider: 'google',\r\n    strengths: ['full-manuscript', 'bulk-analysis'],\r\n    costTier: 'low',\r\n  },\r\n};\r\n\r\ntype ProviderByModel = Map<string, BaseProvider<any>>;\r\n\r\n/**\r\n * Registry describing available models and basic traits.\r\n * Only models instantiated in this.providers are considered \"configured\".\r\n */\r\ntype Tier = 'fast' | 'balanced' | 'strong';\r\ntype ProviderType = 'claude' | 'openai' | 'gemini';\r\ninterface RegistryModel {\r\n  id: string;\r\n  providerType: ProviderType;\r\n  tier: Tier;\r\n  relativeCost: 1 | 2 | 3;\r\n  maxContextTokens?: number;\r\n}\r\n\r\nconst MODEL_REGISTRY: RegistryModel[] = [\r\n  { id: 'claude-3-5-haiku', providerType: 'claude', tier: 'fast', relativeCost: 1 },\r\n  { id: 'claude-sonnet-4', providerType: 'claude', tier: 'balanced', relativeCost: 2 },\r\n  { id: 'claude-opus-4-1', providerType: 'claude', tier: 'strong', relativeCost: 3 },\r\n  { id: 'gpt-5', providerType: 'openai', tier: 'balanced', relativeCost: 2 },\r\n  { id: 'gemini-2-5-pro', providerType: 'gemini', tier: 'balanced', relativeCost: 1 },\r\n];\r\n\r\nfunction configuredCandidates(providers: ProviderByModel): RegistryModel[] {\r\n  return MODEL_REGISTRY.filter((m) => providers.has(m.id));\r\n}\r\n\r\ninterface ConfigureOptions {\r\n  claude?: ClaudeConfig;\r\n  openai?: OpenAIConfig;\r\n  gemini?: GeminiConfig;\r\n}\r\n\r\ninterface ProviderMetrics {\r\n  success: number;\r\n  fail: number;\r\n}\r\n\r\ninterface Metrics {\r\n  totalRequests: number;\r\n  cacheHitRate: number;\r\n  cacheSize: number;\r\n  perProvider: Record<string, ProviderMetrics>;\r\n  avgDurationPerType: Record<AnalysisType, number>;\r\n  lastErrors: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Helper: choose preferred model for a given analysis type.\r\n */\r\nexport function selectModelForRequest(analysisType: AnalysisType): string {\r\n  switch (analysisType) {\r\n    case 'simple':\r\n      return 'gpt-5';\r\n    case 'consistency':\r\n      return 'claude-sonnet-4';\r\n    case 'complex':\r\n      return 'claude-opus-4-1';\r\n    case 'full':\r\n      return 'gemini-2-5-pro';\r\n    default:\r\n      return 'gpt-5';\r\n  }\r\n}\r\n\r\n/**\r\n * Helper: build fallback chain for a given analysis type.\r\n */\r\nexport function buildFallbackChain(analysisType: AnalysisType): string[] {\r\n  switch (analysisType) {\r\n    case 'simple':\r\n      return ['gpt-5', 'gemini-2-5-pro'];\r\n    case 'consistency':\r\n      return ['claude-sonnet-4', 'gpt-5'];\r\n    case 'complex':\r\n      return ['claude-opus-4-1', 'claude-sonnet-4', 'gpt-5'];\r\n    case 'full':\r\n      return ['gemini-2-5-pro', 'claude-opus-4-1'];\r\n    default:\r\n      return ['gpt-5'];\r\n  }\r\n}\r\n\r\n/**\r\n * Manages AI providers, routing, caching, and metrics for continuity analysis.\r\n */\r\nexport class AIServiceManager {\r\n  private providers: ProviderByModel = new Map();\r\n  private breaker: CircuitBreaker;\r\n  private cache: PromptCache;\r\n  // Internal performance tracker singleton (overridable in tests only)\r\n  private static __testTracker: ModelPerformanceTracker | null = null;\r\n  private tracker: ModelPerformanceTracker;\r\n \r\n  private perProviderMetrics: Record<string, ProviderMetrics> = {};\r\n  private typeDurations: Record<AnalysisType, { total: number; count: number }> = {\r\n    simple: { total: 0, count: 0 },\r\n    consistency: { total: 0, count: 0 },\r\n    complex: { total: 0, count: 0 },\r\n    full: { total: 0, count: 0 },\r\n  };\r\n  private _totalRequests = 0;\r\n  private lastErrors: Record<string, string> = {};\r\n \r\n  constructor(cache?: PromptCache, breaker?: CircuitBreaker) {\r\n    this.cache = cache ?? new PromptCache(100, 5 * 60_000);\r\n    this.breaker = breaker ?? new CircuitBreaker();\r\n    this.tracker = AIServiceManager.__testTracker ?? new ModelPerformanceTracker();\r\n  }\r\n\r\n  /** @internal for unit tests only */\r\n  public static __setTestTracker(tracker: ModelPerformanceTracker | null) {\r\n    AIServiceManager.__testTracker = tracker;\r\n  }\r\n\r\n  /**\r\n   * Configure providers and instantiate per-model clients as needed.\r\n   * TODO: Integrate Electron safeStorage for API keys at a later stage.\r\n   */\r\n  public configure(config: ConfigureOptions): void {\r\n    this.providers.clear();\r\n    // Share the same breaker per provider family (per requirements).\r\n    if (config.claude?.apiKey) {\r\n      this.createClaudeInstances(config.claude);\r\n    }\r\n    if (config.openai?.apiKey) {\r\n      this.createOpenAIInstances(config.openai);\r\n    }\r\n    if (config.gemini?.apiKey) {\r\n      this.createGeminiInstances(config.gemini);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute continuity analysis with adaptive model selection, thresholds, and limited escalation.\r\n   * Cache keys remain based solely on request identity.\r\n   */\r\n  public async analyzeContinuity(req: AnalysisRequest): Promise<AnalysisResponse> {\r\n    this._totalRequests++;\r\n    this.ensureValidRequest(req);\r\n    const hit = this.tryCache(req);\r\n    if (hit) return hit;\r\n\r\n    const candidates = configuredCandidates(this.providers);\r\n    if (candidates.length === 0) {\r\n      throw new ProviderError('openai', 'No AI models are configured');\r\n    }\r\n\r\n    const taskKey = deriveTaskTypeKey(req);\r\n    const baseModelId = selectModel(req, candidates, this.tracker);\r\n    const maxEscalations = 2;\r\n    let attempts = 0;\r\n    let lastError: unknown;\r\n    let lastProviderName: ProviderName | undefined;\r\n    let lastResponse: AnalysisResponse | null = null;\r\n\r\n    const tryInvoke = async (modelId: string): Promise<AnalysisResponse> => {\r\n      const provider = this.providers.get(modelId);\r\n      if (!provider) {\r\n        this.recordFailure(modelId, `Provider for model \"${modelId}\" not configured`);\r\n        throw new ProviderError(\r\n          CAPABILITIES[modelId]?.provider ?? 'openai',\r\n          `Provider for model \"${modelId}\" not configured`\r\n        );\r\n      }\r\n      lastProviderName = CAPABILITIES[modelId]?.provider;\r\n      const started = Date.now();\r\n      try {\r\n        const response = await this.invokeProvider(provider, modelId, req);\r\n        // Record to tracker (success)\r\n        this.tracker.recordResult(modelId, taskKey, {\r\n          confidence: response.metadata.confidence ?? 0,\r\n          latencyMs: response.metadata.durationMs ?? Date.now() - started,\r\n          success: true,\r\n        });\r\n        return response;\r\n      } catch (err) {\r\n        // Record to tracker (failure)\r\n        const dur = Date.now() - started;\r\n        this.tracker.recordResult(modelId, taskKey, {\r\n          confidence: 0,\r\n          latencyMs: dur,\r\n          success: false,\r\n        });\r\n        this.lastErrors[modelId] = (err as Error)?.message ?? String(err);\r\n        this.recordFailure(modelId, this.lastErrors[modelId]);\r\n        throw err;\r\n      }\r\n    };\r\n\r\n    // First attempt using base selection\r\n    try {\r\n      lastResponse = await tryInvoke(baseModelId);\r\n      const threshold = confidenceThreshold(taskKey, isComplex(req));\r\n      if ((lastResponse.metadata.confidence ?? 0) >= threshold) {\r\n        this.cache.set(req, lastResponse);\r\n        return lastResponse;\r\n      }\r\n    } catch (e) {\r\n      lastError = e;\r\n    }\r\n\r\n    // Escalate to stronger tier(s) if needed\r\n    while (attempts < maxEscalations) {\r\n      attempts++;\r\n      const strongerPool = candidates.filter((c) => c.tier === 'strong');\r\n      if (strongerPool.length === 0) break;\r\n      const nextId = selectModel(req, strongerPool, this.tracker);\r\n      try {\r\n        lastResponse = await tryInvoke(nextId);\r\n        const threshold = confidenceThreshold(taskKey, true);\r\n        if ((lastResponse.metadata.confidence ?? 0) >= threshold) {\r\n          this.cache.set(req, lastResponse);\r\n          return lastResponse;\r\n        }\r\n      } catch (e) {\r\n        lastError = e;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // If we have some response (even below threshold), return and cache it to avoid repeated work\r\n    if (lastResponse) {\r\n      this.cache.set(req, lastResponse);\r\n      return lastResponse;\r\n    }\r\n\r\n    const prov: ProviderName = lastProviderName ?? 'openai';\r\n    throw new ProviderError(prov, 'All provider attempts failed for analyzeContinuity', {\r\n      cause: lastError,\r\n      retriable: false,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Expose metrics for diagnostics and tests.\r\n   */\r\n  public getMetrics(): Metrics {\r\n    const cacheStats = this.cache.stats();\r\n    const avgDurationPerType: Record<AnalysisType, number> = {\r\n      simple: this.avgDur('simple'),\r\n      consistency: this.avgDur('consistency'),\r\n      complex: this.avgDur('complex'),\r\n      full: this.avgDur('full'),\r\n    };\r\n    return {\r\n      totalRequests: this._totalRequests,\r\n      cacheHitRate: cacheStats.hitRate,\r\n      cacheSize: cacheStats.size,\r\n      perProvider: this.perProviderMetrics,\r\n      avgDurationPerType,\r\n      lastErrors: this.lastErrors,\r\n    };\r\n  }\r\n\r\n  // ---------- Internal helpers (kept small to satisfy max function length) ----------\r\n\r\n  private tryCache(req: AnalysisRequest): AnalysisResponse | null {\r\n    const cached = this.cache.get<AnalysisResponse>(req);\r\n    return cached ? this.withCachedMetadata(cached) : null;\r\n  }\r\n\r\n  private async executeChain(req: AnalysisRequest, chain: string[]): Promise<AnalysisResponse> {\r\n    let lastError: unknown;\r\n    let lastProviderName: ProviderName | undefined;\r\n\r\n    for (const model of chain) {\r\n      const provider = this.providers.get(model);\r\n      if (!provider) {\r\n        this.recordFailure(model, `Provider for model \"${model}\" not configured`);\r\n        continue;\r\n      }\r\n      lastProviderName = CAPABILITIES[model]?.provider;\r\n      try {\r\n        const response = await this.invokeProvider(provider, model, req);\r\n        this.cache.set(req, response);\r\n        return response;\r\n      } catch (err) {\r\n        // TODO: Replace console.log with production logger\r\n        console.log(`[AIServiceManager] analyze via ${model} failed:`, err);\r\n        lastError = err;\r\n        this.lastErrors[model] = (err as Error)?.message ?? String(err);\r\n        this.recordFailure(model, this.lastErrors[model]);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    const prov: ProviderName = lastProviderName ?? 'openai';\r\n    throw new ProviderError(prov, 'All provider fallbacks failed for analyzeContinuity', {\r\n      cause: lastError,\r\n      retriable: false,\r\n    });\r\n  }\r\n\r\n  private async invokeProvider(\r\n    provider: BaseProvider<any>,\r\n    model: string,\r\n    req: AnalysisRequest\r\n  ): Promise<AnalysisResponse> {\r\n    const started = Date.now();\r\n    const result = await provider.analyze(req);\r\n    const duration = Date.now() - started;\r\n    const final = this.buildFinalResponse(model, result, duration);\r\n    this.recordSuccess(model, req.analysisType, duration);\r\n    return final;\r\n  }\r\n\r\n  private buildFinalResponse(\r\n    model: string,\r\n    result: AnalysisResponse,\r\n    durationMs: number\r\n  ): AnalysisResponse {\r\n    return {\r\n      issues: result.issues,\r\n      metadata: {\r\n        modelUsed: model,\r\n        provider: CAPABILITIES[model]?.provider ?? result.metadata.provider,\r\n        costEstimate: result.metadata.costEstimate,\r\n        durationMs,\r\n        confidence: result.metadata.confidence,\r\n        cached: false,\r\n      },\r\n    };\r\n  }\r\n\r\n  private createClaudeInstances(base: ClaudeConfig): void {\r\n    const haikuCfg: ClaudeConfig = { ...base, model: 'claude-3-5-haiku' };\r\n    const sonnetCfg: ClaudeConfig = { ...base, model: 'claude-sonnet-4' };\r\n    const opusCfg: ClaudeConfig = { ...base, model: 'claude-opus-4-1' };\r\n    this.providers.set('claude-3-5-haiku', new ClaudeProvider(haikuCfg, this.breaker));\r\n    this.providers.set('claude-sonnet-4', new ClaudeProvider(sonnetCfg, this.breaker));\r\n    this.providers.set('claude-opus-4-1', new ClaudeProvider(opusCfg, this.breaker));\r\n  }\r\n\r\n  private createOpenAIInstances(base: OpenAIConfig): void {\r\n    const gptCfg: OpenAIConfig = { ...base, model: 'gpt-5' };\r\n    this.providers.set('gpt-5', new OpenAIProvider(gptCfg, this.breaker));\r\n  }\r\n\r\n  private createGeminiInstances(base: GeminiConfig): void {\r\n    const proCfg: GeminiConfig = { ...base, model: 'gemini-2-5-pro' };\r\n    this.providers.set('gemini-2-5-pro', new GeminiProvider(proCfg, this.breaker));\r\n  }\r\n\r\n  private withCachedMetadata(cached: AnalysisResponse): AnalysisResponse {\r\n    return {\r\n      issues: cached.issues,\r\n      metadata: {\r\n        ...cached.metadata,\r\n        costEstimate: 0,\r\n        durationMs: 0,\r\n        cached: true,\r\n      },\r\n    };\r\n  }\r\n\r\n  private ensureValidRequest(req: AnalysisRequest): void {\r\n    if (!req || typeof req !== 'object') {\r\n      throw new Error('Invalid AnalysisRequest');\r\n    }\r\n    if (!req.scene || typeof req.scene.text !== 'string') {\r\n      throw new Error('AnalysisRequest.scene is required');\r\n    }\r\n    if (!Array.isArray(req.previousScenes)) {\r\n      throw new Error('AnalysisRequest.previousScenes must be an array');\r\n    }\r\n    if (!req.readerContext || !(req.readerContext.knownCharacters instanceof Set)) {\r\n      // Note: do not coerce Set here; upstream should provide correct type.\r\n      throw new Error('AnalysisRequest.readerContext.knownCharacters must be a Set');\r\n    }\r\n  }\r\n\r\n  private recordSuccess(model: string, type: AnalysisType, durationMs: number): void {\r\n    const mp = (this.perProviderMetrics[model] ??= { success: 0, fail: 0 });\r\n    mp.success++;\r\n    const bucket = this.typeDurations[type];\r\n    bucket.total += durationMs;\r\n    bucket.count++;\r\n  }\r\n\r\n  private recordFailure(model: string, _reason: string): void {\r\n    const mp = (this.perProviderMetrics[model] ??= { success: 0, fail: 0 });\r\n    mp.fail++;\r\n  }\r\n\r\n  private avgDur(type: AnalysisType): number {\r\n    const b = this.typeDurations[type];\r\n    return b.count === 0 ? 0 : Math.round(b.total / b.count);\r\n  }\r\n}\r\n\r\n// ---------- Adaptive routing helpers (internal/pure) ----------\r\n\r\nfunction deriveTaskTypeKey(req: AnalysisRequest): string {\r\n  // Prefer explicit analysisType; otherwise fall back to detector/category if present.\r\n  const explicit = (req as any)?.analysisType;\r\n  if (explicit && typeof explicit === 'string') return explicit;\r\n  const detector = (req as any)?.detector ?? (req as any)?.category;\r\n  return typeof detector === 'string' ? detector : 'general';\r\n}\r\n\r\nfunction isComplex(req: AnalysisRequest): boolean {\r\n  if ((req as any)?.flags?.complex === true) return true;\r\n  const prevCount = Array.isArray(req.previousScenes) ? req.previousScenes.length : 0;\r\n  const totalChars =\r\n    (req.scene?.text?.length ?? 0) +\r\n    (req.previousScenes ?? []).reduce((a, s) => a + (s.text?.length ?? 0), 0);\r\n  // Conservative thresholds\r\n  if (req.analysisType === 'complex' || req.analysisType === 'full') return true;\r\n  return prevCount >= 6 || totalChars > 12_000;\r\n}\r\n\r\nfunction confidenceThreshold(taskTypeKey: string, complex: boolean): number {\r\n  if (complex) return 0.75;\r\n  if (taskTypeKey === 'simple') return 0.65;\r\n  return 0.7;\r\n}\r\n\r\n/**\r\n * Internal pure selector:\r\n * - chooses base tier via heuristics (fast for simple, strong for complex)\r\n * - considers adjacent tiers\r\n * - scores via tracker with epsilon-greedy exploration\r\n */\r\nfunction selectModel(\r\n  req: AnalysisRequest,\r\n  candidates: RegistryModel[],\r\n  tracker: ModelPerformanceTracker\r\n): string {\r\n  const taskKey = deriveTaskTypeKey(req);\r\n  const complex = isComplex(req);\r\n  const tiers: Tier[] = complex ? ['strong', 'balanced'] : ['fast', 'balanced'];\r\n \r\n  const pool = candidates.filter((c) => tiers.includes(c.tier));\r\n  if (pool.length === 0) return candidates[0]?.id ?? 'gpt-5';\r\n\r\n  const latencyWeight = complex ? 0.2 : 0.4;\r\n  const accuracyWeight = complex ? 0.8 : 0.6;\r\n\r\n  const scored = pool.map((m) => {\r\n    const normCost = (m.relativeCost - 1) / 2; // 1 -> 0, 2 -> 0.5, 3 -> 1\r\n    const costWeight = complex ? normCost * 0.5 : normCost; // penalize cost less for complex\r\n    const s = tracker.score(m.id, taskKey, {\r\n      costWeight,\r\n      latencyWeight,\r\n      accuracyWeight,\r\n    });\r\n    return { id: m.id, score: s };\r\n  });\r\n\r\n  // epsilon-greedy exploration\r\n  const epsilon = 0.1;\r\n  if (Math.random() < epsilon) {\r\n    const r = Math.floor(Math.random() * scored.length);\r\n    return scored[r].id;\r\n  }\r\n\r\n  scored.sort((a, b) => b.score - a.score);\r\n  return scored[0].id;\r\n}\r\n\r\nexport default AIServiceManager;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\__tests__\\AIServiceManagerRouting.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1829,1832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1829,1832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2524,2527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2524,2527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2735,2738],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2735,2738],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3184,3187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3184,3187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3214,3217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3214,3217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":110,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":112,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":114,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":116,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":118,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4560,4563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4560,4563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4590,4593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4590,4593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":139,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":139,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":141,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":143,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":143,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":146,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6010,6013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6010,6013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6251,6254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6251,6254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6281,6284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6281,6284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":172,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":172,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":175,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":177,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":177,"endColumn":40}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, beforeEach, afterEach, expect, vi } from 'vitest';\r\nimport AIServiceManager from '../../ai/AIServiceManager';\r\nimport type { AnalysisRequest, AnalysisResponse, ProviderName } from '../../ai/types';\r\n\r\n// Minimal stub tracker with controllable per-model scores by taskType\r\nclass StubTracker {\r\n  private map = new Map<string, number>(); // key = modelId::taskType\r\n  private defaultBase = 0.7;\r\n\r\n  private key(modelId: string, taskType: string) {\r\n    return `${modelId}::${taskType}`;\r\n  }\r\n\r\n  public setScore(modelId: string, taskType: string, score: number) {\r\n    this.map.set(this.key(modelId, taskType), Math.max(0, Math.min(1, score)));\r\n  }\r\n\r\n  // No-op for tests\r\n  public recordResult() {}\r\n\r\n  public getMetrics() {\r\n    return {\r\n      avgConfidence: 0.7,\r\n      successRate: 0.7,\r\n      avgLatencyMs: 1000,\r\n      samples: 0,\r\n      lastUpdatedAt: null as number | null,\r\n    };\r\n  }\r\n\r\n  // Emulate penalty behavior similar to real tracker: multiply base by (1 - 0.3 * costWeight)\r\n  public score(modelId: string, taskType: string, opts?: { costWeight?: number; latencyWeight?: number; accuracyWeight?: number }) {\r\n    const base = this.map.get(this.key(modelId, taskType)) ?? this.defaultBase;\r\n    const costWeight = clamp01(opts?.costWeight ?? 0);\r\n    const penalty = 1 - 0.3 * costWeight;\r\n    return clamp01(base * penalty);\r\n  }\r\n}\r\n\r\nfunction clamp01(x: number) {\r\n  return x < 0 ? 0 : x > 1 ? 1 : x;\r\n}\r\n\r\nfunction makeSimpleRequest(): AnalysisRequest {\r\n  return {\r\n    analysisType: 'simple',\r\n    scene: {\r\n      id: 's1',\r\n      text: 'A short scene.',\r\n      wordCount: 3,\r\n      position: 1,\r\n      originalPosition: 1,\r\n      characters: ['Alice'],\r\n      timeMarkers: [],\r\n      locationMarkers: [],\r\n      hasBeenMoved: false,\r\n      rewriteStatus: 'pending',\r\n    } as any,\r\n    previousScenes: [],\r\n    readerContext: {\r\n      knownCharacters: new Set(['Alice']),\r\n      establishedTimeline: [],\r\n      revealedPlotPoints: [],\r\n      establishedSettings: [],\r\n    },\r\n  };\r\n}\r\n\r\nfunction makeResponse(model: string, provider: ProviderName, confidence: number, durationMs = 100): AnalysisResponse {\r\n  return {\r\n    issues: [],\r\n    metadata: {\r\n      modelUsed: model,\r\n      provider,\r\n      costEstimate: 0,\r\n      durationMs,\r\n      confidence,\r\n      cached: false,\r\n    },\r\n  };\r\n}\r\n\r\ndescribe('AIServiceManager adaptive routing', () => {\r\n  beforeEach(() => {\r\n    // fresh tracker per test\r\n    const tracker = new StubTracker();\r\n    (AIServiceManager as any).__setTestTracker(tracker);\r\n    // Stabilize epsilon-greedy selection to keep tests deterministic\r\n    vi.spyOn(Math, 'random').mockReturnValue(0.5);\r\n  });\r\n\r\n  afterEach(() => {\r\n    (AIServiceManager as any).__setTestTracker(null);\r\n    vi.restoreAllMocks();\r\n  });\r\n\r\n  it('selects the fast model (Claude 3.5 Haiku) for simple requests with neutral metrics', async () => {\r\n    const mgr = new AIServiceManager();\r\n    // Configure all providers (fake keys, no network thanks to stubs below)\r\n    mgr.configure({\r\n      claude: { apiKey: 'x' },\r\n      openai: { apiKey: 'y' },\r\n      gemini: { apiKey: 'z' },\r\n    });\r\n\r\n    const providers = (mgr as any).providers as Map<string, any>;\r\n    // Stub analyze for all configured models\r\n    providers.forEach((prov, id) => {\r\n      if (id === 'claude-3-5-haiku') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-3-5-haiku', 'anthropic', 0.85, 120));\r\n      } else if (id === 'claude-opus-4-1') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-opus-4-1', 'anthropic', 0.9, 300));\r\n      } else if (id === 'claude-sonnet-4') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-sonnet-4', 'anthropic', 0.82, 180));\r\n      } else if (id === 'gpt-5') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('gpt-5', 'openai', 0.8, 200));\r\n      } else if (id === 'gemini-2-5-pro') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('gemini-2-5-pro', 'google', 0.8, 220));\r\n      }\r\n    });\r\n\r\n    const req = makeSimpleRequest();\r\n    const res = await mgr.analyzeContinuity(req);\r\n    expect(res.metadata.modelUsed).toBe('claude-3-5-haiku');\r\n  });\r\n\r\n  it('escalates to strong tier when confidence below threshold', async () => {\r\n    const mgr = new AIServiceManager();\r\n    mgr.configure({\r\n      claude: { apiKey: 'x' },\r\n      openai: { apiKey: 'y' },\r\n      gemini: { apiKey: 'z' },\r\n    });\r\n\r\n    const providers = (mgr as any).providers as Map<string, any>;\r\n    // Force base fast model to low confidence to trigger escalation, strong to high confidence\r\n    providers.forEach((prov, id) => {\r\n      if (id === 'claude-3-5-haiku') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-3-5-haiku', 'anthropic', 0.5, 120)); // below 0.65 simple threshold\r\n      } else if (id === 'claude-opus-4-1') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-opus-4-1', 'anthropic', 0.9, 300));\r\n      } else if (!prov.analyze) {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse(id, 'openai', 0.8, 200));\r\n      } else {\r\n        // leave other stubs as-is or default\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse(id, 'openai', 0.8, 200));\r\n      }\r\n    });\r\n\r\n    const req = makeSimpleRequest(); // simple task triggers base fast; low confidence should escalate\r\n    const res = await mgr.analyzeContinuity(req);\r\n    expect(res.metadata.modelUsed).toBe('claude-opus-4-1');\r\n  });\r\n\r\n  it('prefers balanced GPT when tracker shows higher accuracy for the taskType despite higher cost', async () => {\r\n    // Install a tracker that boosts GPT specifically for 'simple'\r\n    const boostedTracker = new StubTracker();\r\n    boostedTracker.setScore('gpt-5', 'simple', 0.95);\r\n    boostedTracker.setScore('claude-3-5-haiku', 'simple', 0.8);\r\n    (AIServiceManager as any).__setTestTracker(boostedTracker);\r\n\r\n    const mgr = new AIServiceManager();\r\n    mgr.configure({\r\n      claude: { apiKey: 'x' },\r\n      openai: { apiKey: 'y' },\r\n      gemini: { apiKey: 'z' },\r\n    });\r\n\r\n    const providers = (mgr as any).providers as Map<string, any>;\r\n    providers.forEach((prov, id) => {\r\n      if (id === 'gpt-5') {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('gpt-5', 'openai', 0.88, 190));\r\n      } else if (id === 'claude-3-5-haiku') {\r\n        // Good but slightly lower confidence, so selection should favor GPT given boosted tracker score\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse('claude-3-5-haiku', 'anthropic', 0.82, 130));\r\n      } else {\r\n        prov.analyze = vi.fn(async (req: AnalysisRequest) => makeResponse(id, 'openai', 0.8, 200));\r\n      }\r\n    });\r\n\r\n    const req = makeSimpleRequest();\r\n    const res = await mgr.analyzeContinuity(req);\r\n    expect(res.metadata.modelUsed).toBe('gpt-5');\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\cache\\PromptCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\consensus\\ConsensusAdapter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReaderKnowledge' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AnalysisType' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":44},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[706,709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[706,709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1316,1319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1316,1319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2133,2136],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2133,2136],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3114,3117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3114,3117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3346,3349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3346,3349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3405,3408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3405,3408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3459,3462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3459,3462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3506,3509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3506,3509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3557,3560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3557,3560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3613,3616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3613,3616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3858,3861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3858,3861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4503,4506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4503,4506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5249,5252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5249,5252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5339,5342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5339,5342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6589,6592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6589,6592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7046,7049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7046,7049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7260,7263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7260,7263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":188,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7633,7636],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7633,7636],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7723,7726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7723,7726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7831,7834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7831,7834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7874,7877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7874,7877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":194,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7922,7925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7922,7925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8131,8134],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8131,8134],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8184,8187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8184,8187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9131,9134],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9131,9134],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../shared/types';\r\nimport type { AnalysisRequest, AnalysisType } from '../types';\r\nimport AIServiceManager from '../AIServiceManager';\r\nimport { ValidationPipeline } from '../validation/ValidationPipeline';\r\n\r\n// Local mapping helpers (keep tiny and self-contained)\r\nfunction mapContinuityTypeToSchema(t: ContinuityIssue['type']): 'pronoun_reference' | 'timeline' | 'character_knowledge' | 'other' {\r\n  switch (t) {\r\n    case 'pronoun': return 'pronoun_reference';\r\n    case 'timeline': return 'timeline';\r\n    case 'character': return 'character_knowledge';\r\n    default: return 'other';\r\n  }\r\n}\r\n\r\nfunction mapSchemaTypeToContinuity(t: any): ContinuityIssue['type'] {\r\n  const s = String(t ?? '').toLowerCase();\r\n  if (s === 'pronoun_reference') return 'pronoun';\r\n  if (s === 'timeline') return 'timeline';\r\n  if (s === 'character_knowledge') return 'character';\r\n  // Prefer plot/context over engagement for generic \"other\"\r\n  return 'plot';\r\n}\r\n\r\nfunction mapContinuitySeverityToSchema(s: ContinuityIssue['severity']): 'low' | 'medium' | 'high' | 'critical' {\r\n  switch (s) {\r\n    case 'must-fix': return 'high';\r\n    case 'should-fix': return 'medium';\r\n    case 'consider': return 'low';\r\n  }\r\n}\r\n\r\nfunction mapSchemaSeverityToContinuity(s: any): ContinuityIssue['severity'] {\r\n  const v = String(s ?? '').toLowerCase();\r\n  if (v === 'critical' || v === 'high') return 'must-fix';\r\n  if (v === 'medium') return 'should-fix';\r\n  return 'consider';\r\n}\r\n\r\nfunction toPipelineIssues(issues: readonly ContinuityIssue[]) {\r\n  return (issues ?? []).map((it) => ({\r\n    type: mapContinuityTypeToSchema(it.type),\r\n    severity: mapContinuitySeverityToSchema(it.severity),\r\n    span: Array.isArray(it.textSpan) && it.textSpan.length === 2\r\n      ? { start_index: it.textSpan[0], end_index: it.textSpan[1] }\r\n      : null,\r\n    explanation: String(it.description ?? '').trim() || 'Issue detected',\r\n    evidence: [],\r\n    suggested_fix: String(it.suggestedFix ?? ''),\r\n    confidence: undefined as number | undefined,\r\n  }));\r\n}\r\n\r\nfunction fromPipelineIssues(pIssues: any[]): ContinuityIssue[] {\r\n  const out: ContinuityIssue[] = [];\r\n  for (const it of pIssues ?? []) {\r\n    const start = it?.span?.start_index;\r\n    const end = it?.span?.end_index;\r\n    const hasSpan = Number.isFinite(start) && Number.isFinite(end) && (end as number) >= (start as number);\r\n    out.push({\r\n      type: mapSchemaTypeToContinuity(it?.type),\r\n      severity: mapSchemaSeverityToContinuity(it?.severity),\r\n      description: String(it?.explanation ?? it?.suggested_fix ?? 'Issue detected'),\r\n      textSpan: hasSpan ? [start, end] as [number, number] : [0, 1],\r\n      suggestedFix: it?.suggested_fix ? String(it.suggested_fix) : undefined,\r\n    });\r\n  }\r\n  return out;\r\n}\r\n\r\n// Default small candidate set (local-only; do not import provider registries)\r\nconst DEFAULT_CANDIDATES = ['gpt-5', 'claude-sonnet-4'];\r\n\r\nexport type ExtraFlags = { complex?: boolean; critical?: boolean };\r\n\r\nexport function enrichAnalysisRequest(\r\n  req: AnalysisRequest & Record<string, any>,\r\n  extras: {\r\n    scene: Scene;\r\n    detectorType: string; // stable taskType label (pronoun, timeline, character, plot, engagement, continuity_rewrite, etc.)\r\n    flags?: ExtraFlags;\r\n  }\r\n): AnalysisRequest & Record<string, any> {\r\n  const newPosition =\r\n    typeof (extras.scene as any)?.position === 'number'\r\n      ? (extras.scene as any).position\r\n      : typeof (extras.scene as any)?.index === 'number'\r\n      ? (extras.scene as any).index\r\n      : 0;\r\n\r\n  return Object.assign(req as any, {\r\n    // Stable routing/task labels (kept local; manager tolerates extra props)\r\n    taskType: extras.detectorType,\r\n    detector: extras.detectorType,\r\n    // Flags for heuristics/consensus selection (local only)\r\n    flags: { ...(req as any)?.flags, ...(extras.flags ?? {}) },\r\n    // Local meta (never part of PromptCache identity)\r\n    sceneText: String(extras.scene?.text ?? ''),\r\n    newPosition,\r\n  });\r\n}\r\n\r\n/**\r\n * Run continuity analysis with optional consensus for critical/high-stakes cases.\r\n * - Preserves PromptCache identity by leaving key fields unchanged.\r\n * - Injects __modelId into the req for each run so tests can assert distinct candidates.\r\n * - Returns an object with { issues } compatible with existing mapping utilities.\r\n */\r\nexport async function runAnalysisWithOptionalConsensus(\r\n  aiManager: AIServiceManager,\r\n  req: AnalysisRequest & Record<string, any>,\r\n  opts: {\r\n    critical?: boolean;\r\n    candidates?: string[];\r\n    consensusCount?: number;\r\n    acceptThreshold?: number;\r\n    humanReviewThreshold?: number;\r\n    maxModels?: number;\r\n  } = {}\r\n): Promise<{ issues: ContinuityIssue[] }> {\r\n  const critical = !!opts.critical;\r\n  if (!critical) {\r\n    const resp = await aiManager.analyzeContinuity(req);\r\n    return { issues: resp.issues ?? [] };\r\n  }\r\n\r\n  const candidates = (opts.candidates && opts.candidates.length > 0) ? Array.from(new Set(opts.candidates)) : DEFAULT_CANDIDATES.slice(0, 2);\r\n\r\n  const pipeline = new ValidationPipeline(\r\n    async (r, { modelId } = {}) => {\r\n      // Attach model id onto the request (local-only, tolerated by manager)\r\n      const r2 = { ...(r as any), __modelId: modelId };\r\n      const single = await aiManager.analyzeContinuity(r2 as any);\r\n      // Convert manager result issues (ContinuityIssue[]) to pipeline schema\r\n      const data = {\r\n        issues: toPipelineIssues(single.issues ?? []),\r\n        summary: '',\r\n        confidence: typeof single?.metadata?.confidence === 'number' ? single.metadata.confidence : 0,\r\n      };\r\n      return { data, modelId, latencyMs: typeof single?.metadata?.durationMs === 'number' ? single.metadata.durationMs : undefined };\r\n    },\r\n    {\r\n      defaultConsensusCount: opts.consensusCount ?? 2,\r\n      acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n      humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n      maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n    }\r\n  );\r\n\r\n  const { data } = await pipeline.runConsensus(req, {\r\n    candidates,\r\n    consensusCount: opts.consensusCount ?? 2,\r\n    acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n    humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n    maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n  });\r\n\r\n  return { issues: fromPipelineIssues((data as any)?.issues ?? []) };\r\n}\r\n\r\n/**\r\n * Specialized minimal adapter for rewrite flows:\r\n * - For consensus: runs two model attempts and treats the returned \"rewrite text\" as the pipeline summary.\r\n * - After consensus, uses merged summary as the chosen rewrite text.\r\n * - For single run: returns the original manager result.\r\n */\r\nexport async function runRewriteWithOptionalConsensus(\r\n  aiManager: AIServiceManager,\r\n  req: AnalysisRequest & Record<string, any>,\r\n  opts: {\r\n    critical?: boolean;\r\n    candidates?: string[];\r\n    consensusCount?: number;\r\n    acceptThreshold?: number;\r\n    humanReviewThreshold?: number;\r\n    maxModels?: number;\r\n  } = {}\r\n): Promise<any> {\r\n  const critical = !!opts.critical;\r\n  if (!critical) {\r\n    return aiManager.analyzeContinuity(req);\r\n  }\r\n\r\n  const candidates = (opts.candidates && opts.candidates.length > 0) ? Array.from(new Set(opts.candidates)) : DEFAULT_CANDIDATES.slice(0, 2);\r\n\r\n  const pipeline = new ValidationPipeline(\r\n    async (r, { modelId } = {}) => {\r\n      const r2 = { ...(r as any), __modelId: modelId };\r\n      const single = await aiManager.analyzeContinuity(r2 as any);\r\n      // Extract rewrite text from tolerant locations\r\n      const rewriteText =\r\n        (single as any)?.rewrittenText ??\r\n        (single as any)?.content?.[0]?.text ??\r\n        (single as any)?.text ??\r\n        '';\r\n      const data = {\r\n        issues: [],      // rewrite consensus reconciles on \"summary\" only\r\n        summary: String(rewriteText ?? ''),\r\n        confidence: typeof (single as any)?.metadata?.confidence === 'number' ? (single as any).metadata.confidence : 0.5,\r\n      };\r\n      return { data, modelId };\r\n    },\r\n    {\r\n      defaultConsensusCount: opts.consensusCount ?? 2,\r\n      acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n      humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n      maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n    }\r\n  );\r\n\r\n  const { data } = await pipeline.runConsensus(req, {\r\n    candidates,\r\n    consensusCount: opts.consensusCount ?? 2,\r\n    acceptThreshold: typeof opts.acceptThreshold === 'number' ? opts.acceptThreshold : 0.5,\r\n    humanReviewThreshold: typeof opts.humanReviewThreshold === 'number' ? opts.humanReviewThreshold : 0.9,\r\n    maxModels: typeof opts.maxModels === 'number' ? opts.maxModels : 2,\r\n  });\r\n\r\n  // Return a shape consumable by SceneRewriter.parseRewriteResponse\r\n  return { text: String((data as any)?.summary ?? '') };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\ModelPerformanceTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\Pricing.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2667,2670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2667,2670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2710,2713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2710,2713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2755,2758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2755,2758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Pricing.ts\r\n// Centralized model pricing table and cost estimation utilities.\r\n// - No heavy dependencies.\r\n// - Allows environment override via MODEL_PRICING_JSON (stringified map).\r\n// - Conservative defaults for unknown models.\r\n\r\nexport type Currency = 'USD';\r\n\r\nexport interface ModelPricing {\r\n  inputPer1k: number;   // USD per 1,000 input tokens\r\n  outputPer1k: number;  // USD per 1,000 output tokens\r\n  currency: Currency;\r\n}\r\n\r\ntype PricingMap = Record<string, ModelPricing>;\r\n\r\n// Base pricing table (conservative; easily updated)\r\n// Notes (approximate market references as of 2025, rounded conservatively):\r\n// - OpenAI GPT-4o family: input ~$0.005/1k, output ~$0.015/1k\r\n// - GPT-4.x family: a bit higher; here we align to 4o defaults for simplicity\r\n// - GPT-5 placeholder maps to 4o rates until official pricing is stable\r\n// - Claude:\r\n//   - 3.5 Haiku very low, Sonnet mid, Opus high (conservative placeholders)\r\n// - Gemini 2.5 Pro similar to mid-tier rates\r\nconst BASE_TABLE: PricingMap = {\r\n  // OpenAI family\r\n  'gpt-4o':           { inputPer1k: 0.005, outputPer1k: 0.015, currency: 'USD' },\r\n  'gpt-4o-mini':      { inputPer1k: 0.003, outputPer1k: 0.009,  currency: 'USD' },\r\n  'gpt-4-turbo':      { inputPer1k: 0.01,  outputPer1k: 0.03,   currency: 'USD' },\r\n  'gpt-4':            { inputPer1k: 0.03,  outputPer1k: 0.06,   currency: 'USD' },\r\n  'gpt-5':            { inputPer1k: 0.005, outputPer1k: 0.015,  currency: 'USD' }, // placeholder -> 4o\r\n\r\n  // Claude family\r\n  'claude-3-5-haiku': { inputPer1k: 0.0008, outputPer1k: 0.004,  currency: 'USD' },\r\n  'claude-sonnet-4':  { inputPer1k: 0.003,  outputPer1k: 0.015,  currency: 'USD' },\r\n  'claude-opus-4-1':  { inputPer1k: 0.015,  outputPer1k: 0.075,  currency: 'USD' },\r\n\r\n  // Gemini family\r\n  'gemini-2-5-pro':   { inputPer1k: 0.0035, outputPer1k: 0.0105, currency: 'USD' },\r\n};\r\n\r\n// Default conservative pricing if model is unknown\r\nconst DEFAULT_PRICING: ModelPricing = { inputPer1k: 0.004, outputPer1k: 0.012, currency: 'USD' };\r\n\r\n// Parse optional override from env: MODEL_PRICING_JSON = JSON.stringify({ \"model-id\": { inputPer1k, outputPer1k, currency } })\r\nfunction readOverride(): PricingMap | null {\r\n  const raw = typeof process !== 'undefined' ? (process.env?.MODEL_PRICING_JSON ?? '') : '';\r\n  if (!raw || typeof raw !== 'string') return null;\r\n  try {\r\n    const parsed = JSON.parse(raw);\r\n    // Defensive: ensure proper shape\r\n    const out: PricingMap = {};\r\n    if (parsed && typeof parsed === 'object') {\r\n      for (const [k, v] of Object.entries(parsed as Record<string, unknown>)) {\r\n        if (!v || typeof v !== 'object') continue;\r\n        const ip = (v as any).inputPer1k;\r\n        const op = (v as any).outputPer1k;\r\n        const cur = (v as any).currency ?? 'USD';\r\n        if (Number.isFinite(ip) && Number.isFinite(op) && (cur === 'USD')) {\r\n          out[String(k).toLowerCase()] = { inputPer1k: Number(ip), outputPer1k: Number(op), currency: cur };\r\n        }\r\n      }\r\n    }\r\n    return Object.keys(out).length ? out : null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction normalizeId(id: string): string {\r\n  return String(id || '').trim().toLowerCase();\r\n}\r\n\r\n// Family heuristics when no direct match\r\nfunction familyPricing(modelId: string): ModelPricing | null {\r\n  const m = normalizeId(modelId);\r\n  // OpenAI families\r\n  if (m.includes('gpt-4o')) return BASE_TABLE['gpt-4o'];\r\n  if (m.includes('gpt-4')) return BASE_TABLE['gpt-4-turbo'];\r\n  if (m.includes('gpt-5')) return BASE_TABLE['gpt-5'];\r\n  if (m.startsWith('gpt')) return BASE_TABLE['gpt-4o'];\r\n\r\n  // Claude families\r\n  if (m.includes('haiku')) return BASE_TABLE['claude-3-5-haiku'];\r\n  if (m.includes('sonnet')) return BASE_TABLE['claude-sonnet-4'];\r\n  if (m.includes('opus')) return BASE_TABLE['claude-opus-4-1'];\r\n  if (m.includes('claude')) return BASE_TABLE['claude-sonnet-4'];\r\n\r\n  // Gemini families\r\n  if (m.includes('gemini') && m.includes('pro')) return BASE_TABLE['gemini-2-5-pro'];\r\n  if (m.includes('gemini')) return BASE_TABLE['gemini-2-5-pro'];\r\n\r\n  return null;\r\n}\r\n\r\nlet cachedMergedTable: PricingMap | null = null;\r\n\r\nfunction getMergedTable(): PricingMap {\r\n  if (cachedMergedTable) return cachedMergedTable;\r\n  const overrides = readOverride();\r\n  cachedMergedTable = { ...BASE_TABLE };\r\n  if (overrides) {\r\n    for (const [k, v] of Object.entries(overrides)) {\r\n      cachedMergedTable[k] = v;\r\n    }\r\n  }\r\n  return cachedMergedTable;\r\n}\r\n\r\nexport function getModelPricing(modelId: string): ModelPricing {\r\n  const id = normalizeId(modelId);\r\n  const table = getMergedTable();\r\n  if (table[id]) return table[id];\r\n  const fam = familyPricing(id);\r\n  if (fam) return fam;\r\n  return DEFAULT_PRICING;\r\n}\r\n\r\nexport function estimateCost(\r\n  modelId: string,\r\n  usage: { inputTokens: number; outputTokens?: number }\r\n): { estimatedUSD: number; breakdown: { inputUSD: number; outputUSD: number } } {\r\n  const pr = getModelPricing(modelId);\r\n  const inTok = Math.max(0, Math.floor(usage.inputTokens || 0));\r\n  const outTok = Math.max(0, Math.floor(usage.outputTokens || 0));\r\n  const inputUSD = (inTok / 1000) * pr.inputPer1k;\r\n  const outputUSD = (outTok / 1000) * pr.outputPer1k;\r\n  const estimatedUSD = roundUSD(inputUSD + outputUSD);\r\n  return {\r\n    estimatedUSD,\r\n    breakdown: {\r\n      inputUSD: roundUSD(inputUSD),\r\n      outputUSD: roundUSD(outputUSD),\r\n    },\r\n  };\r\n}\r\n\r\nfunction roundUSD(x: number): number {\r\n  // Round to 6 decimals to avoid floating point noise but keep precision\r\n  return Math.round(x * 1e6) / 1e6;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\RequestBatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\__tests__\\Pricing.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[201,204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[201,204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1743,1746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1743,1746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2575,2578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2575,2578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\r\n\r\ndescribe('Pricing getModelPricing and estimateCost', () => {\r\n  beforeEach(() => {\r\n    vi.resetModules();\r\n    delete (process.env as any).MODEL_PRICING_JSON;\r\n  });\r\n\r\n  it('returns expected pricing for known models', async () => {\r\n    const { getModelPricing } = await import('../Pricing');\r\n    const p1 = getModelPricing('gpt-4o');\r\n    expect(p1.currency).toBe('USD');\r\n    expect(p1.inputPer1k).toBeCloseTo(0.005, 6);\r\n    expect(p1.outputPer1k).toBeCloseTo(0.015, 6);\r\n\r\n    const p2 = getModelPricing('claude-sonnet-4');\r\n    expect(p2.inputPer1k).toBeGreaterThan(0);\r\n    expect(p2.outputPer1k).toBeGreaterThan(0);\r\n\r\n    const p3 = getModelPricing('gemini-2-5-pro');\r\n    expect(p3.inputPer1k).toBeGreaterThan(0);\r\n    expect(p3.outputPer1k).toBeGreaterThan(0);\r\n  });\r\n\r\n  it('estimateCost math is correct with known table', async () => {\r\n    const { estimateCost } = await import('../Pricing');\r\n    const res = estimateCost('gpt-4o', { inputTokens: 1000, outputTokens: 500 });\r\n    // 1000 * 0.005 = 0.005; 500 * 0.015 = 0.0075; total = 0.0125\r\n    expect(res.estimatedUSD).toBeCloseTo(0.0125, 6);\r\n    expect(res.breakdown.inputUSD).toBeCloseTo(0.005, 6);\r\n    expect(res.breakdown.outputUSD).toBeCloseTo(0.0075, 6);\r\n  });\r\n\r\n  it('falls back to conservative default for unknown modelId', async () => {\r\n    const { getModelPricing } = await import('../Pricing');\r\n    const p = getModelPricing('unknown-model-xyz');\r\n    expect(p.currency).toBe('USD');\r\n    expect(p.inputPer1k).toBeGreaterThan(0);\r\n    expect(p.outputPer1k).toBeGreaterThan(0);\r\n  });\r\n\r\n  it('honors MODEL_PRICING_JSON env override (defensive parsing)', async () => {\r\n    (process.env as any).MODEL_PRICING_JSON = JSON.stringify({\r\n      'custom-model-x': { inputPer1k: 0.123, outputPer1k: 0.456, currency: 'USD' },\r\n      // invalid entries ignored\r\n      'bad': { foo: 1, bar: 2 },\r\n    });\r\n    const { getModelPricing, estimateCost } = await import('../Pricing');\r\n\r\n    const p = getModelPricing('custom-model-x');\r\n    expect(p.inputPer1k).toBeCloseTo(0.123, 6);\r\n    expect(p.outputPer1k).toBeCloseTo(0.456, 6);\r\n\r\n    const res = estimateCost('custom-model-x', { inputTokens: 2000, outputTokens: 1000 });\r\n    // 2 * 0.123 + 1 * 0.456 = 0.702\r\n    expect(res.estimatedUSD).toBeCloseTo(0.702, 6);\r\n    expect(res.breakdown.inputUSD).toBeCloseTo(0.246, 6);\r\n    expect(res.breakdown.outputUSD).toBeCloseTo(0.456, 6);\r\n  });\r\n\r\n  it('ignores malformed env JSON without throwing', async () => {\r\n    (process.env as any).MODEL_PRICING_JSON = '{not-json';\r\n    const { getModelPricing } = await import('../Pricing');\r\n    const p = getModelPricing('gpt-4o'); // should use base table\r\n    expect(p.inputPer1k).toBeCloseTo(0.005, 6);\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\optimization\\__tests__\\RequestBatcher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\ClaudePrompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\GeminiPrompts.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[687,690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[687,690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[731,734],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[731,734],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Provider-specific prompt templates for Google Gemini\r\n\r\nimport { ReaderKnowledge, Scene } from '../../../shared/types';\r\n\r\n// Local params type (no new global types)\r\nexport type BuildGeminiParams = {\r\n  readerContext: ReaderKnowledge;\r\n  previousScenes: Scene[];\r\n  newPosition: number;\r\n  sceneText: string;\r\n  genreStyle?: string;\r\n};\r\n\r\nfunction normalizeReader(reader: ReaderKnowledge) {\r\n  const timeline = (reader.establishedTimeline ?? []).map((t) => ({\r\n    label: t.label,\r\n    when: t.when ?? null,\r\n  }));\r\n  const settings = (reader.establishedSettings ?? []).map((l) => ({\r\n    name: l.name,\r\n    id: l.id ?? null,\r\n  }));\r\n  const knownChars = Array.isArray((reader as any).knownCharacters)\r\n    ? [...(reader as any).knownCharacters]\r\n    : Array.from(reader.knownCharacters ?? []);\r\n  return {\r\n    knownCharacters: knownChars.sort(),\r\n    establishedTimeline: timeline,\r\n    revealedPlotPoints: [...(reader.revealedPlotPoints ?? [])].sort(),\r\n    establishedSettings: settings,\r\n  };\r\n}\r\n\r\nfunction minimalScenes(sc: Scene[]) {\r\n  return (sc ?? []).map((s) => ({\r\n    id: s.id,\r\n    position: s.position,\r\n    originalPosition: s.originalPosition,\r\n    wordCount: s.wordCount,\r\n    hasBeenMoved: s.hasBeenMoved,\r\n  }));\r\n}\r\n\r\n/**\r\n * Build instruction and parts for Gemini's content format.\r\n * Deterministic, JSON-only output enforced by instruction and (optionally) response_mime_type upstream.\r\n */\r\nexport function buildGeminiPrompt(params: BuildGeminiParams): {\r\n  instruction: string;\r\n  parts: Array<{ text: string }>;\r\n} {\r\n  const reader = normalizeReader(params.readerContext);\r\n  const prevMeta = minimalScenes(params.previousScenes);\r\n  const prevTexts = (params.previousScenes ?? []).map((s) => ({ id: s.id, text: s.text }));\r\n\r\n  const instruction = [\r\n    '## Role',\r\n    'You are a deterministic continuity analyst for fiction manuscripts.',\r\n    '',\r\n    '## Reader Knowledge and Previous Scenes',\r\n    'Use reader_knowledge and previous_scenes to evaluate what the reader plausibly knows before the current scene.',\r\n    'Do not invent details that are not present. Prefer concise, evidence-backed reasoning.',\r\n    '',\r\n    '## Task',\r\n    `Analyze continuity of the provided scene when moved to position ${String(params.newPosition)} in the manuscript.`,\r\n    'Identify inconsistencies related to pronouns, timeline, and character knowledge, and any other relevant issues.',\r\n    '',\r\n    '## Reasoning Steps',\r\n    '1) Reader knows: derive facts from reader_knowledge and previous_scenes.',\r\n    '2) Scene reveals: extract key facts from the scene.',\r\n    '3) Conflicts: compare (1) and (2) to find contradictions or missing context; cite minimal evidence.',\r\n    '4) Fixes: propose minimal edits or clarifications for each issue.',\r\n    '',\r\n    '## Output Format',\r\n    'Return ONLY valid JSON. No extra text. No code fences.',\r\n    'Top-level structure:',\r\n    '{',\r\n    '  \"issues\": [',\r\n    '    {',\r\n    '      \"type\": \"pronoun_reference|timeline|character_knowledge|other\",',\r\n    '      \"severity\": \"low|medium|high|critical\",',\r\n    '      \"span\": { \"start_index\": 0, \"end_index\": 0 },',\r\n    '      \"explanation\": \"string\",',\r\n    '      \"evidence\": [\"string\"],',\r\n    '      \"suggested_fix\": \"string\",',\r\n    '      \"confidence\": 0.0',\r\n    '    }',\r\n    '  ],',\r\n    '  \"summary\": \"string\",',\r\n    '  \"confidence\": 0.0',\r\n    '}',\r\n  ].join('\\n');\r\n\r\n  const rawParts: string[] = [];\r\n  rawParts.push(`analysis_type: continuity`);\r\n  rawParts.push(`scene_position: ${String(params.newPosition)}`);\r\n  if (params.genreStyle) {\r\n    rawParts.push(`genre_style: ${JSON.stringify(params.genreStyle)}`);\r\n  }\r\n  rawParts.push(`reader_knowledge: ${JSON.stringify(reader)}`);\r\n  rawParts.push(`previous_scenes: ${JSON.stringify({ meta: prevMeta, texts: prevTexts })}`);\r\n  rawParts.push(`scene: ${JSON.stringify({ position: params.newPosition, text: params.sceneText })}`);\r\n\r\n  const parts = rawParts.map((t) => ({ text: t }));\r\n\r\n  return { instruction, parts };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\OpenAIPrompts.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[716,719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[716,719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[760,763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[760,763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4041,4044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4041,4044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// OpenAI-optimized prompt templates with structured outputs\r\n\r\nimport { ReaderKnowledge, Scene } from '../../../shared/types';\r\n\r\n// Local params type for prompt construction (no new global types)\r\nexport type BuildOpenAIParams = {\r\n  readerContext: ReaderKnowledge;\r\n  previousScenes: Scene[];\r\n  newPosition: number;\r\n  sceneText: string;\r\n  genreStyle?: string;\r\n};\r\n\r\nfunction normalizeReader(reader: ReaderKnowledge) {\r\n  const timeline = (reader.establishedTimeline ?? []).map((t) => ({\r\n    label: t.label,\r\n    when: t.when ?? null,\r\n  }));\r\n  const settings = (reader.establishedSettings ?? []).map((l) => ({\r\n    name: l.name,\r\n    id: l.id ?? null,\r\n  }));\r\n  const knownChars = Array.isArray((reader as any).knownCharacters)\r\n    ? [...(reader as any).knownCharacters]\r\n    : Array.from(reader.knownCharacters ?? []);\r\n  return {\r\n    knownCharacters: knownChars.sort(),\r\n    establishedTimeline: timeline,\r\n    revealedPlotPoints: [...(reader.revealedPlotPoints ?? [])].sort(),\r\n    establishedSettings: settings,\r\n  };\r\n}\r\n\r\nfunction minimalScenes(sc: Scene[]) {\r\n  return (sc ?? []).map((s) => ({\r\n    id: s.id,\r\n    position: s.position,\r\n    originalPosition: s.originalPosition,\r\n    wordCount: s.wordCount,\r\n    hasBeenMoved: s.hasBeenMoved,\r\n  }));\r\n}\r\n\r\nexport function buildOpenAIPrompt(params: BuildOpenAIParams): { system: string; user: string } {\r\n  const reader = normalizeReader(params.readerContext);\r\n  const prev = minimalScenes(params.previousScenes);\r\n\r\n  const system = [\r\n    '## Role',\r\n    'You are a deterministic continuity analyst for fiction manuscripts.',\r\n    '',\r\n    '## Task',\r\n    'Identify continuity issues in the current scene using the reader context and prior scenes.',\r\n    'Classify issues using the allowed enums only. Provide concise, evidence-backed explanations.',\r\n    '',\r\n    '## Few-shot',\r\n    'User:',\r\n    '{\"readerContext\":{\"knownCharacters\":[\"A\"],\"establishedTimeline\":[],\"revealedPlotPoints\":[],\"establishedSettings\":[]},',\r\n    '\"previousScenes\":[],\"newPosition\":1,\"sceneText\":\"Sam met Alex. He thanked her.\",\"genreStyle\":\"contemporary\"}',\r\n    'Assistant:',\r\n    '{\"issues\":[{\"type\":\"pronoun_reference\",\"severity\":\"medium\",\"span\":{\"start_index\":14,\"end_index\":26},\"explanation\":\"Ambiguous pronoun \\'He\\' may refer to Sam or Alex.\",\"evidence\":[\"He thanked her\"],\"suggested_fix\":\"Clarify the referent with a name.\",\"confidence\":0.8}],\"summary\":\"One pronoun ambiguity detected.\"}',\r\n    '',\r\n    'User:',\r\n    '{\"readerContext\":{\"knownCharacters\":[\"A\"],\"establishedTimeline\":[{\"label\":\"yesterday\"}],\"revealedPlotPoints\":[],\"establishedSettings\":[]},',\r\n    '\"previousScenes\":[],\"newPosition\":2,\"sceneText\":\"Yesterday it rained. Today it is still yesterday.\",\"genreStyle\":\"mystery\"}',\r\n    'Assistant:',\r\n    '{\"issues\":[{\"type\":\"timeline\",\"severity\":\"high\",\"span\":{\"start_index\":28,\"end_index\":58},\"explanation\":\"Conflicting time markers: Today vs yesterday.\",\"evidence\":[\"Today it is still yesterday\"],\"suggested_fix\":\"Align timeline to a single day.\",\"confidence\":0.85}],\"summary\":\"One timeline inconsistency detected.\"}',\r\n    '',\r\n    '## Output Format',\r\n    'Return ONLY valid JSON per the schema.',\r\n    'No markdown. No code fences. No additional text.',\r\n    '',\r\n    'Top-level keys:',\r\n    '{ \"issues\": Issue[], \"summary\": string, \"confidence?\": number }',\r\n  ].join('\\n');\r\n\r\n  const userParts: string[] = [];\r\n  userParts.push('## Input');\r\n  userParts.push(`analysisType: continuity`);\r\n  userParts.push(`newPosition: ${String(params.newPosition)}`);\r\n  if (params.genreStyle) {\r\n    userParts.push(`genreStyle: ${JSON.stringify(params.genreStyle)}`);\r\n  }\r\n  userParts.push(`readerContext: ${JSON.stringify(reader)}`);\r\n  userParts.push(`previousScenes: ${JSON.stringify(prev)}`);\r\n  userParts.push(`sceneText: ${JSON.stringify(params.sceneText)}`);\r\n\r\n  const user = userParts.join('\\n');\r\n\r\n  return { system, user };\r\n}\r\n\r\n// JSON Schema aligned to Zod AnalysisResponseSchema (self-contained)\r\nexport function getOpenAIResponseJsonSchema(): Record<string, any> {\r\n  return {\r\n    $schema: 'http://json-schema.org/draft-07/schema#',\r\n    title: 'Continuity Analysis',\r\n    type: 'object',\r\n    additionalProperties: false,\r\n    properties: {\r\n      issues: {\r\n        type: 'array',\r\n        items: {\r\n          type: 'object',\r\n          additionalProperties: false,\r\n          properties: {\r\n            type: { enum: ['pronoun_reference', 'timeline', 'character_knowledge', 'other'] },\r\n            severity: { enum: ['low', 'medium', 'high', 'critical'] },\r\n            span: {\r\n              anyOf: [\r\n                {\r\n                  type: 'object',\r\n                  additionalProperties: false,\r\n                  properties: {\r\n                    start_index: { type: 'integer', minimum: 0 },\r\n                    end_index: { type: 'integer', minimum: 0 },\r\n                  },\r\n                  required: ['start_index', 'end_index'],\r\n                },\r\n                { type: 'null' },\r\n              ],\r\n            },\r\n            explanation: { type: 'string', minLength: 1 },\r\n            evidence: { type: 'array', items: { type: 'string' } },\r\n            suggested_fix: { type: 'string' },\r\n            confidence: { type: 'number', minimum: 0, maximum: 1 },\r\n          },\r\n          required: ['type', 'severity', 'explanation'],\r\n        },\r\n      },\r\n      summary: { type: 'string' },\r\n      confidence: { type: 'number', minimum: 0, maximum: 1 },\r\n    },\r\n    required: ['issues', 'summary'],\r\n  };\r\n}\r\n\r\nexport function getOpenAIResponseFormat() {\r\n  return {\r\n    type: 'json_schema' as const,\r\n    json_schema: {\r\n      name: 'continuity_analysis',\r\n      schema: getOpenAIResponseJsonSchema(),\r\n      strict: true,\r\n    },\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\__tests__\\ClaudePrompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\__tests__\\GeminiPrompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\prompts\\__tests__\\OpenAIPrompts.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2543,2546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2543,2546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3189,3192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3189,3192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3468,3471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3468,3471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\r\nimport { buildOpenAIPrompt, getOpenAIResponseJsonSchema, getOpenAIResponseFormat } from '../OpenAIPrompts';\r\nimport type { ReaderKnowledge, Scene } from '../../../../shared/types';\r\n\r\nfunction makeReaderKnowledge(): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(['Alice', 'Bob']),\r\n    establishedTimeline: [{ label: 'Day 1', when: '2025-01-01' }],\r\n    revealedPlotPoints: ['Alice met Bob'],\r\n    establishedSettings: [{ name: 'Cafe Central', id: 'loc-1' }],\r\n  };\r\n}\r\n\r\nfunction makeScene(id: string, position: number, text = 'Sample scene text.'): Scene {\r\n  return {\r\n    id,\r\n    text,\r\n    wordCount: text.split(/\\s+/).length,\r\n    position,\r\n    originalPosition: position,\r\n    characters: ['Alice', 'Bob'],\r\n    timeMarkers: ['later'],\r\n    locationMarkers: ['Cafe Central'],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending',\r\n  } as Scene;\r\n}\r\n\r\ndescribe('OpenAI Prompts - buildOpenAIPrompt', () => {\r\n  it('returns deterministic system and user strings with required sections', () => {\r\n    const reader = makeReaderKnowledge();\r\n    const previousScenes = [makeScene('s1', 1), makeScene('s2', 2)];\r\n    const newPosition = 3;\r\n    const sceneText = 'Alice looks at Bob and wonders what he knows.';\r\n    const { system, user } = buildOpenAIPrompt({\r\n      readerContext: reader,\r\n      previousScenes,\r\n      newPosition,\r\n      sceneText,\r\n      genreStyle: 'contemporary',\r\n    });\r\n\r\n    // System checks: markdown headers and Few-shot section with explicit JSON-only instruction\r\n    expect(system).toContain('## Role');\r\n    expect(system).toContain('## Task');\r\n    expect(system).toContain('## Few-shot');\r\n    expect(system).toContain('## Output Format');\r\n    expect(system).toContain('Return ONLY valid JSON');\r\n\r\n    // User checks: contains key fields\r\n    expect(user).toContain('readerContext: ');\r\n    expect(user).toContain('previousScenes: ');\r\n    expect(user).toContain('newPosition: ');\r\n    expect(user).toContain('sceneText: ');\r\n  });\r\n});\r\n\r\ndescribe('OpenAI Prompts - JSON Schema', () => {\r\n  it('exports a JSON Schema with required top-level and nested keys', () => {\r\n    const schema = getOpenAIResponseJsonSchema();\r\n    // Top-level\r\n    expect(schema).toBeTruthy();\r\n    expect(schema.type).toBe('object');\r\n    expect(schema.properties).toBeTruthy();\r\n    expect(Object.keys(schema.properties)).toEqual(expect.arrayContaining(['issues', 'summary']));\r\n\r\n    // Nested issue keys\r\n    const issueItem = (schema.properties.issues as any).items;\r\n    expect(issueItem).toBeTruthy();\r\n    expect(issueItem.properties).toBeTruthy();\r\n    expect(Object.keys(issueItem.properties)).toEqual(\r\n      expect.arrayContaining(['type', 'severity', 'span', 'explanation', 'evidence', 'suggested_fix', 'confidence'])\r\n    );\r\n  });\r\n\r\n  it('provides response_format for OpenAI structured outputs with correct name and schema shape', () => {\r\n    const rf = getOpenAIResponseFormat();\r\n    expect(rf.type).toBe('json_schema');\r\n    expect(rf.json_schema).toBeTruthy();\r\n    expect(rf.json_schema.name).toBe('continuity_analysis');\r\n\r\n    const schema = rf.json_schema.schema as Record<string, any>;\r\n    expect(schema).toBeTruthy();\r\n    expect(schema.type).toBe('object');\r\n    expect(schema.properties).toBeTruthy();\r\n    expect(Object.keys(schema.properties)).toEqual(expect.arrayContaining(['issues', 'summary']));\r\n    const issueProps = (schema.properties.issues as any)?.items?.properties ?? {};\r\n    expect(Object.keys(issueProps)).toEqual(expect.arrayContaining(['type', 'severity', 'span']));\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\BaseProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8852,8855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8852,8855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  BaseProviderConfig,\r\n  ProviderError,\r\n  ProviderName,\r\n  RateLimitError,\r\n  TimeoutError,\r\n} from '../types';\r\nimport CircuitBreaker, { backoffSchedule } from '../utils/CircuitBreaker';\r\nimport { estimateTokensForModel } from '../utils/Tokenizers';\r\nimport { estimateCost as estimateUsdCost } from '../optimization/Pricing';\r\n/**\r\n * Abstract base class for AI providers.\r\n * Handles:\r\n * - Circuit breaker integration\r\n * - Exponential backoff retries\r\n * - Timeouts using AbortController\r\n * - Standardized error translation\r\n */\r\nexport abstract class BaseProvider<C extends BaseProviderConfig> {\r\n  protected readonly name: ProviderName;\r\n  protected readonly config: C;\r\n  protected readonly breaker: CircuitBreaker;\r\n\r\n  // Session-scoped token accounting (soft, in-memory)\r\n  private __sessionInputTokens = 0;\r\n  private __sessionOutputTokens = 0;\r\n\r\n  constructor(name: ProviderName, config: C, breaker: CircuitBreaker) {\r\n    this.name = name;\r\n    this.config = config;\r\n    this.breaker = breaker;\r\n  }\r\n\r\n  /**\r\n   * Perform continuity analysis with the provider.\r\n   */\r\n  public abstract analyze(req: AnalysisRequest): Promise<AnalysisResponse>;\r\n\r\n  /**\r\n   * Orchestrate fetch with retries, backoff, circuit breaker, and timeouts.\r\n   * Ensures each function is focused and short.\r\n   */\r\n  protected async fetchWithRetry(\r\n    url: string,\r\n    init: RequestInit,\r\n    maxRetries = 5\r\n  ): Promise<Response> {\r\n    const attempts = Math.max(1, Math.min(maxRetries, backoffSchedule().length + 1));\r\n    for (let attempt = 0; attempt < attempts; attempt++) {\r\n      try {\r\n        return await this.attemptOnce(url, init);\r\n      } catch (err) {\r\n        if (this.isCircuitOpen(err)) throw err;\r\n        if (!this.shouldRetry(err) || attempt === attempts - 1) throw err;\r\n        await this.delay(this.getBackoffDelay(attempt));\r\n      }\r\n    }\r\n    // Unreachable: loop either returns or throws\r\n    throw new ProviderError(this.name, 'Unknown retry orchestration error');\r\n  }\r\n\r\n  /**\r\n   * Single attempt guarded by circuit breaker with precise error classification.\r\n   */\r\n  private async attemptOnce(url: string, init: RequestInit): Promise<Response> {\r\n    this.breaker.beforeCall(this.name);\r\n    try {\r\n      const res = await this.timedFetch(url, init, this.timeoutMs());\r\n      if (res.status === 429) {\r\n        const rl = new RateLimitError(this.name, '429 Too Many Requests');\r\n        this.breaker.onFailure(this.name, rl);\r\n        throw rl;\r\n      }\r\n      if (!res.ok) {\r\n        const body = await this.safeText(res);\r\n        const retriable = res.status >= 500 || res.status === 408;\r\n        const perr = new ProviderError(\r\n          this.name,\r\n          `HTTP ${res.status} ${res.statusText} from ${this.name}: ${body.slice(0, 500)}`,\r\n          { status: res.status, retriable }\r\n        );\r\n        this.breaker.onFailure(this.name, perr);\r\n        throw perr;\r\n      }\r\n      this.breaker.onSuccess(this.name);\r\n      return res;\r\n    } catch (e) {\r\n      if (e instanceof TimeoutError) {\r\n        this.breaker.onFailure(this.name, e);\r\n      }\r\n      // CircuitBreakerOpenError is thrown before reaching here; allow it to bubble\r\n      if (this.isCircuitOpen(e)) throw e;\r\n      // For other network errors, wrap if last resort handled by orchestrator\r\n      if (!(e instanceof ProviderError) && !(e instanceof RateLimitError) && !(e instanceof TimeoutError)) {\r\n        const pErr = new ProviderError(this.name, `Network error calling ${this.name}`, {\r\n          cause: e,\r\n          retriable: true,\r\n        });\r\n        this.breaker.onFailure(this.name, pErr);\r\n        throw pErr;\r\n      }\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  private shouldRetry(err: unknown): boolean {\r\n    if (err instanceof TimeoutError) return true;\r\n    if (err instanceof RateLimitError) return true;\r\n    if (err instanceof ProviderError) return err.isRetriable === true;\r\n    return false;\r\n  }\r\n\r\n  private isCircuitOpen(err: unknown): boolean {\r\n    return Boolean(err && typeof err === 'object' && (err as Error).name === 'CircuitBreakerOpenError');\r\n  }\r\n\r\n  private getBackoffDelay(attempt: number): number {\r\n    const sched = backoffSchedule();\r\n    const idx = Math.min(attempt, sched.length - 1);\r\n    return sched[idx] ?? 1000;\r\n  }\r\n\r\n  /**\r\n   * Providers must build their own prompt payloads appropriate for their APIs.\r\n   * This base class no longer constructs a generic prompt.\r\n   */\r\n  protected abstract formatPrompt(req: AnalysisRequest): unknown;\r\n\r\n  /**\r\n   * Backward-compatible estimateCost used by existing providers.\r\n   * Reimplemented to use token-based pricing with heuristics.\r\n   * Note: Output tokens are not known here; this returns input-only estimate.\r\n   */\r\n  protected estimateCost(req: AnalysisRequest, _costTier: 'low' | 'medium' | 'high'): number {\r\n    const modelId = this.config.model ?? '';\r\n    const inputTokens = this.estimateInputTokensForRequest(modelId, req);\r\n    const { estimatedUSD } = estimateUsdCost(modelId || 'unknown', { inputTokens, outputTokens: 0 });\r\n    // Round to 6 decimals to be stable\r\n    return Math.round(estimatedUSD * 1e6) / 1e6;\r\n  }\r\n\r\n  /**\r\n   * Preferred cost estimator when token usage is available (or computed by caller).\r\n   */\r\n  protected estimateCostFromUsage(\r\n    modelId: string,\r\n    usage: { inputTokens: number; outputTokens?: number }\r\n  ): number {\r\n    const { estimatedUSD } = estimateUsdCost(modelId || 'unknown', usage);\r\n    return Math.round(estimatedUSD * 1e6) / 1e6;\r\n  }\r\n\r\n  /**\r\n   * Estimate input tokens for a request based on scene text and previous scenes.\r\n   * Deterministic, heuristic if tokenizer not available.\r\n   */\r\n  protected estimateInputTokensForRequest(modelId: string, req: AnalysisRequest): number {\r\n    const sceneText = req.scene?.text ?? '';\r\n    const prevTexts = (req.previousScenes ?? []).map((s) => s?.text ?? '');\r\n    let total = estimateTokensForModel(modelId, sceneText);\r\n    for (const t of prevTexts) total += estimateTokensForModel(modelId, t);\r\n    // small fixed overhead for separators/roles\r\n    total += 8;\r\n    return Math.max(1, total | 0);\r\n  }\r\n\r\n  /**\r\n   * Enforce optional input token budgets by trimming oldest previousScenes first.\r\n   * Returns possibly-trimmed request and trimming metadata. Defaults to no-op when budgets undefined.\r\n   * If HARD_FAIL_ON_BUDGET === 'true', throws ProviderError when input exceeds budget after best-effort trimming.\r\n   */\r\n  protected enforceInputBudget(\r\n    req: AnalysisRequest,\r\n    modelId?: string\r\n  ): { req: AnalysisRequest; meta?: { trimmed: true; trimmedCount: number; beforeTokens: number; afterTokens: number; budget: number } } {\r\n    const budgets = this.readBudgetsFromEnv();\r\n    const inBudget = budgets.maxInputTokensPerRequest;\r\n    if (!inBudget || inBudget <= 0) {\r\n      return { req };\r\n    }\r\n\r\n    // Compute current input tokens\r\n    const model = modelId ?? this.config.model ?? '';\r\n    const beforeTokens = this.estimateInputTokensForRequest(model, req);\r\n\r\n    if (beforeTokens <= inBudget) {\r\n      return { req };\r\n    }\r\n\r\n    // Trim previousScenes from oldest to newest until within budget, preserving full scene text\r\n    const clone: AnalysisRequest = {\r\n      ...req,\r\n      previousScenes: [...(req.previousScenes ?? [])],\r\n    };\r\n\r\n    let trimmedCount = 0;\r\n    while (clone.previousScenes.length > 0) {\r\n      clone.previousScenes.shift();\r\n      trimmedCount++;\r\n      const est = this.estimateInputTokensForRequest(model, clone);\r\n      if (est <= inBudget) {\r\n        const afterTokens = est;\r\n        // Update session accounting (soft)\r\n        this.__sessionInputTokens += afterTokens;\r\n        return {\r\n          req: clone,\r\n          meta: { trimmed: true, trimmedCount, beforeTokens, afterTokens, budget: inBudget },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Could not fit under budget even after removing all previousScenes\r\n    const afterTokens = this.estimateInputTokensForRequest(model, {\r\n      ...clone,\r\n      previousScenes: [],\r\n    });\r\n    const hardFail = (process.env?.HARD_FAIL_ON_BUDGET ?? '').toLowerCase() === 'true';\r\n    if (hardFail && afterTokens > inBudget) {\r\n      throw new ProviderError(this.name, `Input token budget exceeded (after=${afterTokens}, budget=${inBudget})`, {\r\n        retriable: false,\r\n      });\r\n    }\r\n    this.__sessionInputTokens += afterTokens;\r\n    return {\r\n      req: { ...clone, previousScenes: [] },\r\n      meta: { trimmed: true, trimmedCount, beforeTokens, afterTokens, budget: inBudget },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Read optional budgets from environment. Undefined/NaN -> undefined.\r\n   */\r\n  private readBudgetsFromEnv(): {\r\n    maxInputTokensPerRequest?: number;\r\n    maxOutputTokensPerRequest?: number;\r\n    maxTokensPerSession?: number;\r\n  } {\r\n    const parseNum = (v: any): number | undefined => {\r\n      const n = Number(v);\r\n      return Number.isFinite(n) && n > 0 ? Math.trunc(n) : undefined;\r\n    };\r\n    return {\r\n      maxInputTokensPerRequest: parseNum(process.env?.MAX_INPUT_TOKENS_PER_REQUEST),\r\n      maxOutputTokensPerRequest: parseNum(process.env?.MAX_OUTPUT_TOKENS_PER_REQUEST),\r\n      maxTokensPerSession: parseNum(process.env?.MAX_TOKENS_PER_SESSION),\r\n    };\r\n  }\r\n\r\n  // Internals\r\n\r\n  private timeoutMs(): number {\r\n    return this.config.timeoutMs ?? 30_000;\r\n  }\r\n\r\n  private async timedFetch(url: string, init: RequestInit, timeoutMs: number): Promise<Response> {\r\n    const controller = new AbortController();\r\n    const id = setTimeout(() => controller.abort(), timeoutMs);\r\n    try {\r\n      const res = await fetch(url, { ...init, signal: controller.signal });\r\n      return res;\r\n    } catch (e) {\r\n      if ((e as Error)?.name === 'AbortError') {\r\n        throw new TimeoutError(this.name, timeoutMs);\r\n      }\r\n      throw e;\r\n    } finally {\r\n      clearTimeout(id);\r\n    }\r\n  }\r\n\r\n  private async safeText(res: Response): Promise<string> {\r\n    try {\r\n      return await res.text();\r\n    } catch {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  private async delay(ms: number): Promise<void> {\r\n    await new Promise((r) => setTimeout(r, ms));\r\n  }\r\n}\r\n\r\nexport default BaseProvider;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\ClaudeProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'costTierForModel' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3245,3248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3245,3248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":108,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":108,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3725,3725],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4438,4441],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4438,4441],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import BaseProvider from './BaseProvider';\r\nimport {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  ClaudeConfig,\r\n  ProviderError,\r\n  ProviderName,\r\n  ValidationError,\r\n} from '../types';\r\nimport { validateAndNormalize } from '../utils/ResponseValidator';\r\nimport { buildClaudePrompt } from '../prompts/ClaudePrompts';\r\nimport { estimateMessageTokens, estimateTokensForModel } from '../utils/Tokenizers';\r\nimport { estimateCost as estimateUsdCost } from '../optimization/Pricing';\r\n\r\nconst ANTHROPIC_VERSION = '2023-06-01';\r\n\r\nfunction costTierForModel(model: string | undefined): 'low' | 'medium' | 'high' {\r\n  const m = (model ?? '').toLowerCase();\r\n  if (m.includes('opus') || m.includes('o')) return 'high';\r\n  if (m.includes('sonnet') || m.includes('haiku') || m.includes('sonnet-4')) return 'medium';\r\n  return 'medium';\r\n}\r\n\r\n/**\r\n * Claude (Anthropic) provider implementation using Messages API.\r\n */\r\nexport class ClaudeProvider extends BaseProvider<ClaudeConfig> {\r\n  constructor(config: ClaudeConfig, breaker: import('../utils/CircuitBreaker').default) {\r\n    super('anthropic' as ProviderName, config, breaker);\r\n  }\r\n\r\n  /**\r\n   * Build Anthropic-specific prompt payload using XML-style template.\r\n   */\r\n  protected formatPrompt(req: AnalysisRequest): string {\r\n    const readerContext = req.readerContext;\r\n    const previousScenes = req.previousScenes;\r\n    const newPosition = req.scene.position;\r\n    const sceneText = req.scene.text;\r\n    return buildClaudePrompt(readerContext, previousScenes, newPosition, sceneText);\r\n  }\r\n\r\n  /**\r\n   * Execute continuity analysis via Anthropic Messages API.\r\n   */\r\n  public async analyze(req: AnalysisRequest): Promise<AnalysisResponse> {\r\n    if (!this.config.apiKey) {\r\n      throw new ProviderError('anthropic', 'Missing Anthropic API key in configuration');\r\n    }\r\n\r\n    const modelLabel = this.config.model ?? 'claude-sonnet-4';\r\n    const url =\r\n      this.config.baseUrl?.trim() ||\r\n      'https://api.anthropic.com/v1/messages';\r\n\r\n    // Enforce optional budgets by trimming older previousScenes\r\n    const budgeted = this.enforceInputBudget(req, modelLabel);\r\n    const effReq = budgeted.req;\r\n\r\n    const prompt = this.formatPrompt(effReq) as string;\r\n\r\n    const body = {\r\n      model: modelLabel,\r\n      system:\r\n        'You are a meticulous continuity analyst. Respond with ONLY valid JSON per the requested schema. No extra text.',\r\n      messages: [\r\n        {\r\n          role: 'user',\r\n          content: [{ type: 'text', text: prompt }],\r\n        },\r\n      ],\r\n      max_tokens: 2048,\r\n      temperature: 0.2,\r\n    };\r\n\r\n    // Pre-flight estimate of input tokens using simplified message view\r\n    let inputTokensEstimate = estimateMessageTokens(modelLabel, [\r\n      { role: 'system', content: body.system },\r\n      { role: 'user', content: prompt },\r\n    ]);\r\n\r\n    const headers: HeadersInit = {\r\n      'content-type': 'application/json',\r\n      'x-api-key': this.config.apiKey,\r\n      'anthropic-version': ANTHROPIC_VERSION,\r\n    };\r\n\r\n    const started = Date.now();\r\n    try {\r\n      const res = await this.fetchWithRetry(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body),\r\n      });\r\n\r\n      const raw = (await res.json()) as any;\r\n      const normalized = validateAndNormalize('anthropic', raw, modelLabel);\r\n\r\n      // Prefer provider usage when available\r\n      if (raw && raw.usage && Number.isFinite(raw.usage.input_tokens)) {\r\n        inputTokensEstimate = Math.max(0, Number(raw.usage.input_tokens));\r\n      }\r\n\r\n      // Output tokens: prefer usage, else estimate from first content text\r\n      let outputText = '';\r\n      try {\r\n        outputText = raw?.content?.[0]?.text ?? '';\r\n      } catch {}\r\n      let outputTokensEstimate =\r\n        raw && raw.usage && Number.isFinite(raw.usage.output_tokens)\r\n          ? Math.max(0, Number(raw.usage.output_tokens))\r\n          : estimateTokensForModel(modelLabel, String(outputText ?? ''));\r\n\r\n      const durationMs = Date.now() - started;\r\n\r\n      const costEstimate = this.estimateCostFromUsage(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      });\r\n\r\n      const breakdown = estimateUsdCost(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      }).breakdown;\r\n\r\n      const confidence = normalized.metadata.confidence ?? 0.5;\r\n\r\n      const meta: any = {\r\n        modelUsed: modelLabel,\r\n        provider: 'anthropic',\r\n        costEstimate,\r\n        durationMs,\r\n        confidence,\r\n        cached: false,\r\n      };\r\n      if (budgeted.meta) {\r\n        meta.trimmed = true;\r\n        meta.trimDetails = budgeted.meta;\r\n      }\r\n      meta.tokensInputEstimated = inputTokensEstimate;\r\n      meta.tokensOutputEstimated = outputTokensEstimate;\r\n      meta.costBreakdownUSD = breakdown;\r\n\r\n      const out: AnalysisResponse = {\r\n        issues: normalized.issues,\r\n        metadata: meta as AnalysisResponse['metadata'],\r\n      };\r\n\r\n      return out;\r\n    } catch (err) {\r\n      // TODO: Replace with production logger\r\n      console.log('[ClaudeProvider] analyze error:', err);\r\n      if (err instanceof ValidationError) {\r\n        throw err;\r\n      }\r\n      if (err && typeof err === 'object' && (err as Error).name === 'CircuitBreakerOpenError') {\r\n        throw err;\r\n      }\r\n      throw new ProviderError('anthropic', 'Claude analyze failed', { cause: err });\r\n    }\r\n  }\r\n}\r\n\r\nexport default ClaudeProvider;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\GeminiProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'costTierForModel' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1870,1873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1870,1873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1903,1906],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1903,1906],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3808,3811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3808,3811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":125,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":125,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4427,4427],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":150,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5354,5357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5354,5357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import BaseProvider from './BaseProvider';\r\nimport {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  GeminiConfig,\r\n  ProviderError,\r\n  ProviderName,\r\n  ValidationError,\r\n} from '../types';\r\nimport { validateAndNormalize } from '../utils/ResponseValidator';\r\nimport { buildGeminiPrompt } from '../prompts/GeminiPrompts';\r\nimport { estimateMessageTokens, estimateTokensForModel } from '../utils/Tokenizers';\r\nimport { estimateCost as estimateUsdCost } from '../optimization/Pricing';\r\n\r\nfunction buildGeminiUrl(model: string, apiKey: string, baseUrl?: string): string {\r\n  if (baseUrl && baseUrl.trim().length > 0) {\r\n    // Expect caller to include model + api key if they override baseUrl\r\n    return baseUrl;\r\n  }\r\n  const encodedModel = encodeURIComponent(model);\r\n  return `https://generativelanguage.googleapis.com/v1beta/models/${encodedModel}:generateContent?key=${encodeURIComponent(\r\n    apiKey\r\n  )}`;\r\n}\r\n\r\nfunction costTierForModel(model: string | undefined): 'low' | 'medium' | 'high' {\r\n  const m = (model ?? '').toLowerCase();\r\n  if (m.includes('pro')) return 'low';\r\n  if (m.includes('flash') || m.includes('lite')) return 'low';\r\n  return 'medium';\r\n}\r\n\r\n/**\r\n * Google Gemini provider implementation using generateContent API.\r\n */\r\nexport class GeminiProvider extends BaseProvider<GeminiConfig> {\r\n  constructor(config: GeminiConfig, breaker: import('../utils/CircuitBreaker').default) {\r\n    super('google' as ProviderName, config, breaker);\r\n  }\r\n\r\n  /**\r\n   * Build Gemini-specific content structure with instruction and parts.\r\n   */\r\n  protected formatPrompt(req: AnalysisRequest): { instruction: string; parts: Array<{ text: string }> } {\r\n    const readerContext = req.readerContext;\r\n    const previousScenes = req.previousScenes;\r\n    const newPosition = req.scene.position;\r\n    const sceneText = req.scene.text;\r\n    const genreStyle = (req as any).genreStyle ?? (req.scene as any)?.genreStyle ?? undefined;\r\n\r\n    return buildGeminiPrompt({\r\n      readerContext,\r\n      previousScenes,\r\n      newPosition,\r\n      sceneText,\r\n      genreStyle,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute continuity analysis via Gemini generateContent.\r\n   */\r\n  public async analyze(req: AnalysisRequest): Promise<AnalysisResponse> {\r\n    if (!this.config.apiKey) {\r\n      throw new ProviderError('google', 'Missing Google API key in configuration');\r\n    }\r\n\r\n    const modelLabel = this.config.model ?? 'gemini-2-5-pro';\r\n    const url = buildGeminiUrl(modelLabel, this.config.apiKey, this.config.baseUrl);\r\n\r\n    // Enforce optional input budgets (trim oldest previousScenes)\r\n    const budgeted = this.enforceInputBudget(req, modelLabel);\r\n    const effReq = budgeted.req;\r\n\r\n    const { instruction, parts } = this.formatPrompt(effReq) as { instruction: string; parts: Array<{ text: string }> };\r\n\r\n    const body = {\r\n      systemInstruction: {\r\n        role: 'system',\r\n        parts: [{ text: instruction }],\r\n      },\r\n      contents: [\r\n        {\r\n          role: 'user',\r\n          parts,\r\n        },\r\n      ],\r\n      generationConfig: {\r\n        temperature: 0.2,\r\n        // Prefer JSON-only responses if supported by the API\r\n        response_mime_type: 'application/json',\r\n      },\r\n    };\r\n\r\n    // Pre-flight estimate of input tokens using simplified message view\r\n    let inputTokensEstimate = estimateMessageTokens(modelLabel, [\r\n      { role: 'system', content: instruction },\r\n      { role: 'user', content: parts.map((p) => p.text ?? '').join('\\n') },\r\n    ]);\r\n\r\n    const headers: HeadersInit = {\r\n      'content-type': 'application/json',\r\n    };\r\n\r\n    const started = Date.now();\r\n    try {\r\n      const res = await this.fetchWithRetry(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body),\r\n      });\r\n\r\n      const raw = (await res.json()) as any;\r\n      const normalized = validateAndNormalize('google', raw, modelLabel);\r\n\r\n      // Gemini v1beta responses may not include token usage in public API.\r\n      // If present in future, prefer it; else heuristic on text length.\r\n      // Attempt to extract output text\r\n      let outputText = '';\r\n      try {\r\n        const firstCandidate = raw?.candidates?.[0];\r\n        const partsOut = firstCandidate?.content?.parts ?? [];\r\n        const withText = partsOut.find((p: { text?: string }) => typeof p.text === 'string' && ((p.text?.length ?? 0) > 0));\r\n        outputText = withText?.text ?? '';\r\n      } catch {}\r\n\r\n      // Token usage fields if they appear in future:\r\n      const usageIn = Number(raw?.usageMetadata?.promptTokenCount);\r\n      const usageOut = Number(raw?.usageMetadata?.candidatesTokenCount);\r\n      if (Number.isFinite(usageIn)) inputTokensEstimate = Math.max(0, usageIn);\r\n\r\n      const outputTokensEstimate = Number.isFinite(usageOut)\r\n        ? Math.max(0, usageOut)\r\n        : estimateTokensForModel(modelLabel, String(outputText ?? ''));\r\n\r\n      const durationMs = Date.now() - started;\r\n\r\n      const costEstimate = this.estimateCostFromUsage(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      });\r\n\r\n      const breakdown = estimateUsdCost(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      }).breakdown;\r\n\r\n      const confidence = normalized.metadata.confidence ?? 0.5;\r\n\r\n      const meta: any = {\r\n        modelUsed: modelLabel,\r\n        provider: 'google',\r\n        costEstimate,\r\n        durationMs,\r\n        confidence,\r\n        cached: false,\r\n      };\r\n      if (budgeted.meta) {\r\n        meta.trimmed = true;\r\n        meta.trimDetails = budgeted.meta;\r\n      }\r\n      meta.tokensInputEstimated = inputTokensEstimate;\r\n      meta.tokensOutputEstimated = outputTokensEstimate;\r\n      meta.costBreakdownUSD = breakdown;\r\n\r\n      const out: AnalysisResponse = {\r\n        issues: normalized.issues,\r\n        metadata: meta as AnalysisResponse['metadata'],\r\n      };\r\n\r\n      return out;\r\n    } catch (err) {\r\n      // TODO: Replace with production logger\r\n      console.log('[GeminiProvider] analyze error:', err);\r\n      if (err instanceof ValidationError) {\r\n        throw err;\r\n      }\r\n      if (err && typeof err === 'object' && (err as Error).name === 'CircuitBreakerOpenError') {\r\n        throw err;\r\n      }\r\n      throw new ProviderError('google', 'Gemini analyze failed', { cause: err });\r\n    }\r\n  }\r\n}\r\n\r\nexport default GeminiProvider;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\OpenAIProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'costTierForModel' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1490,1493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1490,1493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1523,1526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1523,1526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3271,3274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3271,3274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":106,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":106,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3761,3761],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4583,4586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4583,4586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import BaseProvider from './BaseProvider';\r\nimport {\r\n  AnalysisRequest,\r\n  AnalysisResponse,\r\n  OpenAIConfig,\r\n  ProviderError,\r\n  ProviderName,\r\n  ValidationError,\r\n} from '../types';\r\nimport { validateAndNormalize } from '../utils/ResponseValidator';\r\nimport { buildOpenAIPrompt, getOpenAIResponseFormat } from '../prompts/OpenAIPrompts';\r\nimport { estimateMessageTokens, estimateTokensForModel } from '../utils/Tokenizers';\r\nimport { estimateCost as estimateUsdCost } from '../optimization/Pricing';\r\n\r\nfunction costTierForModel(model: string | undefined): 'low' | 'medium' | 'high' {\r\n  const m = (model ?? '').toLowerCase();\r\n  if (m.includes('gpt-5')) return 'low';\r\n  if (m.includes('o1') || m.includes('o3') || m.includes('gpt-4')) return 'high';\r\n  return 'medium';\r\n}\r\n\r\n/**\r\n * OpenAI Chat Completions provider implementation.\r\n */\r\nexport class OpenAIProvider extends BaseProvider<OpenAIConfig> {\r\n  constructor(config: OpenAIConfig, breaker: import('../utils/CircuitBreaker').default) {\r\n    super('openai' as ProviderName, config, breaker);\r\n  }\r\n\r\n  /**\r\n   * Build OpenAI-specific structured messages using templates.\r\n   */\r\n  protected formatPrompt(req: AnalysisRequest): { system: string; user: string } {\r\n    const readerContext = req.readerContext;\r\n    const previousScenes = req.previousScenes;\r\n    const newPosition = req.scene.position;\r\n    const sceneText = req.scene.text;\r\n    // Optional, mapped locally without type changes\r\n    const genreStyle = (req as any).genreStyle ?? (req.scene as any)?.genreStyle ?? undefined;\r\n\r\n    return buildOpenAIPrompt({\r\n      readerContext,\r\n      previousScenes,\r\n      newPosition,\r\n      sceneText,\r\n      genreStyle,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute continuity analysis via OpenAI chat.completions.\r\n   */\r\n  public async analyze(req: AnalysisRequest): Promise<AnalysisResponse> {\r\n    if (!this.config.apiKey) {\r\n      throw new ProviderError('openai', 'Missing OpenAI API key in configuration');\r\n    }\r\n\r\n    const modelLabel = this.config.model ?? 'gpt-5';\r\n    const url = this.config.baseUrl?.trim() || 'https://api.openai.com/v1/chat/completions';\r\n\r\n    // Enforce optional budgets (soft trimming oldest previousScenes)\r\n    const budgeted = this.enforceInputBudget(req, modelLabel);\r\n    const effReq = budgeted.req;\r\n\r\n    const { system, user } = this.formatPrompt(effReq) as { system: string; user: string };\r\n\r\n    const body = {\r\n      model: modelLabel,\r\n      messages: [\r\n        { role: 'system', content: system },\r\n        { role: 'user', content: user },\r\n      ],\r\n      temperature: 0.2,\r\n      response_format: getOpenAIResponseFormat(),\r\n      // We avoid streaming to keep simpler validation path\r\n    };\r\n\r\n    // Pre-flight input token estimate from actual payload\r\n    let inputTokensEstimate = estimateMessageTokens(modelLabel, body.messages as Array<{ role?: string; content: string }>);\r\n\r\n    const headers: HeadersInit = {\r\n      'content-type': 'application/json',\r\n      authorization: `Bearer ${this.config.apiKey}`,\r\n    };\r\n\r\n    const started = Date.now();\r\n    try {\r\n      const res = await this.fetchWithRetry(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body),\r\n      });\r\n\r\n      const raw = (await res.json()) as any;\r\n      const normalized = validateAndNormalize('openai', raw, modelLabel);\r\n\r\n      // Prefer provider-reported usage when present\r\n      if (raw && raw.usage && Number.isFinite(raw.usage.prompt_tokens)) {\r\n        inputTokensEstimate = Math.max(0, Number(raw.usage.prompt_tokens));\r\n      }\r\n\r\n      // Estimate output tokens from model content if usage missing\r\n      let outputText = '';\r\n      try {\r\n        outputText = raw?.choices?.[0]?.message?.content ?? '';\r\n      } catch {}\r\n      let outputTokensEstimate =\r\n        raw && raw.usage && Number.isFinite(raw.usage.completion_tokens)\r\n          ? Math.max(0, Number(raw.usage.completion_tokens))\r\n          : estimateTokensForModel(modelLabel, String(outputText ?? ''));\r\n\r\n      const durationMs = Date.now() - started;\r\n\r\n      const costEstimate = this.estimateCostFromUsage(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      });\r\n\r\n      const breakdown = estimateUsdCost(modelLabel, {\r\n        inputTokens: inputTokensEstimate,\r\n        outputTokens: outputTokensEstimate,\r\n      }).breakdown;\r\n\r\n      const confidence = normalized.metadata.confidence ?? 0.5;\r\n\r\n      // Build metadata with optional local fields via widening cast to avoid breaking public types\r\n      const meta: any = {\r\n        modelUsed: modelLabel,\r\n        provider: 'openai',\r\n        costEstimate,\r\n        durationMs,\r\n        confidence,\r\n        cached: false,\r\n      };\r\n      if (budgeted.meta) {\r\n        meta.trimmed = true;\r\n        meta.trimDetails = budgeted.meta;\r\n      }\r\n      meta.tokensInputEstimated = inputTokensEstimate;\r\n      meta.tokensOutputEstimated = outputTokensEstimate;\r\n      meta.costBreakdownUSD = breakdown;\r\n\r\n      const out: AnalysisResponse = {\r\n        issues: normalized.issues,\r\n        // Cast to satisfy AnalysisResponse without altering public type\r\n        metadata: meta as AnalysisResponse['metadata'],\r\n      };\r\n\r\n      return out;\r\n    } catch (err) {\r\n      // TODO: Replace with production logger\r\n      console.log('[OpenAIProvider] analyze error:', err);\r\n      if (err instanceof ValidationError) {\r\n        throw err;\r\n      }\r\n      if (err && typeof err === 'object' && (err as Error).name === 'CircuitBreakerOpenError') {\r\n        throw err;\r\n      }\r\n      throw new ProviderError('openai', 'OpenAI analyze failed', { cause: err });\r\n    }\r\n  }\r\n}\r\n\r\nexport default OpenAIProvider;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\providers\\__tests__\\ProviderBudgets.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1806,1809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1806,1809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2272,2275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2272,2275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2685,2688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2685,2688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3305,3308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3305,3308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":134,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4129,4132],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4129,4132],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4458,4461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4458,4461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\r\nimport OpenAIProvider from '../OpenAIProvider';\r\nimport CircuitBreaker from '../../utils/CircuitBreaker';\r\nimport type { AnalysisRequest } from '../../types';\r\n\r\nfunction makeLongText(n: number): string {\r\n  return 'X'.repeat(n);\r\n}\r\n\r\nfunction makeReq(prevCount: number, prevLen: number, sceneLen: number): AnalysisRequest {\r\n  const previousScenes = Array.from({ length: prevCount }, (_v, i) => ({\r\n    id: `p${i}`,\r\n    text: makeLongText(prevLen),\r\n    wordCount: prevLen / 5,\r\n    position: i,\r\n    originalPosition: i,\r\n    characters: [],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending' as const,\r\n  }));\r\n\r\n  return {\r\n    scene: {\r\n      id: 's1',\r\n      text: makeLongText(sceneLen),\r\n      wordCount: sceneLen / 5,\r\n      position: 10,\r\n      originalPosition: 10,\r\n      characters: [],\r\n      timeMarkers: [],\r\n      locationMarkers: [],\r\n      hasBeenMoved: false,\r\n      rewriteStatus: 'pending',\r\n    },\r\n    previousScenes,\r\n    analysisType: 'simple',\r\n    readerContext: {\r\n      knownCharacters: new Set<string>(),\r\n      establishedTimeline: [],\r\n      revealedPlotPoints: [],\r\n      establishedSettings: [],\r\n    },\r\n  };\r\n}\r\n\r\nfunction fakeOpenAIResponse(usage?: { prompt_tokens?: number; completion_tokens?: number }) {\r\n  const payload = {\r\n    choices: [\r\n      {\r\n        message: {\r\n          content: JSON.stringify({\r\n            issues: [],\r\n            summary: '',\r\n            confidence: 0.9,\r\n          }),\r\n        },\r\n      },\r\n    ],\r\n    usage: usage ?? {\r\n      prompt_tokens: 120,\r\n      completion_tokens: 40,\r\n    },\r\n  };\r\n  return {\r\n    ok: true,\r\n    status: 200,\r\n    statusText: 'OK',\r\n    json: async () => payload,\r\n  } as any;\r\n}\r\n\r\ndescribe('Provider budgets and cost meta', () => {\r\n  const envBackup = { ...process.env };\r\n  beforeEach(() => {\r\n    vi.resetModules();\r\n    vi.useRealTimers();\r\n    // Configure small per-request budget to trigger trimming\r\n    process.env.MAX_INPUT_TOKENS_PER_REQUEST = '200'; // small\r\n    delete process.env.HARD_FAIL_ON_BUDGET;\r\n  });\r\n\r\n  afterEach(() => {\r\n    // restore env\r\n    for (const k of Object.keys(process.env)) delete (process.env as any)[k];\r\n    Object.assign(process.env, envBackup);\r\n    vi.restoreAllMocks();\r\n  });\r\n\r\n  it('adds estimated cost and trimming meta when budgets are configured (OpenAI)', async () => {\r\n    const breaker = new CircuitBreaker();\r\n    const provider = new OpenAIProvider(\r\n      { apiKey: 'test', model: 'gpt-4o' },\r\n      breaker\r\n    );\r\n\r\n    // Stub network call\r\n    const spy = vi\r\n      .spyOn(provider as any, 'fetchWithRetry')\r\n      .mockResolvedValue(fakeOpenAIResponse({ prompt_tokens: 180, completion_tokens: 55 }));\r\n\r\n    // Request with large previousScenes to force trimming\r\n    const req = makeReq(5, 1000, 1200);\r\n\r\n    const res = await provider.analyze(req);\r\n\r\n    expect(spy).toHaveBeenCalledTimes(1);\r\n    expect(res.metadata).toBeTruthy();\r\n    expect(res.metadata.modelUsed).toBe('gpt-4o');\r\n    // costEstimate should be positive given usage and pricing\r\n    expect(res.metadata.costEstimate).toBeGreaterThan(0);\r\n\r\n    // Non-breaking extra meta fields (best-effort)\r\n    const metaAny = res.metadata as any;\r\n    expect(metaAny.tokensInputEstimated).toBeGreaterThan(0);\r\n    expect(metaAny.tokensOutputEstimated).toBeGreaterThanOrEqual(0);\r\n    expect(metaAny.costBreakdownUSD).toBeTruthy();\r\n\r\n    // Trimming flags present when budget applied\r\n    expect(metaAny.trimmed || metaAny.trimDetails).toBeTruthy();\r\n    if (metaAny.trimDetails) {\r\n      expect(metaAny.trimDetails.beforeTokens).toBeGreaterThan(metaAny.trimDetails.afterTokens);\r\n      expect(metaAny.trimDetails.budget).toBe(Number(process.env.MAX_INPUT_TOKENS_PER_REQUEST));\r\n    }\r\n  });\r\n\r\n  it('does not throw when budget exceeded and HARD_FAIL_ON_BUDGET is not set', async () => {\r\n    const breaker = new CircuitBreaker();\r\n    const provider = new OpenAIProvider(\r\n      { apiKey: 'test', model: 'gpt-4o' },\r\n      breaker\r\n    );\r\n    vi.spyOn(provider as any, 'fetchWithRetry').mockResolvedValue(fakeOpenAIResponse());\r\n\r\n    // Make scene extremely large such that even after trimming, it could exceed small budget\r\n    const req = makeReq(10, 5000, 50_000);\r\n\r\n    const res = await provider.analyze(req);\r\n    expect(res.issues).toBeDefined();\r\n    const metaAny = res.metadata as any;\r\n    expect(metaAny.trimmed || metaAny.trimDetails).toBeTruthy();\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\schemas\\ResponseSchemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\schemas\\__tests__\\ResponseSchemas.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":76,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":76,"endColumn":30,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[1762,1814],"text":"type ClaudeConfig = BaseProviderConfig"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":81,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":81,"endColumn":30,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[1870,1922],"text":"type OpenAIConfig = BaseProviderConfig"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":86,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":86,"endColumn":30,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[1987,2039],"text":"type GeminiConfig = BaseProviderConfig"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI service shared types for continuity analysis\r\n// Strict TypeScript compatible\r\n\r\nimport { Scene, ContinuityIssue, ReaderKnowledge } from '../../shared/types';\r\n\r\n/**\r\n * Provider identifiers supported by this AI subsystem.\r\n */\r\nexport type ProviderName = 'anthropic' | 'openai' | 'google';\r\n\r\n/**\r\n * Describes a model's strengths and operational constraints for routing.\r\n */\r\nexport interface ModelCapabilities {\r\n  model: string;\r\n  provider: ProviderName;\r\n  strengths: Array<\r\n    | 'narrative-flow'\r\n    | 'character-voice'\r\n    | 'complex-reasoning'\r\n    | 'deep-analysis'\r\n    | 'instruction-following'\r\n    | 'validation'\r\n    | 'full-manuscript'\r\n    | 'bulk-analysis'\r\n  >;\r\n  costTier: 'low' | 'medium' | 'high';\r\n  maxTokens?: number;\r\n}\r\n\r\n/**\r\n * Variants of analysis the system can perform.\r\n */\r\nexport type AnalysisType = 'simple' | 'consistency' | 'complex' | 'full';\r\n\r\n/**\r\n * Request payload for continuity analysis.\r\n */\r\nexport interface AnalysisRequest {\r\n  scene: Scene;\r\n  previousScenes: Scene[];\r\n  analysisType: AnalysisType;\r\n  readerContext: ReaderKnowledge;\r\n}\r\n\r\n/**\r\n * Normalized response from any provider after validation.\r\n */\r\nexport interface AnalysisResponse {\r\n  issues: ContinuityIssue[];\r\n  metadata: {\r\n    modelUsed: string;\r\n    provider: ProviderName;\r\n    costEstimate: number;\r\n    durationMs: number;\r\n    confidence: number;\r\n    cached: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Base configuration for providers.\r\n * TODO: Integrate Electron safeStorage for apiKey handling in production.\r\n */\r\nexport interface BaseProviderConfig {\r\n  apiKey: string;\r\n  model?: string;\r\n  timeoutMs?: number;\r\n  rateLimitPerMin?: number;\r\n  baseUrl?: string;\r\n}\r\n\r\n/**\r\n * Claude (Anthropic) provider configuration.\r\n */\r\nexport interface ClaudeConfig extends BaseProviderConfig {}\r\n\r\n/**\r\n * OpenAI provider configuration.\r\n */\r\nexport interface OpenAIConfig extends BaseProviderConfig {}\r\n\r\n/**\r\n * Gemini (Google) provider configuration.\r\n */\r\nexport interface GeminiConfig extends BaseProviderConfig {}\r\n\r\n/**\r\n * Base error for provider-related failures.\r\n */\r\nexport class ProviderError extends Error {\r\n  public readonly provider: ProviderName;\r\n  public readonly status?: number;\r\n  public readonly isRetriable: boolean;\r\n  public readonly causeOriginal?: unknown;\r\n\r\n  constructor(\r\n    provider: ProviderName,\r\n    message: string,\r\n    options?: { status?: number; cause?: unknown; retriable?: boolean }\r\n  ) {\r\n    super(message);\r\n    this.name = 'ProviderError';\r\n    this.provider = provider;\r\n    this.status = options?.status;\r\n    this.isRetriable = Boolean(options?.retriable);\r\n    this.causeOriginal = options?.cause;\r\n  }\r\n}\r\n\r\n/**\r\n * Specialized error for rate limit exceedance (HTTP 429, etc).\r\n */\r\nexport class RateLimitError extends Error {\r\n  public readonly provider: ProviderName;\r\n\r\n  constructor(provider: ProviderName, message = 'Rate limit exceeded') {\r\n    super(message);\r\n    this.name = 'RateLimitError';\r\n    this.provider = provider;\r\n  }\r\n}\r\n\r\n/**\r\n * Schema or shape validation failure for provider outputs.\r\n */\r\nexport class ValidationError extends Error {\r\n  public readonly provider: ProviderName;\r\n\r\n  constructor(provider: ProviderName, message = 'Response validation failed') {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n    this.provider = provider;\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown when a provider's circuit breaker is OPEN.\r\n */\r\nexport class CircuitBreakerOpenError extends Error {\r\n  public readonly provider: string;\r\n\r\n  constructor(provider: string, message = 'Circuit breaker open') {\r\n    super(message);\r\n    this.name = 'CircuitBreakerOpenError';\r\n    this.provider = provider;\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown when a provider call times out.\r\n */\r\nexport class TimeoutError extends Error {\r\n  public readonly provider: ProviderName;\r\n  public readonly timeoutMs: number;\r\n\r\n  constructor(provider: ProviderName, timeoutMs: number, message?: string) {\r\n    super(message ?? `Request timed out after ${timeoutMs}ms`);\r\n    this.name = 'TimeoutError';\r\n    this.provider = provider;\r\n    this.timeoutMs = timeoutMs;\r\n  }\r\n}\r\n// Extend AnalysisRequest to support custom prompts for rewriting\r\nexport interface AnalysisRequestExtension {\r\n  customPrompt?: string;\r\n  isRewriteRequest?: boolean;\r\n  preserveElements?: string[];\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\CircuitBreaker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\ResponseValidator.ts","messages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":450,"column":20,"nodeType":"Literal","messageId":"unexpected","endLine":450,"endColumn":38},{"ruleId":"no-redeclare","severity":2,"message":"'validateAndNormalize' is already defined.","line":747,"column":17,"nodeType":"Identifier","messageId":"redeclared","endLine":747,"endColumn":37},{"ruleId":"no-redeclare","severity":2,"message":"'validateAndNormalize' is already defined.","line":753,"column":17,"nodeType":"Identifier","messageId":"redeclared","endLine":753,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":788,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":788,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26756,26759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26756,26759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":788,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":788,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26801,26804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26801,26804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AnalysisResponse as AppAnalysisResponse, ProviderName, ValidationError } from '../types';\r\nimport type { ContinuityIssue } from '../../../shared/types';\r\nimport { z } from 'zod';\r\nimport {\r\n  AnalysisResponseSchema as AnalysisResponseZodSchema,\r\n  type AnalysisResponse as ModelAnalysisResponse,\r\n  IssueTypeEnum,\r\n  SeverityEnum,\r\n} from '../schemas/ResponseSchemas';\r\n\r\n/**\r\n * Minimal parser interface compatible with previous .parse(...) usage.\r\n * Each schema function returns an object with a parse method that throws on invalid input.\r\n */\r\ntype Parser<T> = {\r\n  parse(value: unknown): T;\r\n};\r\n\r\n// ------------ Internal helpers and type guards (legacy compatibility) ------------\r\n\r\nconst ISSUE_TYPES = ['pronoun', 'timeline', 'character', 'plot', 'context', 'engagement'] as const;\r\nconst ISSUE_SEVERITIES = ['must-fix', 'should-fix', 'consider'] as const;\r\n\r\nfunction isObject(v: unknown): v is Record<string, unknown> {\r\n  return v !== null && typeof v === 'object';\r\n}\r\nfunction isString(v: unknown): v is string {\r\n  return typeof v === 'string';\r\n}\r\nfunction isBoolean(v: unknown): v is boolean {\r\n  return typeof v === 'boolean';\r\n}\r\nfunction isNumberFinite(v: unknown): v is number {\r\n  return typeof v === 'number' && Number.isFinite(v);\r\n}\r\nfunction isIntegerNonNegative(v: unknown): v is number {\r\n  return isNumberFinite(v) && Number.isInteger(v) && v >= 0;\r\n}\r\nfunction isProviderName(v: unknown): v is ProviderName {\r\n  return v === 'anthropic' || v === 'openai' || v === 'google';\r\n}\r\n\r\nfunction isTextSpan(v: unknown): v is [number, number] {\r\n  return (\r\n    Array.isArray(v) &&\r\n    v.length === 2 &&\r\n    isIntegerNonNegative(v[0]) &&\r\n    isIntegerNonNegative(v[1]) &&\r\n    v[0] <= v[1]\r\n  );\r\n}\r\n\r\n/**\r\n * Runtime guard for ContinuityIssue (legacy ContinuityIssue used across app).\r\n */\r\nfunction isContinuityIssue(v: unknown): v is ContinuityIssue {\r\n  if (!isObject(v)) return false;\r\n  const type = (v as Record<string, unknown>).type;\r\n  const severity = (v as Record<string, unknown>).severity;\r\n  const description = (v as Record<string, unknown>).description;\r\n  const textSpan = (v as Record<string, unknown>).textSpan;\r\n  const suggestedFix = (v as Record<string, unknown>).suggestedFix;\r\n\r\n  if (!(isString(type) && (ISSUE_TYPES as readonly string[]).includes(type))) return false;\r\n  if (!(isString(severity) && (ISSUE_SEVERITIES as readonly string[]).includes(severity))) return false;\r\n  if (!isString(description)) return false;\r\n  if (!isTextSpan(textSpan)) return false;\r\n  if (suggestedFix !== undefined && !isString(suggestedFix)) return false;\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Validates and narrows the optional metadata block for normalized responses.\r\n * Returns undefined if input is undefined. Throws detailed Error on invalid inputs.\r\n */\r\nfunction validateNormalizedMetadata(\r\n  meta: unknown\r\n):\r\n  | {\r\n      modelUsed?: string;\r\n      provider?: ProviderName;\r\n      costEstimate?: number;\r\n      durationMs?: number;\r\n      confidence?: number;\r\n      cached?: boolean;\r\n    }\r\n  | undefined {\r\n  if (meta === undefined) return undefined;\r\n  if (!isObject(meta)) throw new Error(\"Invalid normalized response: 'metadata' must be an object\");\r\n\r\n  const out: {\r\n    modelUsed?: string;\r\n    provider?: ProviderName;\r\n    costEstimate?: number;\r\n    durationMs?: number;\r\n    confidence?: number;\r\n    cached?: boolean;\r\n  } = {};\r\n\r\n  if ((meta as Record<string, unknown>).modelUsed !== undefined) {\r\n    if (!isString((meta as Record<string, unknown>).modelUsed))\r\n      throw new Error(\"Invalid normalized response: 'metadata.modelUsed' must be a string\");\r\n    out.modelUsed = (meta as Record<string, unknown>).modelUsed as string;\r\n  }\r\n  if ((meta as Record<string, unknown>).provider !== undefined) {\r\n    if (!isProviderName((meta as Record<string, unknown>).provider))\r\n      throw new Error(\r\n        \"Invalid normalized response: 'metadata.provider' must be 'anthropic' | 'openai' | 'google'\"\r\n      );\r\n    out.provider = (meta as Record<string, unknown>).provider as ProviderName;\r\n  }\r\n  if ((meta as Record<string, unknown>).costEstimate !== undefined) {\r\n    if (!isNumberFinite((meta as Record<string, unknown>).costEstimate))\r\n      throw new Error(\"Invalid normalized response: 'metadata.costEstimate' must be a finite number\");\r\n    out.costEstimate = (meta as Record<string, unknown>).costEstimate as number;\r\n  }\r\n  if ((meta as Record<string, unknown>).durationMs !== undefined) {\r\n    if (!isNumberFinite((meta as Record<string, unknown>).durationMs))\r\n      throw new Error(\"Invalid normalized response: 'metadata.durationMs' must be a finite number\");\r\n    out.durationMs = (meta as Record<string, unknown>).durationMs as number;\r\n  }\r\n  if ((meta as Record<string, unknown>).confidence !== undefined) {\r\n    const c = (meta as Record<string, unknown>).confidence;\r\n    if (!isNumberFinite(c) || (c as number) < 0 || (c as number) > 1) {\r\n      throw new Error(\"Invalid normalized response: 'metadata.confidence' must be a number in [0,1]\");\r\n    }\r\n    out.confidence = c as number;\r\n  }\r\n  if ((meta as Record<string, unknown>).cached !== undefined) {\r\n    if (!isBoolean((meta as Record<string, unknown>).cached))\r\n      throw new Error(\"Invalid normalized response: 'metadata.cached' must be a boolean\");\r\n    out.cached = (meta as Record<string, unknown>).cached as boolean;\r\n  }\r\n  return out;\r\n}\r\n\r\n// ------------ Raw provider response shapes and guards (envelopes) ------------\r\n\r\ninterface OpenAIChatMessage {\r\n  role?: string;\r\n  content: string;\r\n}\r\ninterface OpenAIChoice {\r\n  index?: number;\r\n  message: OpenAIChatMessage;\r\n  finish_reason?: string;\r\n}\r\ninterface OpenAIChatResponse {\r\n  id?: string;\r\n  object?: string;\r\n  choices: OpenAIChoice[];\r\n  usage?: {\r\n    prompt_tokens?: number;\r\n    completion_tokens?: number;\r\n    total_tokens?: number;\r\n  };\r\n}\r\n\r\nfunction isOpenAIChatResponse(v: unknown): v is OpenAIChatResponse {\r\n  if (!isObject(v)) return false;\r\n  const choices = (v as Record<string, unknown>).choices;\r\n  if (!Array.isArray(choices) || choices.length < 1) return false;\r\n\r\n  const first = choices[0];\r\n  if (!isObject(first)) return false;\r\n  const message = (first as Record<string, unknown>).message;\r\n  if (!isObject(message)) return false;\r\n  const content = (message as Record<string, unknown>).content;\r\n  if (!isString(content)) return false;\r\n\r\n  return true;\r\n}\r\n\r\ninterface AnthropicContentItem {\r\n  type?: string;\r\n  text: string;\r\n}\r\ninterface AnthropicResponse {\r\n  id?: string;\r\n  type?: string;\r\n  role?: string;\r\n  model?: string;\r\n  content: AnthropicContentItem[];\r\n  usage?: {\r\n    input_tokens?: number;\r\n    output_tokens?: number;\r\n  };\r\n}\r\n\r\nfunction isAnthropicResponse(v: unknown): v is AnthropicResponse {\r\n  if (!isObject(v)) return false;\r\n  const content = (v as Record<string, unknown>).content;\r\n  if (!Array.isArray(content) || content.length < 1) return false;\r\n  const first = content[0];\r\n  if (!isObject(first)) return false;\r\n  const text = (first as Record<string, unknown>).text;\r\n  if (!isString(text)) return false;\r\n  return true;\r\n}\r\n\r\ninterface GeminiPart {\r\n  text?: string;\r\n}\r\ninterface GeminiContent {\r\n  role?: string;\r\n  parts: GeminiPart[];\r\n}\r\ninterface GeminiCandidate {\r\n  content: GeminiContent;\r\n  finishReason?: string;\r\n}\r\ninterface GeminiResponse {\r\n  candidates: GeminiCandidate[];\r\n  promptFeedback?: unknown;\r\n}\r\n\r\nfunction isGeminiResponse(v: unknown): v is GeminiResponse {\r\n  if (!isObject(v)) return false;\r\n  const candidates = (v as Record<string, unknown>).candidates;\r\n  if (!Array.isArray(candidates) || candidates.length < 1) return false;\r\n  const first = candidates[0];\r\n  if (!isObject(first)) return false;\r\n  const content = (first as Record<string, unknown>).content;\r\n  if (!isObject(content)) return false;\r\n  const parts = (content as Record<string, unknown>).parts;\r\n  if (!Array.isArray(parts) || parts.length < 1) return false;\r\n  // Not all parts must have text, but structure must exist\r\n  return true;\r\n}\r\n\r\n// ------------ Raw provider \"schema\" factories (public API compatible) ------------\r\n\r\n/**\r\n * OpenAI chat.completions \"schema\" returning a parser with .parse(raw).\r\n * Ensures choices[0].message.content is a string.\r\n */\r\nexport function openAIChatSchema(): Parser<OpenAIChatResponse> {\r\n  return {\r\n    parse(raw: unknown): OpenAIChatResponse {\r\n      if (!isOpenAIChatResponse(raw)) {\r\n        throw new Error('Invalid OpenAI chat response: expected choices[0].message.content as string');\r\n      }\r\n      return raw;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Anthropic Messages API \"schema\" returning a parser with .parse(raw).\r\n * Ensures content[0].text is a string.\r\n */\r\nexport function anthropicSchema(): Parser<AnthropicResponse> {\r\n  return {\r\n    parse(raw: unknown): AnthropicResponse {\r\n      if (!isAnthropicResponse(raw)) {\r\n        throw new Error('Invalid Anthropic response: expected content[0].text as string');\r\n      }\r\n      return raw;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Google Gemini generateContent \"schema\" returning a parser with .parse(raw).\r\n * Ensures candidates[0].content.parts exists; later we find a part with non-empty text.\r\n */\r\nexport function geminiSchema(): Parser<GeminiResponse> {\r\n  return {\r\n    parse(raw: unknown): GeminiResponse {\r\n      if (!isGeminiResponse(raw)) {\r\n        throw new Error('Invalid Gemini response: expected candidates[0].content.parts array');\r\n      }\r\n      return raw;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Legacy normalized response \"schema\" for ContinuityIssue[] (kept for compatibility).\r\n * Public export maintained to avoid breaking external imports.\r\n */\r\nexport function normalizedResponseSchema(): Parser<{\r\n  issues: ContinuityIssue[];\r\n  metadata?:\r\n    | {\r\n        modelUsed?: string;\r\n        provider?: ProviderName;\r\n        costEstimate?: number;\r\n        durationMs?: number;\r\n        confidence?: number;\r\n        cached?: boolean;\r\n      }\r\n    | undefined;\r\n}> {\r\n  return {\r\n    parse(\r\n      raw: unknown\r\n    ): {\r\n      issues: ContinuityIssue[];\r\n      metadata?:\r\n        | {\r\n            modelUsed?: string;\r\n            provider?: ProviderName;\r\n            costEstimate?: number;\r\n            durationMs?: number;\r\n            confidence?: number;\r\n            cached?: boolean;\r\n          }\r\n        | undefined;\r\n    } {\r\n      if (!isObject(raw)) {\r\n        throw new Error('Invalid normalized response: expected an object');\r\n      }\r\n\r\n      const issuesRaw = (raw as Record<string, unknown>).issues;\r\n      let issues: ContinuityIssue[] = [];\r\n      if (issuesRaw === undefined) {\r\n        issues = [];\r\n      } else {\r\n        if (!Array.isArray(issuesRaw)) {\r\n          throw new Error(\"Invalid normalized response: 'issues' must be an array\");\r\n        }\r\n        issuesRaw.forEach((item, idx) => {\r\n          if (!isContinuityIssue(item)) {\r\n            // Provide a precise messaging on failure\r\n            throw new Error(`Invalid ContinuityIssue at index ${idx}`);\r\n          }\r\n        });\r\n        issues = issuesRaw as ContinuityIssue[];\r\n      }\r\n\r\n      const metadata = validateNormalizedMetadata((raw as Record<string, unknown>).metadata);\r\n\r\n      return { issues, metadata };\r\n    },\r\n  };\r\n}\r\n\r\n// ------------ Utilities: JSON extraction and sanitization ------------\r\n\r\n/**\r\n * Extract the first JSON object from arbitrary text using bracket counting.\r\n * Handles nested braces and ignores braces inside strings.\r\n */\r\nexport function extractJsonFromText(text: string): string {\r\n  // Strip code fences if present\r\n  const fenceMatch = text.match(/```(?:json)?\\s*([\\s\\S]*?)```/i);\r\n  if (fenceMatch) {\r\n    text = fenceMatch[1];\r\n  }\r\n\r\n  let start = -1;\r\n  let depth = 0;\r\n  let inString: false | '\"' | \"'\" = false;\r\n  let escape = false;\r\n\r\n  for (let i = 0; i < text.length; i++) {\r\n    const ch = text[i];\r\n\r\n    if (inString) {\r\n      if (escape) {\r\n        escape = false;\r\n      } else if (ch === '\\\\') {\r\n        escape = true;\r\n      } else if (ch === inString) {\r\n        inString = false;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (ch === '\"' || ch === \"'\") {\r\n      inString = ch as '\"' | \"'\";\r\n      continue;\r\n    }\r\n\r\n    if (ch === '{') {\r\n      if (depth === 0) start = i;\r\n      depth++;\r\n    } else if (ch === '}') {\r\n      depth--;\r\n      if (depth === 0 && start !== -1) {\r\n        return text.slice(start, i + 1);\r\n      }\r\n    }\r\n  }\r\n  // Fallback: trim and try if entire string looks like JSON\r\n  const trimmed = text.trim();\r\n  if (trimmed.startsWith('{') && trimmed.endsWith('}')) return trimmed;\r\n  throw new Error('No JSON object found in text');\r\n}\r\n\r\nfunction stripBOM(s: string): string {\r\n  return s.charCodeAt(0) === 0xfeff ? s.slice(1) : s;\r\n}\r\nfunction replaceSmartQuotes(s: string): string {\r\n  return s\r\n    .replace(/[\\u2018\\u2019\\u201A\\u201B]/g, \"'\")\r\n    .replace(/[\\u201C\\u201D\\u201E\\u201F]/g, '\"');\r\n}\r\nfunction removeComments(s: string): string {\r\n  // Remove //... and /* ... */\r\n  return s.replace(/\\/\\/[^\\n\\r]*|\\/\\*[\\s\\S]*?\\*\\//g, '');\r\n}\r\nfunction removeTrailingCommas(s: string): string {\r\n  // Remove trailing commas before } or ]\r\n  return s.replace(/,(\\s*[}\\]])/g, '$1');\r\n}\r\nfunction fixSingleQuotedKeysAndStrings(s: string): string {\r\n  // 'key': value  -> \"key\": value\r\n  s = s.replace(/([{,\\s])'([A-Za-z0-9_]+)'\\s*:/g, '$1\"$2\":');\r\n  // :\"value'like\" -> conservative conversion for single-quoted string values\r\n  s = s.replace(/:\\s*'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'/g, ': \"$1\"');\r\n  return s;\r\n}\r\nfunction quoteUnquotedKeys(s: string): string {\r\n  // { key: ... , another_key: ... } -> quote keys\r\n  return s.replace(/([{,\\s])([A-Za-z_][A-Za-z0-9_]*)\\s*:/g, '$1\"$2\":');\r\n}\r\nfunction sanitizeJsonLike(s: string, { quoteKeys = false }: { quoteKeys?: boolean } = {}): string {\r\n  let out = stripBOM(s);\r\n  out = replaceSmartQuotes(out);\r\n  out = removeComments(out);\r\n  out = removeTrailingCommas(out);\r\n  out = fixSingleQuotedKeysAndStrings(out);\r\n  if (quoteKeys) {\r\n    out = quoteUnquotedKeys(out);\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Fallback slice for the outermost JSON object when strict extraction fails.\r\n * Returns substring between the first '{' and the last '}' if present.\r\n */\r\nfunction sliceOuterJson(s: string): string | null {\r\n  const start = s.indexOf('{');\r\n  const end = s.lastIndexOf('}');\r\n  if (start !== -1 && end !== -1 && end > start) {\r\n    return s.slice(start, end + 1);\r\n  }\r\n  return null;\r\n}\r\n\r\n// ------------ Model response normalization and confidence scoring ------------\r\n\r\nexport type ValidationMeta = { attempts: number; repaired: boolean; errors: string[] };\r\n\r\nfunction cleanText(s: string): string {\r\n  return s.replace(/[\\x00-\\x1F\\x7F]/g, '').trim();\r\n}\r\n\r\nfunction clamp01(x: number): number {\r\n  if (!Number.isFinite(x)) return 0;\r\n  return Math.max(0, Math.min(1, x));\r\n}\r\n\r\nfunction normalizeModelData(parsed: ModelAnalysisResponse): ModelAnalysisResponse {\r\n  // Clone to avoid mutation of caller data\r\n  const data: ModelAnalysisResponse = {\r\n    issues: Array.isArray(parsed.issues) ? [...parsed.issues] : [],\r\n    summary: typeof parsed.summary === 'string' ? parsed.summary : '',\r\n    confidence: typeof parsed.confidence === 'number' ? clamp01(parsed.confidence) : undefined,\r\n  };\r\n\r\n  data.summary = cleanText(data.summary);\r\n\r\n  const severityValues = SeverityEnum.options as readonly z.infer<typeof SeverityEnum>[];\r\n  const typeValues = IssueTypeEnum.options as readonly z.infer<typeof IssueTypeEnum>[];\r\n\r\n  data.issues = data.issues.map((issue: ModelAnalysisResponse['issues'][number]) => {\r\n    let severity = issue.severity;\r\n    // Case-insensitive severity coercion if needed (best-effort; schema enforces valid already)\r\n    const sevLower = String(severity).toLowerCase();\r\n    const sevCoerced = severityValues.find((v: z.infer<typeof SeverityEnum>) => v.toLowerCase() === sevLower) ?? severity;\r\n    severity = sevCoerced as typeof issue.severity;\r\n\r\n    let type = issue.type;\r\n    const typeLower = String(type).toLowerCase();\r\n    const typeCoerced =\r\n      typeValues.find((v: z.infer<typeof IssueTypeEnum>) => v.toLowerCase() === typeLower) ?? type;\r\n    type = typeCoerced as typeof issue.type;\r\n\r\n    // Span normalization\r\n    let span = issue.span ?? null;\r\n    if (span) {\r\n      const start = Math.max(0, Math.min(Number.MAX_SAFE_INTEGER, Math.trunc(span.start_index)));\r\n      const end = Math.max(0, Math.min(Number.MAX_SAFE_INTEGER, Math.trunc(span.end_index)));\r\n      span = {\r\n        start_index: Math.max(0, Math.min(start, end)),\r\n        end_index: Math.max(start, end),\r\n      };\r\n    }\r\n\r\n    // Strings cleanup\r\n    const explanation = cleanText(issue.explanation ?? '');\r\n    const suggested_fix = cleanText(issue.suggested_fix ?? '');\r\n\r\n    // Evidence cleanup, dedupe and cap\r\n    const seen = new Set<string>();\r\n    const evidence =\r\n      Array.isArray(issue.evidence) ? issue.evidence.map((e: string) => cleanText(e)).filter((e: string) => e.length > 0) : [];\r\n    const deduped: string[] = [];\r\n    for (const e of evidence) {\r\n      const key = e.toLowerCase();\r\n      if (!seen.has(key)) {\r\n        seen.add(key);\r\n        deduped.push(e);\r\n      }\r\n      if (deduped.length >= 10) break;\r\n    }\r\n\r\n    // Confidence clamp if present\r\n    let conf = issue.confidence;\r\n    if (typeof conf === 'number') {\r\n      conf = clamp01(conf);\r\n    }\r\n\r\n    return {\r\n      type,\r\n      severity,\r\n      span: span ?? null,\r\n      explanation,\r\n      evidence: deduped,\r\n      suggested_fix,\r\n      confidence: conf,\r\n    };\r\n  });\r\n\r\n  // Backfill issue confidences heuristically if missing\r\n  const sevWeights: Record<z.infer<typeof SeverityEnum>, number> = {\r\n    low: 0.4,\r\n    medium: 0.6,\r\n    high: 0.8,\r\n    critical: 0.9,\r\n  };\r\n\r\n  data.issues = data.issues.map((issue: ModelAnalysisResponse['issues'][number]) => {\r\n    if (typeof issue.confidence === 'number') return issue;\r\n    let score = sevWeights[issue.severity] ?? 0.5;\r\n    const bonus = Math.min(0.1, (issue.evidence?.length ?? 0) * 0.02);\r\n    score += bonus;\r\n    if (issue.span && Number.isFinite(issue.span.start_index) && Number.isFinite(issue.span.end_index)) {\r\n      score += 0.05;\r\n    }\r\n    // Clamp into [0.35, 0.98]\r\n    score = Math.max(0.35, Math.min(0.98, score));\r\n    return { ...issue, confidence: clamp01(score) };\r\n  });\r\n\r\n  if (data.confidence === undefined) {\r\n    const confidences = data.issues.map((i: ModelAnalysisResponse['issues'][number]) => i.confidence ?? 0);\r\n    const mean = confidences.length ? confidences.reduce((a: number, b: number) => a + b, 0) / confidences.length : 0;\r\n    data.confidence = clamp01(mean);\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n// ------------ Parsing pipeline with retries and fallbacks ------------\r\n\r\ntype ParseAttemptResult =\r\n  | { ok: true; data: ModelAnalysisResponse; meta: ValidationMeta }\r\n  | { ok: false; meta: ValidationMeta };\r\n\r\nfunction tryZodValidate(candidate: unknown): { ok: true; data: ModelAnalysisResponse } | { ok: false; error: string } {\r\n  const res = AnalysisResponseZodSchema.safeParse(candidate);\r\n  if (res.success) return { ok: true, data: res.data };\r\n  return { ok: false, error: res.error.errors.map((e: z.ZodIssue) => e.message).join('; ') };\r\n}\r\n\r\nfunction parseModelOutputToZod(raw: unknown, retries = 3): ParseAttemptResult {\r\n  const errors: string[] = [];\r\n  let attempts = 0;\r\n  let repaired = false;\r\n  let extractedSub: string | null = null;\r\n\r\n  // 0) Already-object case\r\n  if (isObject(raw)) {\r\n    attempts++;\r\n    const z = tryZodValidate(raw);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    } else {\r\n      errors.push(`Zod validation failed on object: ${z.error}`);\r\n      // Continue to stringify-sanitize attempts below\r\n    }\r\n  }\r\n\r\n  const rawStr = isString(raw) ? raw : (() => {\r\n    try {\r\n      return JSON.stringify(raw);\r\n    } catch {\r\n      return '';\r\n    }\r\n  })();\r\n\r\n  // Strategy 1: Strict JSON.parse on full string\r\n  attempts++;\r\n  try {\r\n    const candidate = JSON.parse(stripBOM(rawStr));\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed on strict JSON: ${z.error}`);\r\n  } catch (e) {\r\n    errors.push(`Strict JSON.parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 2: Extract first top-level JSON object substring (handles fences too)\r\n  attempts++;\r\n  try {\r\n    const jsonSub = extractJsonFromText(rawStr);\r\n    extractedSub = jsonSub;\r\n    if (jsonSub !== rawStr) repaired = true;\r\n    const candidate = JSON.parse(jsonSub);\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed on extracted JSON: ${z.error}`);\r\n  } catch (e) {\r\n    // Keep extractedSub as whatever was found (if any), but note failure\r\n    repaired = true;\r\n    errors.push(`Extraction/parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 3: Sanitize common issues (smart quotes, single quotes, trailing commas, comments)\r\n  attempts++;\r\n  try {\r\n    const base = extractedSub ?? sliceOuterJson(rawStr) ?? rawStr;\r\n    const sanitized = sanitizeJsonLike(base);\r\n    if (sanitized !== base) repaired = true;\r\n    const candidate = JSON.parse(sanitized);\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed after sanitize: ${z.error}`);\r\n  } catch (e) {\r\n    repaired = true;\r\n    errors.push(`Sanitize/parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 3b: Quote unquoted keys conservatively\r\n  attempts++;\r\n  try {\r\n    const base = extractedSub ?? sliceOuterJson(rawStr) ?? rawStr;\r\n    const sanitized = sanitizeJsonLike(base, { quoteKeys: true });\r\n    if (sanitized !== base) repaired = true;\r\n    const candidate = JSON.parse(sanitized);\r\n    const z = tryZodValidate(candidate);\r\n    if (z.ok) {\r\n      return { ok: true, data: normalizeModelData(z.data), meta: { attempts, repaired, errors } };\r\n    }\r\n    errors.push(`Zod validation failed after quoting keys: ${z.error}`);\r\n  } catch (e) {\r\n    repaired = true;\r\n    errors.push(`Quote-keys/parse failed: ${(e as Error)?.message ?? String(e)}`);\r\n  }\r\n\r\n  // Strategy 4: JSON5 (optional, skipped if not installed)\r\n  // Note: json5 is not in deps by default; skip silently.\r\n  // If added later, this can be enabled with a dynamic import.\r\n\r\n  // Respect retries cap (we have already performed multiple attempts)\r\n  if (attempts >= Math.max(1, retries)) {\r\n    return { ok: false, meta: { attempts, repaired, errors } };\r\n  }\r\n\r\n  return { ok: false, meta: { attempts, repaired, errors } };\r\n}\r\n\r\n// ------------ Provider payload extraction (envelopes) ------------\r\n\r\nfunction extractTextPayload(provider: ProviderName, raw: unknown): string {\r\n  if (provider === 'openai') {\r\n    const parsed = openAIChatSchema().parse(raw);\r\n    return parsed.choices[0].message.content;\r\n  }\r\n  if (provider === 'anthropic') {\r\n    const parsed = anthropicSchema().parse(raw);\r\n    return parsed.content[0].text;\r\n  }\r\n  // google\r\n  const parsed = geminiSchema().parse(raw);\r\n  const parts = parsed.candidates[0]?.content?.parts ?? [];\r\n  const firstWithText = parts.find(\r\n    (p: { text?: string }) => typeof p.text === 'string' && ((p.text?.length ?? 0) > 0)\r\n  );\r\n  if (!firstWithText || !firstWithText.text) {\r\n    throw new Error('No text part found in Gemini response');\r\n  }\r\n  return firstWithText.text;\r\n}\r\n\r\n// ------------ Mapping to application-level AnalysisResponse (legacy) ------------\r\n\r\nfunction mapIssueTypeToLegacy(t: z.infer<typeof IssueTypeEnum>): ContinuityIssue['type'] {\r\n  switch (t) {\r\n    case 'pronoun_reference':\r\n      return 'pronoun';\r\n    case 'timeline':\r\n      return 'timeline';\r\n    case 'character_knowledge':\r\n      return 'character';\r\n    case 'other':\r\n    default:\r\n      return 'context';\r\n  }\r\n}\r\n\r\nfunction mapSeverityToLegacy(s: z.infer<typeof SeverityEnum>): ContinuityIssue['severity'] {\r\n  switch (s) {\r\n    case 'low':\r\n      return 'consider';\r\n    case 'medium':\r\n      return 'should-fix';\r\n    case 'high':\r\n    case 'critical':\r\n    default:\r\n      return 'must-fix';\r\n  }\r\n}\r\n\r\nfunction modelToLegacyIssues(data: ModelAnalysisResponse): ContinuityIssue[] {\r\n  return (data.issues ?? []).map((i: ModelAnalysisResponse['issues'][number]) => {\r\n    const start = i.span?.start_index ?? 0;\r\n    const end = i.span?.end_index ?? Math.max(0, start);\r\n    return {\r\n      type: mapIssueTypeToLegacy(i.type),\r\n      severity: mapSeverityToLegacy(i.severity),\r\n      description: i.explanation ?? '',\r\n      textSpan: [Math.max(0, Math.trunc(start)), Math.max(0, Math.trunc(end))],\r\n      suggestedFix: i.suggested_fix ? String(i.suggested_fix) : undefined,\r\n    };\r\n  });\r\n}\r\n\r\n// ------------ Public API (overloaded) ------------\r\n\r\nexport function validateAndNormalize(\r\n  raw: unknown,\r\n  options?: { retries?: number }\r\n): { data: ModelAnalysisResponse; meta: ValidationMeta };\r\nexport function validateAndNormalize(\r\n  provider: ProviderName,\r\n  raw: unknown,\r\n  fallbackModelLabel: string\r\n): AppAnalysisResponse;\r\n// Implementation\r\nexport function validateAndNormalize(\r\n  a: unknown,\r\n  b?: unknown,\r\n  c?: unknown\r\n): { data: ModelAnalysisResponse; meta: ValidationMeta } | AppAnalysisResponse {\r\n  // Overload dispatcher\r\n  if (isProviderName(a)) {\r\n    // Legacy API: (provider, raw, fallbackModelLabel) -> AppAnalysisResponse\r\n    const provider = a as ProviderName;\r\n    const raw = b as unknown;\r\n    const fallbackModelLabel = String(c ?? '');\r\n    try {\r\n      const payloadText = extractTextPayload(provider, raw);\r\n      const result = parseModelOutputToZod(payloadText, 4);\r\n      if (!result.ok) {\r\n        throw new ValidationError(provider, 'Response validation failed');\r\n      }\r\n      const modelData = result.data; // already normalized and confidences filled\r\n      const legacy: AppAnalysisResponse = {\r\n        issues: modelToLegacyIssues(modelData),\r\n        metadata: {\r\n          modelUsed: fallbackModelLabel,\r\n          provider,\r\n          costEstimate: 0,\r\n          durationMs: 0,\r\n          confidence: typeof modelData.confidence === 'number' ? modelData.confidence : 0,\r\n          cached: false,\r\n        },\r\n      };\r\n      return legacy;\r\n    } catch {\r\n      throw new ValidationError(a as ProviderName, 'Response validation failed');\r\n    }\r\n  } else {\r\n    // New primary API: (raw, options?) -> { data, meta }\r\n    const retries = isObject(b) && isNumberFinite((b as any).retries) ? Math.max(1, Math.trunc((b as any).retries)) : 4;\r\n    const result = parseModelOutputToZod(a, retries);\r\n    if (!result.ok) {\r\n      return { data: { issues: [], summary: '', confidence: 0 }, meta: result.meta };\r\n    }\r\n    return { data: result.data, meta: result.meta };\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\Tokenizers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2273,2276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2273,2276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2687,2690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2687,2690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2945,2948],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2945,2948],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":74,"column":11,"nodeType":"BlockStatement","messageId":"unexpected","endLine":74,"endColumn":13,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3056,3056],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":92,"column":41,"nodeType":"BlockStatement","messageId":"unexpected","endLine":92,"endColumn":43,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3838,3838],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":105,"column":11,"nodeType":"BlockStatement","messageId":"unexpected","endLine":105,"endColumn":13,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4233,4233],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":150,"column":13,"nodeType":"BlockStatement","messageId":"unexpected","endLine":150,"endColumn":15,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[5482,5482],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2646,2649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2646,2649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2662,2665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2662,2665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2900,2903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2900,2903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2916,2919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2916,2919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Tokenizers.ts\r\n// Pure utilities for token estimation with optional dynamic tokenizer support.\r\n// - No hard dependency on tokenizer libraries; best-effort dynamic import attempted without logging.\r\n// - Deterministic outputs for the same inputs (no randomness).\r\n//\r\n// Encoding notes (OpenAI):\r\n// - GPT-3.5/4/4o/gpt-* typically use cl100k_base; o-series may use o200k_base where available.\r\n// - We map broadly and fall back to heuristics if encodings/libs are unavailable.\r\n//\r\n// Claude/Gemini:\r\n// - No official JS tokenizer readily available; we approximate with chars-per-token heuristics when dynamic libs aren't present.\r\n//\r\n// Heuristic fallback (used if tokenizer not available):\r\n//   tokens = max(1, round((asciiLen + 0.5*nonAsciiCount) / divisor))\r\n//   divisors by provider/model family:\r\n//     - OpenAI: 4.0\r\n//     - Claude: 3.5\r\n//     - Gemini: 3.2\r\n\r\ntype MessageLike = { role?: string; content: string };\r\n\r\n// Small overhead configuration for chat-like messages\r\nconst OVERHEAD_PER_MESSAGE = 4;\r\nconst BASE_OVERHEAD = 2;\r\n\r\nfunction normalizeModelId(modelId: string): string {\r\n  return String(modelId || '').toLowerCase().trim();\r\n}\r\n\r\nfunction modelFamily(modelId: string): 'openai' | 'anthropic' | 'google' | 'unknown' {\r\n  const m = normalizeModelId(modelId);\r\n  if (m.includes('gpt-') || m.startsWith('gpt') || m.startsWith('o1') || m.startsWith('o3')) return 'openai';\r\n  if (m.includes('claude') || m.includes('anthropic')) return 'anthropic';\r\n  if (m.includes('gemini') || m.includes('google')) return 'google';\r\n  return 'unknown';\r\n}\r\n\r\n// Map model to preferred encoding id for js-tiktoken-like libs\r\nfunction preferredEncodingName(modelId: string): 'cl100k_base' | 'o200k_base' | 'cl100k_base' {\r\n  const m = normalizeModelId(modelId);\r\n  // Heuristic mapping:\r\n  // - Newer \"o\" and \"4o\" families prefer o200k_base when available.\r\n  if (m.includes('o1') || m.includes('o3') || m.includes('4o')) return 'o200k_base';\r\n  // Default OpenAI mapping\r\n  return 'cl100k_base';\r\n}\r\n\r\n// Attempts to get a length function via dynamic import of a tokenizer library.\r\n// Synchronous API; returns a function or null. We DO NOT await dynamic import.\r\n// Future calls may benefit if the dynamic import has resolved by then.\r\nlet tiktokenModule: any | null = null;\r\nlet tiktokenTried = false;\r\n\r\nfunction tryInitiateDynamicImport(): void {\r\n  if (tiktokenTried) return;\r\n  tiktokenTried = true;\r\n  try {\r\n    // Use non-literal dynamic specifiers so TypeScript doesn't try to resolve missing modules.\r\n    const m1 = 'js-tiktoken';\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    (import(m1 as any) as Promise<any>)\r\n      .then((mod: any) => {\r\n        tiktokenModule = mod;\r\n      })\r\n      .catch(() => {\r\n        const m2 = '@dqbd/tiktoken';\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return (import(m2 as any) as Promise<any>)\r\n          .then((mod: any) => {\r\n            tiktokenModule = mod;\r\n          })\r\n          .catch(() => {});\r\n      });\r\n  } catch {}\r\n}\r\n\r\n// Get an encoder length function for a given model if the module has loaded.\r\nfunction getEncoderLenIfReady(modelId: string): ((text: string) => number) | null {\r\n  if (!tiktokenModule) return null;\r\n  const encName = preferredEncodingName(modelId);\r\n  try {\r\n    // js-tiktoken exposes get_encoding(name)\r\n    if (typeof tiktokenModule.get_encoding === 'function') {\r\n      const enc = tiktokenModule.get_encoding(encName);\r\n      if (enc && typeof enc.encode === 'function') {\r\n        return (text: string) => {\r\n          try {\r\n            return enc.encode(text ?? '').length || 0;\r\n          } finally {\r\n            // Some encoders have a free() API; guard it if present\r\n            if (typeof enc.free === 'function') {\r\n              try { enc.free(); } catch {}\r\n            }\r\n          }\r\n        };\r\n      }\r\n    }\r\n    // @dqbd/tiktoken may expose encodingForModel(model)\r\n    if (typeof tiktokenModule.encodingForModel === 'function') {\r\n      const enc = tiktokenModule.encodingForModel(encName);\r\n      if (enc && typeof enc.encode === 'function') {\r\n        return (text: string) => enc.encode(text ?? '').length || 0;\r\n      }\r\n    }\r\n  } catch {}\r\n  return null;\r\n}\r\n\r\nfunction countAsciiAndNonAscii(s: string): { ascii: number; nonAscii: number } {\r\n  let ascii = 0;\r\n  let nonAscii = 0;\r\n  for (let i = 0; i < s.length; i++) {\r\n    const code = s.charCodeAt(i);\r\n    if (code <= 0x7f) ascii++;\r\n    else nonAscii++;\r\n  }\r\n  return { ascii, nonAscii };\r\n}\r\n\r\nfunction heuristicDivisor(modelId: string): number {\r\n  switch (modelFamily(modelId)) {\r\n    case 'openai':\r\n      return 4.0;\r\n    case 'anthropic':\r\n      return 3.5;\r\n    case 'google':\r\n      return 3.2;\r\n    default:\r\n      return 4.0;\r\n  }\r\n}\r\n\r\nfunction heuristicTokens(modelId: string, text: string): number {\r\n  const divisor = heuristicDivisor(modelId);\r\n  const { ascii, nonAscii } = countAsciiAndNonAscii(text ?? '');\r\n  const estimate = Math.round((ascii + 0.5 * nonAscii) / divisor);\r\n  return Math.max(1, estimate);\r\n}\r\n\r\n// Public API\r\n\r\nexport function estimateTokensForModel(modelId: string, text: string): number {\r\n  // Lazy-start dynamic import without side effects outside of this function.\r\n  tryInitiateDynamicImport();\r\n  const encoderLen = getEncoderLenIfReady(modelId);\r\n  if (encoderLen) {\r\n    try {\r\n      const n = encoderLen(text ?? '');\r\n      if (Number.isFinite(n) && n > 0) return n;\r\n    } catch {}\r\n  }\r\n  // Claude and Gemini: approximate via chars/token ratio when tokenizer is absent\r\n  return heuristicTokens(modelId, text ?? '');\r\n}\r\n\r\nexport function estimateMessageTokens(modelId: string, parts: Array<MessageLike>): number {\r\n  const list = Array.isArray(parts) ? parts : [];\r\n  let total = BASE_OVERHEAD;\r\n  for (const p of list) {\r\n    const content = p?.content ?? '';\r\n    total += estimateTokensForModel(modelId, content) + OVERHEAD_PER_MESSAGE;\r\n  }\r\n  return Math.max(1, total | 0);\r\n}\r\n\r\n// Expose constants for tests (not side-effectful)\r\nexport const __TEST_ONLY__TOKENIZER_CONSTANTS = {\r\n  OVERHEAD_PER_MESSAGE,\r\n  BASE_OVERHEAD,\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\__tests__\\ResponseValidator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\utils\\__tests__\\Tokenizers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\validation\\ValidationPipeline.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3048,3051],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3048,3051],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3691,3694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3691,3694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3940,3943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3940,3943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4281,4284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4281,4284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4507,4510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4507,4510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4542,4545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4542,4545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5165,5168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5165,5168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5622,5625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5622,5625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9772,9775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9772,9775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":246,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9877,9880],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9877,9880],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":246,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9917,9920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9917,9920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":253,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10270,10273],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10270,10273],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":254,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10401,10404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10401,10404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":285,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11654,11657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11654,11657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":299,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":299,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12215,12218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12215,12218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":390,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":390,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16144,16147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16144,16147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":391,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":391,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16199,16202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16199,16202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":393,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16330,16333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16330,16333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":395,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":395,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16500,16503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16500,16503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":402,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":402,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16793,16796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16793,16796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":418,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17306,17309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17306,17309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":419,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17415,17418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17415,17418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":420,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":420,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17477,17480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17477,17480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":423,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":423,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17732,17735],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17732,17735],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":437,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18298,18301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18298,18301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":439,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18440,18443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18440,18443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Consensus validation pipeline for multi-model analysis reconciliation.\r\n *\r\n * This module is self-contained and does not modify providers or AIServiceManager APIs.\r\n * It accepts an injected analyze() executor (e.g., AIServiceManager.analyze) and orchestrates:\r\n *  - optional multi-model execution (sequential)\r\n *  - issue grouping and consensus voting\r\n *  - merged AnalysisResponse synthesis with confidence computation\r\n *  - human-in-the-loop triggers and structured meta\r\n *\r\n * Inputs:\r\n *  - analyze(req, { modelId? }) => Promise<{ data: AnalysisResponse; meta?: any; modelId?: string; latencyMs?: number }>\r\n *  - AnalysisRequest type from src/services/ai/types.ts\r\n *  - AnalysisResponse type from src/services/ai/schemas/ResponseSchemas.ts\r\n *\r\n * Outputs:\r\n *  - runConsensus returns { data: AnalysisResponse; meta: { votes, perModel, attempts, humanReviewRequired, reasons } }\r\n *    where:\r\n *      - data: merged issues, summary, confidence\r\n *      - meta.votes: Record<issueHash, { count: number; modelIds: string[] }>\r\n *      - meta.perModel: Array<{ modelId: string; confidence: number }>\r\n *      - meta.attempts: number of analysis attempts executed (including failed ones)\r\n *      - meta.humanReviewRequired: boolean\r\n *      - meta.reasons: string[] describing trigger reasons\r\n *\r\n * Reconciliation logic (consensus and issue merging):\r\n *  - Group issues across models by hashIssue(issue):\r\n *      - normalized type\r\n *      - severity\r\n *      - span bucket (50-char window)\r\n *      - evidence snippet fingerprints\r\n *  - For each group:\r\n *      - votes: number of unique contributing models\r\n *      - type: majority vote\r\n *      - severity: max by severity order (low < medium < high < critical) with frequency tie-breaker\r\n *      - span: choose the span with the most votes; on tie, choose the narrowest (end - start)\r\n *      - explanation/evidence/suggested_fix: from highest-confidence contributing model\r\n *          - evidence de-duplicated and capped at 10\r\n *      - confidence: average of contributing issues' confidences; +0.05 boost if votes >= 2; clamped to [0, 1]\r\n *  - Acceptance: include merged issue if votes/totalModels >= acceptThreshold (default 0.5; thus 1/1 accepted)\r\n *  - Summary: choose from the highest-confidence model (trimmed)\r\n *  - Top-level confidence: mean of final issues' confidences; if none, 0\r\n *\r\n * Human-in-the-loop trigger when any holds:\r\n *  - any merged issue has severity === 'critical' or confidence >= humanReviewThreshold (default 0.9)\r\n *  - consensus variance high: stddev(per-model confidence) >= 0.25\r\n *  - merged issues == 0 but at least two models reported non-empty issues (disagreement)\r\n */\r\n\r\nimport type { AnalysisRequest } from '../types';\r\nimport type { AnalysisResponse } from '../schemas/ResponseSchemas';\r\n\r\n// Severity ordering for comparisons\r\nconst SEVERITY_ORDER: Record<NonNullable<ReturnType<typeof getSeverityNormalized>>, number> = {\r\n  low: 0,\r\n  medium: 1,\r\n  high: 2,\r\n  critical: 3,\r\n};\r\n\r\nfunction getSeverityNormalized(s: any): 'low' | 'medium' | 'high' | 'critical' {\r\n  if (s === 'low' || s === 'medium' || s === 'high' || s === 'critical') return s;\r\n  return 'low';\r\n}\r\n\r\nfunction clamp01(n: number): number {\r\n  if (Number.isNaN(n)) return 0;\r\n  return Math.max(0, Math.min(1, n));\r\n}\r\n\r\nfunction mean(values: number[]): number {\r\n  if (!values.length) return 0;\r\n  return values.reduce((a, b) => a + b, 0) / values.length;\r\n}\r\n\r\nfunction stddev(values: number[]): number {\r\n  if (values.length <= 1) return 0;\r\n  const m = mean(values);\r\n  const variance = mean(values.map((v) => (v - m) ** 2));\r\n  return Math.sqrt(variance);\r\n}\r\n\r\nfunction spanLength(span: any | null | undefined): number {\r\n  if (!span || typeof span.start_index !== 'number' || typeof span.end_index !== 'number') return Number.POSITIVE_INFINITY;\r\n  return Math.max(0, span.end_index - span.start_index);\r\n}\r\n\r\nfunction bucketSpan(span: any | null | undefined, bucketSize = 50): string {\r\n  if (!span || typeof span.start_index !== 'number' || typeof span.end_index !== 'number') return 'nospan';\r\n  const s = Math.floor(span.start_index / bucketSize);\r\n  const e = Math.floor(span.end_index / bucketSize);\r\n  return `${s}-${e}`;\r\n}\r\n\r\nfunction normalizeEvidenceLines(evidence: any): string[] {\r\n  if (!Array.isArray(evidence)) return [];\r\n  return evidence\r\n    .map((e) => (typeof e === 'string' ? e.trim() : ''))\r\n    .filter(Boolean);\r\n}\r\n\r\nfunction pickHighestConfidenceIssue(issues: Array<{ issue: any; modelId: string }>): { issue: any; modelId: string } {\r\n  if (!issues.length) return { issue: null, modelId: 'unknown' };\r\n  let best = issues[0];\r\n  let bestConf = typeof best.issue?.confidence === 'number' ? best.issue.confidence : 0;\r\n  for (let i = 1; i < issues.length; i++) {\r\n    const c = typeof issues[i].issue?.confidence === 'number' ? issues[i].issue.confidence : 0;\r\n    if (c > bestConf) {\r\n      best = issues[i];\r\n      bestConf = c;\r\n    }\r\n  }\r\n  return best;\r\n}\r\n\r\nexport class ValidationPipeline {\r\n  private readonly analyze: (req: AnalysisRequest, opts?: { modelId?: string }) => Promise<{\r\n    data: AnalysisResponse;\r\n    meta?: any;\r\n    modelId?: string;\r\n    latencyMs?: number;\r\n  }>;\r\n\r\n  private readonly options: {\r\n    defaultConsensusCount: number;\r\n    acceptThreshold: number;\r\n    humanReviewThreshold: number;\r\n    maxModels: number;\r\n  };\r\n\r\n  /**\r\n   * Create a ValidationPipeline with an injected single-analysis executor.\r\n   */\r\n  constructor(\r\n    analyze: (req: AnalysisRequest, opts?: { modelId?: string }) => Promise<{\r\n      data: AnalysisResponse;\r\n      meta?: any;\r\n      modelId?: string;\r\n      latencyMs?: number;\r\n    }>,\r\n    options?: {\r\n      defaultConsensusCount?: number;\r\n      acceptThreshold?: number;\r\n      humanReviewThreshold?: number;\r\n      maxModels?: number;\r\n    }\r\n  ) {\r\n    this.analyze = analyze;\r\n    this.options = {\r\n      defaultConsensusCount: options?.defaultConsensusCount ?? 1,\r\n      acceptThreshold: options?.acceptThreshold ?? 0.5,\r\n      humanReviewThreshold: options?.humanReviewThreshold ?? 0.9,\r\n      maxModels: options?.maxModels ?? 5,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Execute consensus across one or more models and reconcile results.\r\n   *\r\n   * Behavior:\r\n   *  1) Always runs at least one analysis (primary). If opts.candidates provided, selects up to consensusCount unique candidates sequentially.\r\n   *  2) Collects responses and metadata (confidence, modelId).\r\n   *  3) Reconciles into a single AnalysisResponse using voting/merging.\r\n   *  4) Computes reconciled top-level confidence and meta: { votes, perModel, attempts, humanReviewRequired, reasons }.\r\n   *  5) If no valid responses and hardFailOnInvalid, throws; else returns empty issues with confidence 0.\r\n   */\r\n  async runConsensus(\r\n    req: AnalysisRequest,\r\n    opts?: {\r\n      candidates?: string[];\r\n      consensusCount?: number;\r\n      hardFailOnInvalid?: boolean;\r\n      acceptThreshold?: number;\r\n      humanReviewThreshold?: number;\r\n      maxModels?: number;\r\n    }\r\n  ): Promise<{\r\n    data: AnalysisResponse;\r\n    meta: {\r\n      votes: Record<string, { count: number; modelIds: string[] }>;\r\n      perModel: Array<{ modelId: string; confidence: number }>;\r\n      attempts: number;\r\n      humanReviewRequired: boolean;\r\n      reasons: string[];\r\n    };\r\n  }> {\r\n    const consensusCount = Math.max(1, Math.min(opts?.consensusCount ?? this.options.defaultConsensusCount, opts?.maxModels ?? this.options.maxModels));\r\n    const acceptThreshold = typeof opts?.acceptThreshold === 'number' ? opts!.acceptThreshold : this.options.acceptThreshold;\r\n    const humanReviewThreshold = typeof opts?.humanReviewThreshold === 'number' ? opts!.humanReviewThreshold : this.options.humanReviewThreshold;\r\n\r\n    const results: Array<{ modelId: string; data: AnalysisResponse }> = [];\r\n    let attempts = 0;\r\n\r\n    if (Array.isArray(opts?.candidates) && opts!.candidates.length > 0) {\r\n      const unique = Array.from(new Set(opts!.candidates));\r\n      const chosen = unique.slice(0, consensusCount);\r\n      for (const modelId of chosen) {\r\n        attempts += 1;\r\n        try {\r\n          const r = await this.analyze(req, { modelId });\r\n          const mid = r.modelId ?? r.meta?.modelId ?? modelId ?? 'unknown';\r\n          if (r?.data && Array.isArray(r.data.issues)) {\r\n            results.push({ modelId: String(mid), data: r.data });\r\n          }\r\n        } catch {\r\n          // Swallow error; we only fail hard if no valid responses at end and hardFailOnInvalid === true\r\n        }\r\n      }\r\n    } else {\r\n      // Primary-only execution in this subtask (no model discovery)\r\n      attempts += 1;\r\n      try {\r\n        const r = await this.analyze(req);\r\n        const mid = r.modelId ?? r.meta?.modelId ?? 'primary';\r\n        if (r?.data && Array.isArray(r.data.issues)) {\r\n          results.push({ modelId: String(mid), data: r.data });\r\n        }\r\n      } catch {\r\n        // Swallow to evaluate at end\r\n      }\r\n    }\r\n\r\n    if (results.length === 0) {\r\n      if (opts?.hardFailOnInvalid) {\r\n        throw new Error('ValidationPipeline: no valid analysis responses');\r\n      }\r\n      // Return empty AnalysisResponse with confidence 0 and empty meta\r\n      return {\r\n        data: { issues: [], summary: '', confidence: 0 },\r\n        meta: {\r\n          votes: {},\r\n          perModel: [],\r\n          attempts,\r\n          humanReviewRequired: false,\r\n          reasons: [],\r\n        },\r\n      };\r\n    }\r\n\r\n    // Reconcile and collect votes\r\n    const { merged, votes } = ValidationPipeline.reconcile(results, acceptThreshold);\r\n\r\n    // Per-model confidences\r\n    const perModel = results.map(({ modelId, data }) => {\r\n      const perIssueConfs = Array.isArray(data.issues) ? data.issues.map((i: any) => (typeof i.confidence === 'number' ? i.confidence : 0)) : [];\r\n      const conf = typeof (data as any).confidence === 'number' ? (data as any).confidence : (perIssueConfs.length ? mean(perIssueConfs) : 0);\r\n      return { modelId, confidence: clamp01(conf) };\r\n    });\r\n\r\n    // Human-in-the-loop decision\r\n    const humanReviewRequired = ValidationPipeline.shouldTriggerHumanReview(merged, perModel, humanReviewThreshold);\r\n    const reasons: string[] = [];\r\n    if (merged.issues.some((i: any) => getSeverityNormalized(i.severity) === 'critical')) reasons.push('critical_issue_present');\r\n    if (merged.issues.some((i: any) => (typeof i.confidence === 'number' ? i.confidence : 0) >= humanReviewThreshold)) reasons.push('high_confidence_issue_requires_review');\r\n    if (stddev(perModel.map((p) => p.confidence)) >= 0.25) reasons.push('high_variance_between_models');\r\n    const preAcceptModelsWithIssues = results.reduce((acc, r) => acc + (Array.isArray(r.data.issues) && r.data.issues.length > 0 ? 1 : 0), 0);\r\n    if ((merged.issues?.length ?? 0) === 0 && preAcceptModelsWithIssues >= 2) reasons.push('disagreement_no_consensus');\r\n\r\n    return {\r\n      data: merged,\r\n      meta: {\r\n        votes,\r\n        perModel,\r\n        attempts,\r\n        humanReviewRequired,\r\n        reasons,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Merge multiple model results into a single AnalysisResponse based on consensus voting.\r\n   * Returns both merged payload and vote counts for transparency.\r\n   */\r\n  static reconcile(\r\n    results: Array<{ modelId: string; data: AnalysisResponse }>,\r\n    acceptThreshold: number\r\n  ): {\r\n    merged: AnalysisResponse;\r\n    votes: Record<string, { count: number; modelIds: string[] }>;\r\n  } {\r\n    const totalModels = Math.max(1, new Set(results.map((r) => r.modelId)).size);\r\n\r\n    // Build groups keyed by issue hash\r\n    type Contrib = { issue: any; modelId: string };\r\n    const groups = new Map<string, Contrib[]>();\r\n    for (const { modelId, data } of results) {\r\n      const issues = Array.isArray(data.issues) ? data.issues : [];\r\n      for (const issue of issues) {\r\n        const key = ValidationPipeline.hashIssue(issue);\r\n        const arr = groups.get(key) ?? [];\r\n        arr.push({ issue, modelId });\r\n        groups.set(key, arr);\r\n      }\r\n    }\r\n\r\n    // Compute votes and merged issues\r\n    const votes: Record<string, { count: number; modelIds: string[] }> = {};\r\n    const mergedIssues: any[] = [];\r\n\r\n    for (const [hash, contribs] of groups.entries()) {\r\n      const modelIds = Array.from(new Set(contribs.map((c) => c.modelId)));\r\n      const voteCount = modelIds.length;\r\n      votes[hash] = { count: voteCount, modelIds };\r\n\r\n      // type: majority\r\n      const typeCounts = new Map<string, number>();\r\n      for (const { issue } of contribs) {\r\n        const t = String(issue.type ?? '').toLowerCase();\r\n        typeCounts.set(t, (typeCounts.get(t) ?? 0) + 1);\r\n      }\r\n      const majorityType = Array.from(typeCounts.entries()).sort((a, b) => b[1] - a[1])[0]?.[0] ?? 'other';\r\n\r\n      // severity: max by order with frequency tie-break\r\n      const severityCounts = new Map<string, { count: number; order: number }>();\r\n      for (const { issue } of contribs) {\r\n        const sev = getSeverityNormalized(issue.severity);\r\n        const prev = severityCounts.get(sev) ?? { count: 0, order: SEVERITY_ORDER[sev] };\r\n        severityCounts.set(sev, { count: prev.count + 1, order: prev.order });\r\n      }\r\n      const mergedSeverity =\r\n        Array.from(severityCounts.entries()).sort((a, b) => {\r\n          const ao = SEVERITY_ORDER[getSeverityNormalized(a[0])];\r\n          const bo = SEVERITY_ORDER[getSeverityNormalized(b[0])];\r\n          if (bo !== ao) {\r\n            return bo - ao;\r\n          }\r\n          return (b[1].count ?? 0) - (a[1].count ?? 0);\r\n        })[0]?.[0] ?? 'low';\r\n\r\n      // span: most votes, tie => narrowest\r\n      type SpanLike = { start_index: number; end_index: number } | null;\r\n      const spanKey = (s: SpanLike) => (s ? `${s.start_index}|${s.end_index}` : 'null');\r\n      const spanCounts = new Map<string, { count: number; span: SpanLike }>();\r\n      for (const { issue } of contribs) {\r\n        const s: SpanLike =\r\n          issue && issue.span && typeof issue.span.start_index === 'number' && typeof issue.span.end_index === 'number'\r\n            ? { start_index: issue.span.start_index, end_index: issue.span.end_index }\r\n            : null;\r\n        const key = spanKey(s);\r\n        const prev = spanCounts.get(key) ?? { count: 0, span: s };\r\n        spanCounts.set(key, { count: prev.count + 1, span: s });\r\n      }\r\n      let chosenSpan: SpanLike = null;\r\n      if (spanCounts.size > 0) {\r\n        const ranked = Array.from(spanCounts.values()).sort((a, b) => {\r\n          if (b.count !== a.count) return b.count - a.count;\r\n          return spanLength(a.span) - spanLength(b.span);\r\n        });\r\n        chosenSpan = ranked[0].span ?? null;\r\n      }\r\n\r\n      // choose explanation/suggested_fix/evidence from highest-confidence contributor\r\n      const best = pickHighestConfidenceIssue(contribs);\r\n      const bestIssue = best.issue ?? {};\r\n      const mergedEvidence = Array.from(\r\n        new Set(\r\n          normalizeEvidenceLines(\r\n            contribs.flatMap(({ issue }) => normalizeEvidenceLines(issue.evidence))\r\n          )\r\n        )\r\n      ).slice(0, 10);\r\n\r\n      // confidence: average of contributing issues + boost if 2+ votes\r\n      const confs = contribs.map(({ issue }) => (typeof issue.confidence === 'number' ? issue.confidence : 0));\r\n      let mergedConfidence = mean(confs);\r\n      if (voteCount >= 2) mergedConfidence = clamp01(mergedConfidence + 0.05);\r\n\r\n      const mergedIssue = {\r\n        type: majorityType,\r\n        severity: mergedSeverity,\r\n        span: chosenSpan,\r\n        explanation: String(bestIssue.explanation ?? '').trim() || 'Issue detected',\r\n        evidence: mergedEvidence,\r\n        suggested_fix: String(bestIssue.suggested_fix ?? ''),\r\n        confidence: mergedConfidence,\r\n      };\r\n\r\n      // Acceptance by threshold\r\n      if (voteCount / totalModels >= acceptThreshold) {\r\n        mergedIssues.push(mergedIssue);\r\n      }\r\n    }\r\n\r\n    // Summary: choose from highest-confidence model\r\n    let summary = '';\r\n    {\r\n      const scored = results.map((r) => {\r\n        const conf =\r\n          typeof (r.data as any).confidence === 'number'\r\n            ? (r.data as any).confidence\r\n            : (Array.isArray(r.data.issues) && r.data.issues.length\r\n                ? mean(r.data.issues.map((i: any) => (typeof i.confidence === 'number' ? i.confidence : 0)))\r\n                : 0);\r\n        return { modelId: r.modelId, confidence: conf, summary: String((r.data as any).summary ?? '') };\r\n      });\r\n      scored.sort((a, b) => b.confidence - a.confidence);\r\n      summary = (scored[0]?.summary ?? '').trim();\r\n    }\r\n\r\n    // Top-level confidence: mean of final issues' confidences\r\n    const topConfidence = mergedIssues.length ? mean(mergedIssues.map((i: any) => (typeof i.confidence === 'number' ? i.confidence : 0))) : 0;\r\n\r\n    const merged: AnalysisResponse = {\r\n      issues: mergedIssues,\r\n      summary,\r\n      confidence: clamp01(topConfidence),\r\n    };\r\n\r\n    return { merged, votes };\r\n  }\r\n\r\n  /**\r\n   * Stable hash for grouping similar issues across models.\r\n   * Uses: normalized type, severity, span bucket, and evidence fingerprints.\r\n   */\r\n  static hashIssue(issue: AnalysisResponse['issues'][number]): string {\r\n    const typeNorm = String((issue as any)?.type ?? '').toLowerCase().trim() || 'other';\r\n    const severityNorm = getSeverityNormalized((issue as any)?.severity);\r\n    const spanBucket = bucketSpan((issue as any)?.span);\r\n    // Use coarse evidence signature to allow grouping when spans/types align but exact text differs.\r\n    // This keeps evidence influence while enabling consensus on overlapping detections.\r\n    const ev = normalizeEvidenceLines((issue as any)?.evidence);\r\n    const evidenceSig = ev.length > 0 ? 'some' : 'none';\r\n    return JSON.stringify({ t: typeNorm, s: severityNorm, b: spanBucket, e: evidenceSig });\r\n  }\r\n\r\n  /**\r\n   * Decide if a human review should be triggered based on merged results and inter-model variance.\r\n   */\r\n  static shouldTriggerHumanReview(\r\n    merged: AnalysisResponse,\r\n    perModel: Array<{ modelId: string; confidence: number }>,\r\n    threshold: number\r\n  ): boolean {\r\n    // condition 1: any critical or high-confidence issue\r\n    const hasCritical = merged.issues.some((i: any) => getSeverityNormalized(i.severity) === 'critical');\r\n    if (hasCritical) return true;\r\n    const hasHighConf = merged.issues.some((i: any) => (typeof i.confidence === 'number' ? i.confidence : 0) >= threshold);\r\n    if (hasHighConf) return true;\r\n\r\n    // condition 2: high variance across models\r\n    const varianceHigh = stddev(perModel.map((p) => clamp01(p.confidence))) >= 0.25;\r\n    if (varianceHigh) return true;\r\n\r\n    // condition 3: disagreement - merged empty but multiple models reported non-empty issues\r\n    // Note: this check is performed in runConsensus to capture pre-acceptance counts for robustness,\r\n    // but we also include a conservative check here in case callers use this helper directly.\r\n    if ((merged.issues?.length ?? 0) === 0 && perModel.length >= 2) {\r\n      // cannot infer pre-accept counts here; treat as non-trigger in helper\r\n    }\r\n\r\n    return false;\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\ai\\validation\\__tests__\\ValidationPipeline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\AnalysisCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\CacheStorage.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3740,3743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3740,3743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3994,3997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3994,3997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":144,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4561,4564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4561,4564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5372,5375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5372,5375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":219,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7014,7017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7014,7017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'now' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":423,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":423,"endColumn":16}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CacheStorage\r\n *\r\n * Two-tier cache:\r\n *  - L1: in-memory LRU (lru-cache if available; Map-based fallback)\r\n *  - L2: SQLite via better-sqlite3 (optional, dynamic require to avoid bundler/runtime issues)\r\n *\r\n * Notes:\r\n *  - 24h TTL enforced at read-time for both tiers.\r\n *  - L2 is best-effort. If unavailable or errors occur, storage operates in L1-only mode.\r\n *  - JSON serialization must handle ReaderKnowledge.knownCharacters (Set) safely.\r\n *  - Provides public underscore test hooks that delegate to private helpers.\r\n */\r\n\r\nimport path from 'path';\r\nimport type { CachedAnalysis, CacheStats } from './types';\r\n\r\n// Duplication of TTL to avoid coupling/circular import. Keep in sync with AnalysisCache.\r\nconst TTL_MS = 24 * 60 * 60 * 1000;\r\nconst L1_MAX = 200;\r\nconst L2_MAX_ROWS = 1000;\r\n\r\n// Dynamic require helper\r\nconst dynamicRequire: NodeRequire | null = (() => {\r\n  try {\r\n     \r\n    return eval('require');\r\n  } catch {\r\n    return null;\r\n  }\r\n})();\r\n\r\ntype L1Value = CachedAnalysis;\r\ntype L1Key = string;\r\n\r\n/**\r\n * Minimal LRU compatible interface used internally so we can swap implementations.\r\n */\r\ninterface LruLike<K, V> {\r\n  get(key: K): V | undefined;\r\n  set(key: K, val: V): void;\r\n  has(key: K): boolean;\r\n  delete(key: K): boolean;\r\n  clear(): void;\r\n  readonly size: number;\r\n  /** Optional keys iterator for maintenance/invalidation if available. */\r\n  keys?(): IterableIterator<K>;\r\n}\r\n\r\n/**\r\n * Map-based fallback LRU with simple recency management:\r\n *  - get: reinsert to end\r\n *  - set: evict first inserted if over capacity\r\n */\r\nclass SimpleMapLRU<K, V> implements LruLike<K, V> {\r\n  private map = new Map<K, V>();\r\n  private max: number;\r\n  constructor(max: number) { this.max = max; }\r\n  get(key: K): V | undefined {\r\n    if (!this.map.has(key)) return undefined;\r\n    const val = this.map.get(key)!;\r\n    this.map.delete(key);\r\n    this.map.set(key, val);\r\n    return val;\r\n  }\r\n  set(key: K, val: V): void {\r\n    if (this.map.has(key)) this.map.delete(key);\r\n    this.map.set(key, val);\r\n    if (this.map.size > this.max) {\r\n      const firstKey = this.map.keys().next().value;\r\n      if (firstKey !== undefined) this.map.delete(firstKey);\r\n    }\r\n  }\r\n  has(key: K): boolean { return this.map.has(key); }\r\n  delete(key: K): boolean { return this.map.delete(key); }\r\n  clear(): void { this.map.clear(); }\r\n  get size(): number { return this.map.size; }\r\n  keys(): IterableIterator<K> { return this.map.keys(); }\r\n}\r\n\r\n// Attempt to build an L1 cache using lru-cache if available.\r\nfunction createL1(max: number): LruLike<L1Key, L1Value> {\r\n  try {\r\n    if (dynamicRequire) {\r\n      const LRU = dynamicRequire('lru-cache');\r\n      if (LRU && LRU.default) {\r\n        // lru-cache v7+ exports default\r\n        const lru = new LRU.default({ max });\r\n        return {\r\n          get: (k: L1Key) => lru.get(k),\r\n          set: (k: L1Key, v: L1Value) => { lru.set(k, v); },\r\n          has: (k: L1Key) => lru.has(k),\r\n          delete: (k: L1Key) => lru.delete(k),\r\n          clear: () => lru.clear(),\r\n          get size() { return lru.size; },\r\n          keys: () => lru.keys(),\r\n        };\r\n      } else if (LRU) {\r\n        // older versions\r\n        const lru = new LRU({ max });\r\n        return {\r\n          get: (k: L1Key) => lru.get(k),\r\n          set: (k: L1Key, v: L1Value) => { lru.set(k, v); },\r\n          has: (k: L1Key) => lru.has(k),\r\n          delete: (k: L1Key) => lru.delete(k),\r\n          clear: () => lru.clear(),\r\n          get size() { return lru.size; },\r\n          keys: () => lru.keys(),\r\n        };\r\n      }\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  return new SimpleMapLRU<L1Key, L1Value>(max);\r\n}\r\n\r\n// SQLite (better-sqlite3) dynamic load\r\ntype BetterSqliteDatabase = any;\r\n\r\nfunction resolveDbPath(): string {\r\n  // Try Electron userData\r\n  try {\r\n    if (dynamicRequire) {\r\n      const electron = dynamicRequire('electron');\r\n      const userData =\r\n        electron?.app?.getPath?.('userData') ||\r\n        (electron as any)?.remote?.app?.getPath?.('userData');\r\n      if (typeof userData === 'string' && userData.length > 0) {\r\n        return path.join(userData, 'analysis-cache.sqlite');\r\n      }\r\n    }\r\n  } catch {\r\n    // ignore\r\n  }\r\n  // Fallback to CWD\r\n  return path.join(process.cwd(), 'analysis-cache.sqlite');\r\n}\r\n\r\n// Helpers to serialize/deserialize CachedAnalysis safely for DB storage\r\nfunction serializeCachedAnalysis(value: CachedAnalysis): string {\r\n  try {\r\n    // Clone and convert ReaderKnowledge.knownCharacters(Set) -> Array to ensure JSON-safe\r\n    const clone: any = JSON.parse(JSON.stringify(value, (_k, v) => {\r\n      // Basic stable conversion (structures already JSON-safe except Set)\r\n      return v;\r\n    }));\r\n    if (clone?.analysis?.readerContext?.knownCharacters instanceof Set) {\r\n      clone.analysis.readerContext.knownCharacters = Array.from(clone.analysis.readerContext.knownCharacters);\r\n    } else if (Array.isArray(clone?.analysis?.readerContext?.knownCharacters)) {\r\n      // already array, ok\r\n    } else if (value?.analysis?.readerContext?.knownCharacters instanceof Set) {\r\n      clone.analysis.readerContext.knownCharacters = Array.from(value.analysis.readerContext.knownCharacters);\r\n    }\r\n    return JSON.stringify(clone);\r\n  } catch {\r\n    // As a last resort, do a manual shallow conversion for knownCharacters\r\n    try {\r\n      const shallow: any = {\r\n        ...value,\r\n        analysis: {\r\n          ...value.analysis,\r\n          readerContext: {\r\n            ...value.analysis.readerContext,\r\n            knownCharacters: Array.from(value.analysis.readerContext.knownCharacters || []),\r\n          },\r\n        },\r\n      };\r\n      return JSON.stringify(shallow);\r\n    } catch {\r\n      // give up but avoid throwing\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\nfunction deserializeCachedAnalysis(json: string): CachedAnalysis | null {\r\n  try {\r\n    const parsed = JSON.parse(json);\r\n    if (parsed?.analysis?.readerContext?.knownCharacters && Array.isArray(parsed.analysis.readerContext.knownCharacters)) {\r\n      parsed.analysis.readerContext.knownCharacters = new Set<string>(parsed.analysis.readerContext.knownCharacters);\r\n    }\r\n    return parsed as CachedAnalysis;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\ninterface SqliteRow {\r\n  cache_key: string;\r\n  analysis_data: string;\r\n  semantic_hash: string;\r\n  cached_at: number;\r\n  last_accessed: number;\r\n  hit_count: number;\r\n  scene_id?: string | null;\r\n  position?: number | null;\r\n}\r\n\r\nexport default class CacheStorage {\r\n  private l1: LruLike<L1Key, L1Value>;\r\n  private l2Db: BetterSqliteDatabase | null = null;\r\n  private l2Available = false;\r\n\r\n  // In-memory metadata for L1 invalidation\r\n  private keyMeta = new Map<string, { sceneId?: string; position?: number }>();\r\n\r\n  // Storage-level approximate stats\r\n  private storageHits = 0;\r\n  private storageMisses = 0;\r\n\r\n  constructor() {\r\n    this.l1 = createL1(L1_MAX);\r\n  }\r\n\r\n  async init(): Promise<void> {\r\n    // initialize SQLite if possible\r\n    try {\r\n      let Database: any = null;\r\n      if (dynamicRequire) {\r\n        try {\r\n          Database = dynamicRequire('better-sqlite3');\r\n        } catch {\r\n          Database = null;\r\n        }\r\n      }\r\n\r\n      if (Database) {\r\n        const dbPath = resolveDbPath();\r\n        this.l2Db = new Database(dbPath);\r\n        this.l2Available = true;\r\n        // Create schema\r\n        this.l2Db\r\n          .prepare(\r\n            `CREATE TABLE IF NOT EXISTS analysis_cache (\r\n              cache_key TEXT PRIMARY KEY,\r\n              analysis_data TEXT NOT NULL,\r\n              semantic_hash TEXT NOT NULL,\r\n              cached_at INTEGER NOT NULL,\r\n              last_accessed INTEGER NOT NULL,\r\n              hit_count INTEGER DEFAULT 0,\r\n              scene_id TEXT,\r\n              position INTEGER\r\n            )`,\r\n          )\r\n          .run();\r\n\r\n        this.l2Db.prepare(`CREATE INDEX IF NOT EXISTS idx_scene_id ON analysis_cache(scene_id)`).run();\r\n        this.l2Db.prepare(`CREATE INDEX IF NOT EXISTS idx_position ON analysis_cache(position)`).run();\r\n        this.l2Db.prepare(`CREATE INDEX IF NOT EXISTS idx_last_accessed ON analysis_cache(last_accessed)`).run();\r\n      }\r\n    } catch (err) {\r\n      // Disable L2 for session\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] SQLite unavailable, continuing with memory-only.', err);\r\n    }\r\n  }\r\n\r\n  // Public API\r\n\r\n  async get(cacheKey: string): Promise<CachedAnalysis | null> {\r\n    try {\r\n      // L1\r\n      const fromMem = this.getFromMemory(cacheKey);\r\n      if (fromMem) {\r\n        this.storageHits++;\r\n        this.bumpAccess(cacheKey, /*l1*/ true, /*l2*/ true);\r\n        return fromMem;\r\n      }\r\n      this.storageMisses++;\r\n\r\n      // L2\r\n      const row = await this.getRowFromSQLite(cacheKey);\r\n      if (row) {\r\n        const now = Date.now();\r\n        if (now - row.cached_at > TTL_MS) {\r\n          // expired\r\n          await this.deleteFromSQLite(cacheKey);\r\n          return null;\r\n        }\r\n        const parsed = deserializeCachedAnalysis(row.analysis_data);\r\n        if (!parsed) {\r\n          // corruption\r\n          await this.deleteFromSQLite(cacheKey);\r\n          return null;\r\n        }\r\n        // hydrate L1 and metadata\r\n        this.setToMemory(cacheKey, parsed);\r\n        this.keyMeta.set(cacheKey, { sceneId: row.scene_id ?? undefined, position: row.position ?? undefined });\r\n        this.storageHits++;\r\n        this.bumpAccess(cacheKey, /*l1*/ true, /*l2*/ true);\r\n        return parsed;\r\n      }\r\n      return null;\r\n    } catch {\r\n      // Never break caller flow\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // meta is optional; if provided, allows L2 to store scene_id/position for targeted invalidation.\r\n  async set(cacheKey: string, analysis: CachedAnalysis, meta?: { sceneId?: string; position?: number }): Promise<void> {\r\n    try {\r\n      // L1\r\n      this.setToMemory(cacheKey, analysis);\r\n      if (meta) this.keyMeta.set(cacheKey, { sceneId: meta.sceneId, position: meta.position });\r\n\r\n      // L2\r\n      await this._setToSQLite(cacheKey, analysis, meta);\r\n      await this.cleanupExpired();\r\n      await this.enforceL2Capacity();\r\n    } catch (err) {\r\n      // Disable L2 on persistent failure, do not throw\r\n       \r\n      console.warn('[CacheStorage] set failed, proceeding with memory-only.', err);\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n    }\r\n  }\r\n\r\n  async getStats(): Promise<CacheStats> {\r\n    let l2Count = 0;\r\n    if (this.l2Available && this.l2Db) {\r\n      try {\r\n        const row = this.l2Db.prepare('SELECT COUNT(*) as cnt FROM analysis_cache').get();\r\n        l2Count = typeof row?.cnt === 'number' ? row.cnt : 0;\r\n      } catch {\r\n        // ignore\r\n      }\r\n    }\r\n\r\n    const totalGets = this.storageHits + this.storageMisses;\r\n    const hitRate = totalGets > 0 ? (this.storageHits / totalGets) * 100 : 0;\r\n\r\n    return {\r\n      hitRate,\r\n      size: (this.l1?.size ?? 0) + l2Count,\r\n      totalHits: this.storageHits,\r\n      totalMisses: this.storageMisses,\r\n      avgHitTime: 0,\r\n      avgGenerationTime: 0,\r\n    };\r\n    }\r\n\r\n  async clear(): Promise<void> {\r\n    try {\r\n      this.l1.clear();\r\n      this.keyMeta.clear();\r\n      if (this.l2Available && this.l2Db) {\r\n        this.l2Db.prepare('DELETE FROM analysis_cache').run();\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  // Private L1 helpers\r\n\r\n  private getFromMemory(cacheKey: string): CachedAnalysis | null {\r\n    try {\r\n      if (!this.l1?.has(cacheKey)) return null;\r\n      const val = this.l1.get(cacheKey);\r\n      if (!val) return null;\r\n      const now = Date.now();\r\n      // Enforce TTL against creation time\r\n      if (now - val.cachedAt > TTL_MS) {\r\n        this.l1.delete(cacheKey);\r\n        this.keyMeta.delete(cacheKey);\r\n        return null;\r\n      }\r\n      return val;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private setToMemory(cacheKey: string, analysis: CachedAnalysis): void {\r\n    try {\r\n      this.l1.set(cacheKey, analysis);\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  // Private L2 helpers\r\n\r\n  private async getRowFromSQLite(cacheKey: string): Promise<SqliteRow | null> {\r\n    if (!this.l2Available || !this.l2Db) return null;\r\n    try {\r\n      const row = this.l2Db\r\n        .prepare(\r\n          `SELECT cache_key, analysis_data, semantic_hash, cached_at, last_accessed, hit_count, scene_id, position\r\n           FROM analysis_cache WHERE cache_key = ?`,\r\n        )\r\n        .get(cacheKey) as SqliteRow | undefined;\r\n      return row || null;\r\n    } catch (err) {\r\n      // Disable L2 on error\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] getRowFromSQLite failed, disabling L2.', err);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Test hook: publicly exposed wrapper\r\n  public async _getFromSQLite(cacheKey: string): Promise<CachedAnalysis | null> {\r\n    const row = await this.getRowFromSQLite(cacheKey);\r\n    if (!row) return null;\r\n    const parsed = deserializeCachedAnalysis(row.analysis_data);\r\n    if (!parsed) return null;\r\n    return parsed;\r\n  }\r\n\r\n  private async setToSQLite(cacheKey: string, analysis: CachedAnalysis, meta?: { sceneId?: string; position?: number }): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      const payload = serializeCachedAnalysis(analysis);\r\n      if (!payload) return; // skip if serialization failed\r\n      const now = Date.now();\r\n      const sceneId = meta?.sceneId ?? null;\r\n      const position = typeof meta?.position === 'number' ? meta!.position : null;\r\n\r\n      this.l2Db\r\n        .prepare(\r\n          `INSERT INTO analysis_cache (cache_key, analysis_data, semantic_hash, cached_at, last_accessed, hit_count, scene_id, position)\r\n           VALUES (@cache_key, @analysis_data, @semantic_hash, @cached_at, @last_accessed, @hit_count, @scene_id, @position)\r\n           ON CONFLICT(cache_key) DO UPDATE SET\r\n             analysis_data = excluded.analysis_data,\r\n             semantic_hash = excluded.semantic_hash,\r\n             cached_at = excluded.cached_at,\r\n             last_accessed = excluded.last_accessed,\r\n             scene_id = COALESCE(excluded.scene_id, analysis_cache.scene_id),\r\n             position = COALESCE(excluded.position, analysis_cache.position)`,\r\n        )\r\n        .run({\r\n          cache_key: cacheKey,\r\n          analysis_data: payload,\r\n          semantic_hash: analysis.semanticHash,\r\n          cached_at: analysis.cachedAt,\r\n          last_accessed: analysis.lastAccessed,\r\n          hit_count: analysis.hitCount,\r\n          scene_id: sceneId,\r\n          position: position,\r\n        });\r\n    } catch (err) {\r\n      // Disable L2 on persistent failure\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] setToSQLite failed, disabling L2.', err);\r\n    }\r\n  }\r\n\r\n  // Test hook: publicly exposed wrapper\r\n  public async _setToSQLite(cacheKey: string, analysis: CachedAnalysis, meta?: { sceneId?: string; position?: number }): Promise<void> {\r\n    await this.setToSQLite(cacheKey, analysis, meta);\r\n  }\r\n\r\n  private async deleteFromSQLite(cacheKey: string): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      this.l2Db.prepare('DELETE FROM analysis_cache WHERE cache_key = ?').run(cacheKey);\r\n    } catch (err) {\r\n      // Disable L2 on error\r\n      this.l2Available = false;\r\n      this.l2Db = null;\r\n       \r\n      console.warn('[CacheStorage] deleteFromSQLite failed, disabling L2.', err);\r\n    }\r\n  }\r\n\r\n  private async enforceL2Capacity(): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      const countRow = this.l2Db.prepare('SELECT COUNT(*) as cnt FROM analysis_cache').get();\r\n      const cnt = typeof countRow?.cnt === 'number' ? countRow.cnt : 0;\r\n      const excess = cnt - L2_MAX_ROWS;\r\n      if (excess > 0) {\r\n        this.l2Db\r\n          .prepare(\r\n            `DELETE FROM analysis_cache\r\n             WHERE cache_key IN (\r\n               SELECT cache_key FROM analysis_cache\r\n               ORDER BY last_accessed ASC\r\n               LIMIT ?\r\n             )`,\r\n          )\r\n          .run(excess);\r\n      }\r\n    } catch (err) {\r\n      // ignore; not critical\r\n       \r\n      console.warn('[CacheStorage] enforceL2Capacity warning:', err);\r\n    }\r\n  }\r\n\r\n  private async cleanupExpired(): Promise<void> {\r\n    if (!this.l2Available || !this.l2Db) return;\r\n    try {\r\n      const cutoff = Date.now() - TTL_MS;\r\n      this.l2Db.prepare('DELETE FROM analysis_cache WHERE cached_at < ?').run(cutoff);\r\n    } catch (err) {\r\n      // ignore\r\n       \r\n      console.warn('[CacheStorage] cleanupExpired warning:', err);\r\n    }\r\n  }\r\n\r\n  private bumpAccess(cacheKey: string, bumpL1: boolean, bumpL2: boolean): void {\r\n    const now = Date.now();\r\n    if (bumpL1) {\r\n      const val = this.l1.get(cacheKey);\r\n      if (val) {\r\n        const bumped: CachedAnalysis = {\r\n          ...val,\r\n          lastAccessed: now,\r\n          hitCount: (val.hitCount || 0) + 1,\r\n        };\r\n        this.l1.set(cacheKey, bumped);\r\n      }\r\n    }\r\n    if (bumpL2 && this.l2Available && this.l2Db) {\r\n      try {\r\n        this.l2Db\r\n          .prepare('UPDATE analysis_cache SET last_accessed = ?, hit_count = hit_count + 1 WHERE cache_key = ?')\r\n          .run(now, cacheKey);\r\n      } catch {\r\n        // ignore\r\n      }\r\n    }\r\n  }\r\n\r\n  // Private invalidation helpers (invoked by AnalysisCache using symbolic helper call with \"as any\")\r\n\r\n  private deleteBySceneId(sceneId: string): number {\r\n    let removed = 0;\r\n    // L1 by metadata map\r\n    try {\r\n      for (const [key, meta] of this.keyMeta.entries()) {\r\n        if (meta.sceneId === sceneId) {\r\n          if (this.l1.delete(key)) removed++;\r\n          this.keyMeta.delete(key);\r\n        }\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    // L2\r\n    try {\r\n      if (this.l2Available && this.l2Db) {\r\n        const info = this.l2Db.prepare('DELETE FROM analysis_cache WHERE scene_id = ?').run(sceneId);\r\n        removed += info?.changes ?? 0;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return removed;\r\n  }\r\n\r\n  private deleteByPosition(position: number): number {\r\n    let removed = 0;\r\n    // L1 by metadata map\r\n    try {\r\n      for (const [key, meta] of this.keyMeta.entries()) {\r\n        if (typeof meta.position === 'number' && meta.position === position) {\r\n          if (this.l1.delete(key)) removed++;\r\n          this.keyMeta.delete(key);\r\n        }\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    // L2\r\n    try {\r\n      if (this.l2Available && this.l2Db) {\r\n        const info = this.l2Db.prepare('DELETE FROM analysis_cache WHERE position = ?').run(position);\r\n        removed += info?.changes ?? 0;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return removed;\r\n  }\r\n\r\n  // Public underscore test hooks for memory\r\n  public _getFromMemory(cacheKey: string): CachedAnalysis | null {\r\n    return this.getFromMemory(cacheKey);\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\SemanticHasher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\cache\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\export\\ManuscriptExporter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'orderedScenes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":145,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Manuscript, Scene, RewriteVersion } from '../../shared/types';\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport interface ExportOptions {\r\n  format: 'original' | 'rewritten' | 'both' | 'changelog';\r\n  includeMetadata: boolean;\r\n  includeChangeLog: boolean;\r\n  changeLogDetail: 'summary' | 'detailed';\r\n  outputPath?: string;\r\n  filename?: string;\r\n}\r\n\r\nexport interface ExportResult {\r\n  success: boolean;\r\n  filePath?: string;\r\n  error?: string;\r\n  stats?: {\r\n    totalScenes: number;\r\n    rewrittenScenes: number;\r\n    totalWords: number;\r\n    totalChanges: number;\r\n  };\r\n}\r\n\r\nexport interface ChangeLogEntry {\r\n  sceneNumber: number;\r\n  sceneTitle: string;\r\n  changes: {\r\n    issueType: string;\r\n    description: string;\r\n    fix: string;\r\n  }[];\r\n  wordCountBefore: number;\r\n  wordCountAfter: number;\r\n  modelUsed?: string;\r\n  timestamp?: number;\r\n}\r\n\r\nclass ManuscriptExporter {\r\n  /**\r\n   * Export manuscript with various format options\r\n   */\r\n  async exportManuscript(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): Promise<ExportResult> {\r\n    try {\r\n      const stats = this.calculateStats(manuscript, rewrites);\r\n      \r\n      let content: string;\r\n      switch (options.format) {\r\n        case 'original':\r\n          content = this.exportOriginal(manuscript);\r\n          break;\r\n        case 'rewritten':\r\n          content = this.exportRewritten(manuscript, rewrites);\r\n          break;\r\n        case 'both':\r\n          content = this.exportBothVersions(manuscript, rewrites, options);\r\n          break;\r\n        case 'changelog':\r\n          content = this.exportChangeLog(manuscript, rewrites, options);\r\n          break;\r\n        default:\r\n          content = this.exportRewritten(manuscript, rewrites);\r\n      }\r\n      \r\n      // Add metadata header if requested\r\n      if (options.includeMetadata) {\r\n        content = this.addMetadataHeader(manuscript, stats, options) + content;\r\n      }\r\n      \r\n      // Add change log section if requested\r\n      if (options.includeChangeLog && options.format !== 'changelog') {\r\n        content += this.generateChangeLogSection(manuscript, rewrites, options);\r\n      }\r\n      \r\n      // Determine output path\r\n      const outputPath = options.outputPath || process.cwd();\r\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\r\n      const defaultFilename = `${manuscript.title || 'manuscript'}_${options.format}_${timestamp}.txt`;\r\n      const filename = options.filename || defaultFilename;\r\n      const filePath = path.join(outputPath, filename);\r\n      \r\n      // Write file\r\n      await fs.writeFile(filePath, content, 'utf-8');\r\n      \r\n      return {\r\n        success: true,\r\n        filePath,\r\n        stats\r\n      };\r\n      \r\n    } catch (error) {\r\n       \r\n      console.error('[ManuscriptExporter] Export error:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Export failed'\r\n      };\r\n    }\r\n  }\r\n  \r\n  private exportOriginal(manuscript: Manuscript): string {\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    return orderedScenes\r\n      .map(scene => scene.text)\r\n      .join('\\n\\n### SCENE BREAK ###\\n\\n');\r\n  }\r\n  \r\n  private exportRewritten(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>\r\n  ): string {\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    \r\n    return orderedScenes\r\n      .map(scene => {\r\n        // Use applied rewrite if available, otherwise original\r\n        if (scene.rewriteStatus === 'approved') {\r\n          // Scene text was already updated with rewrite\r\n          return scene.text;\r\n        }\r\n        \r\n        // Check for unapplied rewrites\r\n        const sceneRewrites = rewrites.get(scene.id);\r\n        const latestRewrite = sceneRewrites?.[sceneRewrites.length - 1];\r\n        \r\n        if (latestRewrite && latestRewrite.rewrittenText) {\r\n          return latestRewrite.rewrittenText;\r\n        }\r\n        \r\n        return scene.text;\r\n      })\r\n      .join('\\n\\n### SCENE BREAK ###\\n\\n');\r\n  }\r\n  \r\n  private exportBothVersions(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): string {\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    const sections: string[] = [];\r\n    \r\n    // Add table of contents\r\n    sections.push('TABLE OF CONTENTS\\n' + '='.repeat(50) + '\\n');\r\n    sections.push('Original Version ............... Page 1');\r\n    sections.push('Rewritten Version .............. Page 2');\r\n    if (options.includeChangeLog) {\r\n      sections.push('Change Log ..................... Page 3');\r\n    }\r\n    sections.push('\\n\\n');\r\n    \r\n    // Original version\r\n    sections.push('ORIGINAL VERSION\\n' + '='.repeat(50) + '\\n\\n');\r\n    sections.push(this.exportOriginal(manuscript));\r\n    sections.push('\\n\\n' + '='.repeat(50) + '\\n\\n');\r\n    \r\n    // Rewritten version\r\n    sections.push('REWRITTEN VERSION\\n' + '='.repeat(50) + '\\n\\n');\r\n    sections.push(this.exportRewritten(manuscript, rewrites));\r\n    \r\n    return sections.join('');\r\n  }\r\n  \r\n  private exportChangeLog(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): string {\r\n    const entries = this.buildChangeLogEntries(manuscript, rewrites);\r\n    \r\n    const sections: string[] = [\r\n      'MANUSCRIPT CHANGE LOG',\r\n      '='.repeat(50),\r\n      `Generated: ${new Date().toLocaleString()}`,\r\n      `Total Scenes: ${manuscript.scenes.length}`,\r\n      `Scenes Rewritten: ${entries.length}`,\r\n      '',\r\n      '='.repeat(50),\r\n      ''\r\n    ];\r\n    \r\n    if (entries.length === 0) {\r\n      sections.push('No scenes have been rewritten.');\r\n      return sections.join('\\n');\r\n    }\r\n    \r\n    // Add entries\r\n    entries.forEach((entry, index) => {\r\n      sections.push(`\\nSCENE ${entry.sceneNumber}`);\r\n      sections.push('-'.repeat(30));\r\n      \r\n      if (entry.sceneTitle) {\r\n        sections.push(`Title: ${entry.sceneTitle}`);\r\n      }\r\n      \r\n      sections.push(`Word Count: ${entry.wordCountBefore}  ${entry.wordCountAfter} (${\r\n        entry.wordCountAfter - entry.wordCountBefore > 0 ? '+' : ''\r\n      }${entry.wordCountAfter - entry.wordCountBefore})`);\r\n      \r\n      if (entry.modelUsed) {\r\n        sections.push(`AI Model: ${entry.modelUsed}`);\r\n      }\r\n      \r\n      sections.push('\\nChanges Made:');\r\n      entry.changes.forEach(change => {\r\n        sections.push(`   ${change.issueType.toUpperCase()}: ${change.description}`);\r\n        if (options.changeLogDetail === 'detailed' && change.fix) {\r\n          sections.push(`     ${change.fix}`);\r\n        }\r\n      });\r\n      \r\n      if (index < entries.length - 1) {\r\n        sections.push('');\r\n      }\r\n    });\r\n    \r\n    return sections.join('\\n');\r\n  }\r\n  \r\n  private generateChangeLogSection(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>,\r\n    options: ExportOptions\r\n  ): string {\r\n    const changeLog = this.exportChangeLog(manuscript, rewrites, options);\r\n    return '\\n\\n' + '='.repeat(50) + '\\n\\n' + changeLog;\r\n  }\r\n  \r\n  private addMetadataHeader(\r\n    manuscript: Manuscript,\r\n    stats: ExportResult['stats'],\r\n    options: ExportOptions\r\n  ): string {\r\n    const header: string[] = [\r\n      '='.repeat(50),\r\n      'MANUSCRIPT EXPORT',\r\n      '='.repeat(50),\r\n      `Title: ${manuscript.title || 'Untitled'}`,\r\n      `Export Date: ${new Date().toLocaleString()}`,\r\n      `Export Format: ${options.format}`,\r\n      `Total Scenes: ${stats?.totalScenes || 0}`,\r\n      `Rewritten Scenes: ${stats?.rewrittenScenes || 0}`,\r\n      `Total Words: ${stats?.totalWords || 0}`,\r\n      '='.repeat(50),\r\n      '\\n\\n'\r\n    ];\r\n    \r\n    return header.join('\\n');\r\n  }\r\n  \r\n  private buildChangeLogEntries(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>\r\n  ): ChangeLogEntry[] {\r\n    const entries: ChangeLogEntry[] = [];\r\n    const orderedScenes = this.getOrderedScenes(manuscript);\r\n    \r\n    orderedScenes.forEach((scene, index) => {\r\n      const sceneRewrites = rewrites.get(scene.id);\r\n      const latestRewrite = sceneRewrites?.[sceneRewrites.length - 1];\r\n      \r\n      if (latestRewrite && (scene.rewriteStatus === 'approved' || latestRewrite.rewrittenText)) {\r\n        const entry: ChangeLogEntry = {\r\n          sceneNumber: index + 1,\r\n          sceneTitle: this.extractSceneTitle(scene.text),\r\n          changes: latestRewrite.issuesAddressed.map(issue => ({\r\n            issueType: issue.type,\r\n            description: issue.description,\r\n            fix: issue.suggestedFix || 'Applied contextual fix'\r\n          })),\r\n          wordCountBefore: scene.wordCount,\r\n          wordCountAfter: this.countWords(\r\n            scene.rewriteStatus === 'approved' ? scene.text : latestRewrite.rewrittenText\r\n          ),\r\n          modelUsed: latestRewrite.modelUsed,\r\n          timestamp: latestRewrite.timestamp\r\n        };\r\n        \r\n        entries.push(entry);\r\n      }\r\n    });\r\n    \r\n    return entries;\r\n  }\r\n  \r\n  private getOrderedScenes(manuscript: Manuscript): Scene[] {\r\n    return manuscript.currentOrder\r\n      .map(id => manuscript.scenes.find(s => s.id === id))\r\n      .filter(Boolean) as Scene[];\r\n  }\r\n  \r\n  private calculateStats(\r\n    manuscript: Manuscript,\r\n    rewrites: Map<string, RewriteVersion[]>\r\n  ): ExportResult['stats'] {\r\n    const rewrittenScenes = manuscript.scenes.filter(scene => \r\n      scene.rewriteStatus === 'approved' || rewrites.has(scene.id)\r\n    );\r\n    \r\n    const totalWords = manuscript.scenes.reduce((sum, scene) => {\r\n      if (scene.rewriteStatus === 'approved') {\r\n        return sum + scene.wordCount;\r\n      }\r\n      const rewrite = rewrites.get(scene.id)?.[0];\r\n      if (rewrite?.rewrittenText) {\r\n        return sum + this.countWords(rewrite.rewrittenText);\r\n      }\r\n      return sum + scene.wordCount;\r\n    }, 0);\r\n    \r\n    const totalChanges = Array.from(rewrites.values())\r\n      .reduce((sum, versions) => {\r\n        const latest = versions[versions.length - 1];\r\n        return sum + (latest?.issuesAddressed.length || 0);\r\n      }, 0);\r\n    \r\n    return {\r\n      totalScenes: manuscript.scenes.length,\r\n      rewrittenScenes: rewrittenScenes.length,\r\n      totalWords,\r\n      totalChanges\r\n    };\r\n  }\r\n  \r\n  private extractSceneTitle(text: string): string {\r\n    const firstLine = text.split('\\n')[0];\r\n    if (firstLine && firstLine.length < 100) {\r\n      return firstLine.trim();\r\n    }\r\n    return text.substring(0, 50).trim() + '...';\r\n  }\r\n  \r\n  private countWords(text: string): number {\r\n    return text.split(/\\s+/).filter(word => word.length > 0).length;\r\n  }\r\n}\r\n\r\nexport default ManuscriptExporter;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\export\\__tests__\\ManuscriptExporter.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1734,1737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1734,1737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\nimport * as os from 'os';\r\nimport ManuscriptExporter from '../ManuscriptExporter';\r\nimport type { Manuscript, Scene, RewriteVersion, ContinuityIssue } from '../../../shared/types';\r\n\r\nfunction countWords(s: string): number {\r\n  return s.split(/\\s+/).filter(Boolean).length;\r\n}\r\n\r\nfunction makeScenes(): Scene[] {\r\n  const s1Text = 'Scene One. Alice enters. Morning light fills the room.';\r\n  const s2Text = 'Scene Two. She greets Bob. They talk about yesterday.';\r\n  const s1: Scene = {\r\n    id: 's1',\r\n    text: s1Text,\r\n    wordCount: countWords(s1Text),\r\n    position: 0,\r\n    originalPosition: 0,\r\n    characters: ['Alice'],\r\n    timeMarkers: ['Morning'],\r\n    locationMarkers: ['Apartment'],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending'\r\n  };\r\n  const s2: Scene = {\r\n    id: 's2',\r\n    text: s2Text,\r\n    wordCount: countWords(s2Text),\r\n    position: 1,\r\n    originalPosition: 1,\r\n    characters: ['Alice', 'Bob'],\r\n    timeMarkers: ['Yesterday'],\r\n    locationMarkers: ['Apartment'],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending'\r\n  };\r\n  return [s1, s2];\r\n}\r\n\r\nfunction makeManuscript(): Manuscript {\r\n  const scenes = makeScenes();\r\n  return {\r\n    id: 'm1',\r\n    title: 'Test Manuscript',\r\n    scenes,\r\n    originalOrder: scenes.map(s => s.id),\r\n    currentOrder: scenes.map(s => s.id),\r\n    filePath: undefined\r\n  };\r\n}\r\n\r\nfunction makeRewrites(): Map<string, RewriteVersion[]> {\r\n  const issue: ContinuityIssue = {\r\n    type: 'pronoun',\r\n    severity: 'should-fix',\r\n    description: 'Ambiguous pronoun \"She\".',\r\n    textSpan: [0, 3],\r\n    suggestedFix: 'Clarify the subject.'\r\n  } as any;\r\n\r\n  const rewritten = 'Scene Two. Alice greets Bob. They talk about yesterday.';\r\n  const v: RewriteVersion = {\r\n    id: 'r1',\r\n    sceneId: 's2',\r\n    timestamp: Date.now(),\r\n    rewrittenText: rewritten,\r\n    issuesAddressed: [issue],\r\n    changesExplanation: 'Clarified pronoun.',\r\n    modelUsed: 'claude-3-opus',\r\n    userEdited: false,\r\n    appliedToManuscript: false\r\n  };\r\n  return new Map<string, RewriteVersion[]>([['s2', [v]]]);\r\n}\r\n\r\nasync function makeTmpDir(): Promise<string> {\r\n  const base = await fs.mkdtemp(path.join(os.tmpdir(), 'exporter-test-'));\r\n  return base;\r\n}\r\n\r\ndescribe('ManuscriptExporter', () => {\r\n  it('exports original format with scene breaks', async () => {\r\n    const exporter = new ManuscriptExporter();\r\n    const manuscript = makeManuscript();\r\n    const rewrites = new Map<string, RewriteVersion[]>();\r\n    const dir = await makeTmpDir();\r\n\r\n    const result = await exporter.exportManuscript(manuscript, rewrites, {\r\n      format: 'original',\r\n      includeMetadata: false,\r\n      includeChangeLog: false,\r\n      changeLogDetail: 'summary',\r\n      outputPath: dir,\r\n      filename: 'original.txt'\r\n    });\r\n\r\n    expect(result.success).toBe(true);\r\n    expect(result.filePath).toBeTruthy();\r\n\r\n    const content = await fs.readFile(result.filePath!, 'utf-8');\r\n    expect(content).toContain('Scene One.');\r\n    expect(content).toContain('Scene Two.');\r\n    expect(content).toContain('### SCENE BREAK ###');\r\n    expect(result.stats).toBeTruthy();\r\n    expect(result.stats!.totalScenes).toBe(2);\r\n  });\r\n\r\n  it('exports rewritten format using latest rewrite when not approved', async () => {\r\n    const exporter = new ManuscriptExporter();\r\n    const manuscript = makeManuscript();\r\n    const rewrites = makeRewrites();\r\n    const dir = await makeTmpDir();\r\n\r\n    const result = await exporter.exportManuscript(manuscript, rewrites, {\r\n      format: 'rewritten',\r\n      includeMetadata: false,\r\n      includeChangeLog: false,\r\n      changeLogDetail: 'summary',\r\n      outputPath: dir,\r\n      filename: 'rewritten.txt'\r\n    });\r\n\r\n    expect(result.success).toBe(true);\r\n    const content = await fs.readFile(result.filePath!, 'utf-8');\r\n    // Rewritten scene 2 must be used\r\n    expect(content).toContain('Alice greets Bob');\r\n    // Original scene 1 still present\r\n    expect(content).toContain('Scene One.');\r\n  });\r\n\r\n  it('exports both versions with section headers', async () => {\r\n    const exporter = new ManuscriptExporter();\r\n    const manuscript = makeManuscript();\r\n    const rewrites = makeRewrites();\r\n    const dir = await makeTmpDir();\r\n\r\n    const result = await exporter.exportManuscript(manuscript, rewrites, {\r\n      format: 'both',\r\n      includeMetadata: true,\r\n      includeChangeLog: true,\r\n      changeLogDetail: 'summary',\r\n      outputPath: dir,\r\n      filename: 'both.txt'\r\n    });\r\n\r\n    expect(result.success).toBe(true);\r\n    const content = await fs.readFile(result.filePath!, 'utf-8');\r\n    expect(content).toContain('MANUSCRIPT EXPORT');\r\n    expect(content).toContain('ORIGINAL VERSION');\r\n    expect(content).toContain('REWRITTEN VERSION');\r\n  });\r\n\r\n  it('exports change log only and attributes model', async () => {\r\n    const exporter = new ManuscriptExporter();\r\n    const manuscript = makeManuscript();\r\n    const rewrites = makeRewrites();\r\n    const dir = await makeTmpDir();\r\n\r\n    const result = await exporter.exportManuscript(manuscript, rewrites, {\r\n      format: 'changelog',\r\n      includeMetadata: false,\r\n      includeChangeLog: false,\r\n      changeLogDetail: 'detailed',\r\n      outputPath: dir,\r\n      filename: 'changelog.txt'\r\n    });\r\n\r\n    expect(result.success).toBe(true);\r\n    const content = await fs.readFile(result.filePath!, 'utf-8');\r\n    expect(content).toContain('MANUSCRIPT CHANGE LOG');\r\n    expect(content).toContain('AI Model:');\r\n    // Document fixes: ensure issue type and description are present (no quality scores)\r\n    expect(content).toMatch(/PRONOUN: Ambiguous pronoun/i);\r\n  });\r\n\r\n  it('appends change log when requested and returns stats', async () => {\r\n    const exporter = new ManuscriptExporter();\r\n    const manuscript = makeManuscript();\r\n    const rewrites = makeRewrites();\r\n    const dir = await makeTmpDir();\r\n\r\n    const result = await exporter.exportManuscript(manuscript, rewrites, {\r\n      format: 'rewritten',\r\n      includeMetadata: true,\r\n      includeChangeLog: true,\r\n      changeLogDetail: 'summary',\r\n      outputPath: dir,\r\n      filename: 'with-changelog.txt'\r\n    });\r\n\r\n    expect(result.success).toBe(true);\r\n    expect(result.stats).toBeTruthy();\r\n    expect(result.stats!.totalScenes).toBe(2);\r\n    expect(result.stats!.rewrittenScenes).toBeGreaterThanOrEqual(1);\r\n\r\n    const content = await fs.readFile(result.filePath!, 'utf-8');\r\n    expect(content).toContain('MANUSCRIPT EXPORT');\r\n    expect(content).toContain('MANUSCRIPT CHANGE LOG');\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\DiffEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\PerformanceOptimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BatchRewriteProgress' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3734,3737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3734,3737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3787,3790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3787,3790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { BatchRewriteProgress } from './RewriteOrchestrator';\r\n\r\nexport interface PerformanceMetrics {\r\n  avgRewriteTime: number;\r\n  cacheHitRate: number;\r\n  memoryUsage: number;\r\n  errorRate: number;\r\n  lastUpdated: number;\r\n}\r\n\r\nclass PerformanceOptimizer {\r\n  private metrics: PerformanceMetrics = {\r\n    avgRewriteTime: 0,\r\n    cacheHitRate: 0,\r\n    memoryUsage: 0,\r\n    errorRate: 0,\r\n    lastUpdated: Date.now()\r\n  };\r\n  \r\n  private rewriteTimes: number[] = [];\r\n  private cacheHits = 0;\r\n  private cacheMisses = 0;\r\n  private errors = 0;\r\n  private total = 0;\r\n  \r\n  /**\r\n   * Track rewrite performance\r\n   */\r\n  trackRewrite(startTime: number, success: boolean, cached: boolean = false): void {\r\n    const duration = Date.now() - startTime;\r\n    this.total++;\r\n    \r\n    if (success) {\r\n      this.rewriteTimes.push(duration);\r\n      // Keep only last 100 times for moving average\r\n      if (this.rewriteTimes.length > 100) {\r\n        this.rewriteTimes.shift();\r\n      }\r\n    } else {\r\n      this.errors++;\r\n    }\r\n    \r\n    if (cached) {\r\n      this.cacheHits++;\r\n    } else {\r\n      this.cacheMisses++;\r\n    }\r\n    \r\n    this.updateMetrics();\r\n  }\r\n  \r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getMetrics(): PerformanceMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n  \r\n  /**\r\n   * Suggest optimizations based on current metrics\r\n   */\r\n  getSuggestions(): string[] {\r\n    const suggestions: string[] = [];\r\n    \r\n    if (this.metrics.avgRewriteTime > 30000) {\r\n      suggestions.push('Consider using simpler models for basic issues');\r\n    }\r\n    \r\n    if (this.metrics.cacheHitRate < 0.3 && this.total > 10) {\r\n      suggestions.push('Low cache hit rate - ensure cache is properly configured');\r\n    }\r\n    \r\n    if (this.metrics.errorRate > 0.1) {\r\n      suggestions.push('High error rate detected - check API keys and network');\r\n    }\r\n    \r\n    if (this.metrics.memoryUsage > 500) {\r\n      suggestions.push('High memory usage - consider clearing old rewrites');\r\n    }\r\n    \r\n    return suggestions;\r\n  }\r\n  \r\n  /**\r\n   * Optimize batch size based on performance\r\n   */\r\n  getOptimalBatchSize(): number {\r\n    if (this.metrics.avgRewriteTime < 5000) {\r\n      return 10; // Fast processing, larger batches OK\r\n    } else if (this.metrics.avgRewriteTime < 15000) {\r\n      return 5; // Medium speed\r\n    } else {\r\n      return 3; // Slow processing, smaller batches\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Clean up old data to free memory\r\n   */\r\n  cleanup(): void {\r\n    // Clear old metrics\r\n    if (this.rewriteTimes.length > 100) {\r\n      this.rewriteTimes = this.rewriteTimes.slice(-100);\r\n    }\r\n    \r\n    // Reset counters periodically\r\n    if (this.total > 1000) {\r\n      const hitRate = this.metrics.cacheHitRate;\r\n      const errorRate = this.metrics.errorRate;\r\n      \r\n      // Reset but maintain ratios\r\n      this.cacheHits = Math.round(hitRate * 100);\r\n      this.cacheMisses = Math.round((1 - hitRate) * 100);\r\n      this.errors = Math.round(errorRate * 100);\r\n      this.total = 100;\r\n    }\r\n  }\r\n  \r\n  private updateMetrics(): void {\r\n    // Calculate average rewrite time\r\n    if (this.rewriteTimes.length > 0) {\r\n      const sum = this.rewriteTimes.reduce((a, b) => a + b, 0);\r\n      this.metrics.avgRewriteTime = Math.round(sum / this.rewriteTimes.length);\r\n    }\r\n    \r\n    // Calculate cache hit rate\r\n    const cacheTotal = this.cacheHits + this.cacheMisses;\r\n    if (cacheTotal > 0) {\r\n      this.metrics.cacheHitRate = this.cacheHits / cacheTotal;\r\n    }\r\n    \r\n    // Calculate error rate\r\n    if (this.total > 0) {\r\n      this.metrics.errorRate = this.errors / this.total;\r\n    }\r\n    \r\n    // Estimate memory usage (simplified)\r\n    if (typeof process !== 'undefined' && (process as any).memoryUsage) {\r\n      const usage = (process as any).memoryUsage();\r\n      this.metrics.memoryUsage = Math.round(usage.heapUsed / 1024 / 1024); // MB\r\n    }\r\n    \r\n    this.metrics.lastUpdated = Date.now();\r\n  }\r\n}\r\n\r\nexport default PerformanceOptimizer;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\RewriteOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ContinuityIssue' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import SceneRewriter from './SceneRewriter';\r\nimport type { Scene, ContinuityIssue, ReaderKnowledge } from '../../shared/types';\r\nimport type { RewriteResult } from './SceneRewriter';\r\nimport AIServiceManager from '../ai/AIServiceManager';\r\n\r\nexport interface BatchRewriteProgress {\r\n  totalScenes: number;\r\n  completedScenes: number;\r\n  currentSceneId?: string;\r\n  currentSceneTitle?: string;\r\n  phase: 'preparing' | 'analyzing' | 'rewriting' | 'complete' | 'error';\r\n  message: string;\r\n  results: Map<string, RewriteResult>;\r\n  errors: Map<string, string>;\r\n}\r\n\r\nexport interface BatchRewriteOptions {\r\n  sceneIds?: string[];  // Specific scenes, or all moved if not provided\r\n  skipIfNoIssues?: boolean;\r\n  preserveElements?: Map<string, string[]>; // Per-scene preservation\r\n  progressCallback?: (progress: BatchRewriteProgress) => void;\r\n}\r\n\r\nclass RewriteOrchestrator {\r\n  private sceneRewriter: SceneRewriter;\r\n  private aiManager: AIServiceManager;\r\n  private currentBatch?: AbortController;\r\n\r\n  constructor(aiManager?: AIServiceManager) {\r\n    this.aiManager = aiManager || new AIServiceManager();\r\n    this.sceneRewriter = new SceneRewriter(this.aiManager);\r\n  }\r\n\r\n  /**\r\n   * Rewrite multiple moved scenes in dependency order\r\n   */\r\n  async rewriteMovedScenes(\r\n    manuscript: { scenes: Scene[]; currentOrder: string[] },\r\n    options: BatchRewriteOptions = {}\r\n  ): Promise<BatchRewriteProgress> {\r\n    // Cancel any existing batch\r\n    this.cancelBatch();\r\n    this.currentBatch = new AbortController();\r\n\r\n    const progress: BatchRewriteProgress = {\r\n      totalScenes: 0,\r\n      completedScenes: 0,\r\n      phase: 'preparing',\r\n      message: 'Preparing batch rewrite...',\r\n      results: new Map(),\r\n      errors: new Map()\r\n    };\r\n\r\n    try {\r\n      // Step 1: Identify scenes to rewrite\r\n      const scenesToRewrite = this.identifyScenesToRewrite(manuscript, options);\r\n      progress.totalScenes = scenesToRewrite.length;\r\n\r\n      if (scenesToRewrite.length === 0) {\r\n        progress.phase = 'complete';\r\n        progress.message = 'No scenes need rewriting';\r\n        return progress;\r\n      }\r\n\r\n      // Step 2: Order scenes by dependency (narrative) order\r\n      const orderedScenes = this.orderByDependency(scenesToRewrite, manuscript.currentOrder);\r\n\r\n      progress.phase = 'analyzing';\r\n      progress.message = `Analyzing ${scenesToRewrite.length} scenes...`;\r\n      options.progressCallback?.(progress);\r\n\r\n      // Step 3: Process each scene\r\n      for (const sceneId of orderedScenes) {\r\n        if (this.currentBatch?.signal.aborted) {\r\n          progress.phase = 'error';\r\n          progress.message = 'Batch rewrite cancelled';\r\n          break;\r\n        }\r\n\r\n        const scene = manuscript.scenes.find(s => s.id === sceneId);\r\n        if (!scene) {\r\n          progress.errors.set(sceneId, 'Scene not found');\r\n          progress.completedScenes++;\r\n          options.progressCallback?.(progress);\r\n          continue;\r\n        }\r\n\r\n        progress.currentSceneId = sceneId;\r\n        progress.currentSceneTitle = this.getSceneTitle(scene);\r\n        progress.phase = 'rewriting';\r\n        progress.message = `Rewriting scene ${progress.completedScenes + 1} of ${progress.totalScenes}`;\r\n        options.progressCallback?.(progress);\r\n\r\n        try {\r\n          // Get issues from analysis\r\n          const issues = scene.continuityAnalysis?.issues || [];\r\n          if (options.skipIfNoIssues && issues.length === 0) {\r\n            progress.completedScenes++;\r\n            continue;\r\n          }\r\n\r\n          // Build reader context from previous scenes\r\n          const readerContext = this.buildReaderContext(\r\n            manuscript,\r\n            sceneId,\r\n            progress.results\r\n          );\r\n\r\n          // Get previous scenes (including any already rewritten)\r\n          const previousScenes = this.getPreviousScenes(\r\n            manuscript,\r\n            sceneId,\r\n            progress.results\r\n          );\r\n\r\n          // Rewrite the scene\r\n          const result = await this.sceneRewriter.rewriteScene({\r\n            scene,\r\n            issuesFound: issues,\r\n            readerContext,\r\n            previousScenes,\r\n            preserveElements: options.preserveElements?.get(sceneId) || []\r\n          });\r\n\r\n          if (result.success) {\r\n            progress.results.set(sceneId, result);\r\n          } else {\r\n            progress.errors.set(sceneId, result.error || 'Unknown error');\r\n          }\r\n        } catch (error) {\r\n           \r\n          console.error(`[RewriteOrchestrator] Failed to rewrite scene ${sceneId}:`, error);\r\n          progress.errors.set(sceneId, error instanceof Error ? error.message : 'Unknown error');\r\n        }\r\n\r\n        progress.completedScenes++;\r\n        options.progressCallback?.(progress);\r\n\r\n        // Add small delay between scenes to prevent rate limiting\r\n        if (progress.completedScenes < progress.totalScenes) {\r\n          await this.delay(500);\r\n        }\r\n      }\r\n\r\n      progress.phase = progress.errors.size > 0 ? 'error' : 'complete';\r\n      progress.message = this.generateCompletionMessage(progress);\r\n\r\n    } catch (error) {\r\n       \r\n      console.error('[RewriteOrchestrator] Batch rewrite error:', error);\r\n      progress.phase = 'error';\r\n      progress.message = 'Batch rewrite failed';\r\n    }\r\n\r\n    this.currentBatch = undefined;\r\n    return progress;\r\n  }\r\n\r\n  /**\r\n   * Cancel the current batch operation\r\n   */\r\n  cancelBatch(): void {\r\n    if (this.currentBatch) {\r\n      this.currentBatch.abort();\r\n    }\r\n  }\r\n\r\n  private identifyScenesToRewrite(\r\n    manuscript: { scenes: Scene[] },\r\n    options: BatchRewriteOptions\r\n  ): string[] {\r\n    if (options.sceneIds) {\r\n      return options.sceneIds;\r\n    }\r\n\r\n    // Default: all moved scenes with issues\r\n    return manuscript.scenes\r\n      .filter(scene =>\r\n        scene.hasBeenMoved &&\r\n        !!scene.continuityAnalysis?.issues &&\r\n        scene.continuityAnalysis.issues.length > 0\r\n      )\r\n      .map(scene => scene.id);\r\n  }\r\n\r\n  private orderByDependency(\r\n    sceneIds: string[],\r\n    currentOrder: string[]\r\n  ): string[] {\r\n    // Process scenes in their current narrative order\r\n    // This ensures reader context builds correctly\r\n    return sceneIds.sort((a, b) => {\r\n      const aIndex = currentOrder.indexOf(a);\r\n      const bIndex = currentOrder.indexOf(b);\r\n      return aIndex - bIndex;\r\n    });\r\n  }\r\n\r\n  private buildReaderContext(\r\n    manuscript: { scenes: Scene[]; currentOrder: string[] },\r\n    sceneId: string,\r\n    rewrittenScenes: Map<string, RewriteResult>\r\n  ): ReaderKnowledge {\r\n    const context: ReaderKnowledge = {\r\n      knownCharacters: new Set<string>(),\r\n      establishedTimeline: [],\r\n      revealedPlotPoints: [],\r\n      establishedSettings: []\r\n    };\r\n\r\n    const sceneIndex = manuscript.currentOrder.indexOf(sceneId);\r\n    if (sceneIndex <= 0) return context;\r\n\r\n    // Include all scenes before this one\r\n    for (let i = 0; i < sceneIndex; i++) {\r\n      const prevSceneId = manuscript.currentOrder[i];\r\n      const prevScene = manuscript.scenes.find(s => s.id === prevSceneId);\r\n      if (!prevScene) continue;\r\n\r\n      // Use rewritten version if available\r\n      const rewritten = rewrittenScenes.get(prevSceneId);\r\n      if (rewritten && rewritten.rewrittenText) {\r\n        // For now, use original metadata; could extract from rewritten text later\r\n        prevScene.characters?.forEach(char => context.knownCharacters.add(char));\r\n      } else {\r\n        prevScene.characters?.forEach(char => context.knownCharacters.add(char));\r\n        prevScene.timeMarkers?.forEach(marker => {\r\n          context.establishedTimeline.push({ label: marker });\r\n        });\r\n        prevScene.locationMarkers?.forEach(loc => {\r\n          context.establishedSettings.push({ name: loc });\r\n        });\r\n      }\r\n    }\r\n\r\n    return context;\r\n  }\r\n\r\n  private getPreviousScenes(\r\n    manuscript: { scenes: Scene[]; currentOrder: string[] },\r\n    sceneId: string,\r\n    rewrittenScenes: Map<string, RewriteResult>\r\n  ): Scene[] {\r\n    const sceneIndex = manuscript.currentOrder.indexOf(sceneId);\r\n    if (sceneIndex <= 0) return [];\r\n\r\n    // Get last 3 scenes before this one\r\n    const startIndex = Math.max(0, sceneIndex - 3);\r\n    const previousScenes: Scene[] = [];\r\n\r\n    for (let i = startIndex; i < sceneIndex; i++) {\r\n      const prevSceneId = manuscript.currentOrder[i];\r\n      const prevScene = manuscript.scenes.find(s => s.id === prevSceneId);\r\n      if (!prevScene) continue;\r\n\r\n      // Use rewritten version if available\r\n      const rewritten = rewrittenScenes.get(prevSceneId);\r\n      if (rewritten && rewritten.rewrittenText) {\r\n        previousScenes.push({\r\n          ...prevScene,\r\n          text: rewritten.rewrittenText,\r\n          currentRewrite: rewritten.rewrittenText\r\n        });\r\n      } else {\r\n        previousScenes.push(prevScene);\r\n      }\r\n    }\r\n\r\n    return previousScenes;\r\n  }\r\n\r\n  private getSceneTitle(scene: Scene): string {\r\n    // Try to extract a title from the scene\r\n    const firstLine = (scene.text || '').split('\\n')[0];\r\n    if (firstLine && firstLine.length < 100) {\r\n      return firstLine;\r\n    }\r\n    return `Scene ${scene.position + 1}`;\r\n  }\r\n\r\n  private generateCompletionMessage(progress: BatchRewriteProgress): string {\r\n    const successful = progress.completedScenes - progress.errors.size;\r\n\r\n    if (progress.errors.size === 0) {\r\n      return `Successfully rewrote ${successful} scene${successful !== 1 ? 's' : ''}`;\r\n    } else if (successful === 0) {\r\n      return `Failed to rewrite ${progress.errors.size} scene${progress.errors.size !== 1 ? 's' : ''}`;\r\n    } else {\r\n      return `Rewrote ${successful} scene${successful !== 1 ? 's' : ''}, ${progress.errors.size} failed`;\r\n    }\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}\r\n\r\nexport default RewriteOrchestrator;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\SceneRewriter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3371,3374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3371,3374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3685,3688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3685,3688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3732,3735],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3732,3735],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5105,5108],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5105,5108],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7191,7194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7191,7194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7495,7498],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7495,7498],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/services/rewrite/SceneRewriter.ts\r\n\r\n/**\r\n * Phase 3.1  SceneRewriter\r\n * Vision Compliance:\r\n * - Single rewrite only (no alternatives, no ranking)\r\n * - Fix ONLY identified issues; no optimization or stylistic \"improvements\"\r\n * - Preserve author's voice and story elements not tied to the issues\r\n */\r\n\r\nimport AIServiceManager from '../ai/AIServiceManager';\r\nimport type {\r\n  Scene,\r\n  ContinuityIssue,\r\n  ReaderKnowledge,\r\n} from '../../shared/types';\r\nimport type { AnalysisRequest , AnalysisRequestExtension } from '../ai/types';\r\n\r\nimport { enrichAnalysisRequest, runRewriteWithOptionalConsensus } from '../ai/consensus/ConsensusAdapter';\r\n\r\nexport interface RewriteRequest {\r\n  scene: Scene;\r\n  issuesFound: ContinuityIssue[];        // Issues from Phase 2 analysis\r\n  readerContext: ReaderKnowledge;        // What the reader knows at new position\r\n  previousScenes: Scene[];               // For context (max 3 scenes)\r\n  preserveElements: string[];            // Elements that MUST stay unchanged\r\n}\r\n\r\nexport interface RewriteResult {\r\n  success: boolean;\r\n  rewrittenText?: string;\r\n  issuesAddressed: ContinuityIssue[];    // Which issues were actually fixed\r\n  changesExplanation: string;            // Human-readable explanation\r\n  preservedElements: string[];           // What was kept intact\r\n  diffData: DiffSegment[];               // For UI display (basic placeholder for 3.1)\r\n  error?: string;\r\n  modelUsed?: string;\r\n}\r\n\r\nexport interface DiffSegment {\r\n  type: 'added' | 'removed' | 'unchanged';\r\n  text: string;\r\n  reason?: string;                       // Links to specific issue\r\n  issueId?: string;                      // References ContinuityIssue\r\n}\r\n\r\nclass SceneRewriter {\r\n  private aiManager: AIServiceManager;\r\n\r\n  // Retry handling\r\n  private retryCount = new Map<string, number>();\r\n  private maxRetries = 3;\r\n\r\n  constructor(aiManager?: AIServiceManager) {\r\n    // Use provided manager or create new instance\r\n    this.aiManager = aiManager || new AIServiceManager();\r\n  }\r\n\r\n  async rewriteScene(request: RewriteRequest): Promise<RewriteResult> {\r\n    try {\r\n      // Validate request\r\n      if (!request?.scene || !request.issuesFound || request.issuesFound.length === 0) {\r\n        return {\r\n          success: false,\r\n          issuesAddressed: [],\r\n          changesExplanation: 'No issues to fix',\r\n          preservedElements: [],\r\n          diffData: [],\r\n          error: 'Invalid request: no scene or issues provided',\r\n        };\r\n      }\r\n\r\n      // Build prompt based on issue types (strict: fix issues only)\r\n      const prompt = this.buildRewritePrompt(request);\r\n\r\n      // Select model based on complexity\r\n      const analysisType = this.determineAnalysisType(request.issuesFound);\r\n\r\n      // Create analysis request for AIServiceManager (intersection with extension)\r\n      const baseRequest: AnalysisRequest & AnalysisRequestExtension = {\r\n        scene: request.scene,\r\n        previousScenes: request.previousScenes.slice(-3), // Limit context\r\n        analysisType,\r\n        readerContext: request.readerContext,\r\n        customPrompt: prompt,\r\n        isRewriteRequest: true,\r\n        preserveElements: request.preserveElements,\r\n      };\r\n\r\n      // Enrich request locally with stable taskType and meta; preserve PromptCache identity\r\n      const enriched = enrichAnalysisRequest(baseRequest as any, {\r\n        scene: request.scene,\r\n        detectorType: 'continuity_rewrite',\r\n        flags: { critical: this.isCriticalRewrite(request) },\r\n      });\r\n\r\n      // Run single model or consensus depending on criticality\r\n      const response = await runRewriteWithOptionalConsensus(this.aiManager, enriched as any, {\r\n        critical: Boolean((enriched as any)?.flags?.critical),\r\n        consensusCount: 2,\r\n        acceptThreshold: 0.5,\r\n        humanReviewThreshold: 0.9,\r\n        maxModels: 2,\r\n      });\r\n\r\n      // Parse and structure the response\r\n      return this.parseRewriteResponse(\r\n        response,\r\n        request.scene.text || '',\r\n        request.issuesFound\r\n      );\r\n\r\n    } catch (error) {\r\n      // Ensure original text is not lost; fail safely with structured error\r\n       \r\n      console.error('[SceneRewriter] Rewrite failed:', error);\r\n      return {\r\n        success: false,\r\n        issuesAddressed: [],\r\n        changesExplanation: 'Rewrite generation failed',\r\n        preservedElements: [],\r\n        diffData: [],\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      };\r\n    }\r\n  }\r\n\r\n  private buildRewritePrompt(request: RewriteRequest): string {\r\n    // Build a focused prompt that:\r\n    // 1. Lists specific issues to fix\r\n    // 2. Provides reader context\r\n    // 3. Specifies preservation constraints\r\n    // 4. Requests structured output (single rewrite only)\r\n\r\n    const issuesList = request.issuesFound\r\n      .map((i) => `- ${i.type}: ${i.description}`)\r\n      .join('\\n');\r\n\r\n    const knownChars = Array.from(request.readerContext.knownCharacters || []).join(', ');\r\n    const timeline = (request.readerContext.establishedTimeline || [])\r\n      .map((t: any) => t?.label)\r\n      .filter(Boolean)\r\n      .join(', ');\r\n    const plotPoints = (request.readerContext.revealedPlotPoints || []).join(', ');\r\n\r\n    const preserveList =\r\n      request.preserveElements && request.preserveElements.length > 0\r\n        ? `Preserve these elements exactly:\\n${request.preserveElements.join('\\n')}`\r\n        : '';\r\n\r\n    return `Rewrite this scene to fix continuity issues for its new position.\r\n\r\nCURRENT SCENE TEXT:\r\n${request.scene.text}\r\n\r\nISSUES TO FIX:\r\n${issuesList}\r\n\r\nREADER CONTEXT AT NEW POSITION:\r\n- Known characters: ${knownChars}\r\n- Established timeline: ${timeline}\r\n- Revealed plot points: ${plotPoints}\r\n\r\n${preserveList}\r\n\r\nSTRICT REQUIREMENTS:\r\n1. Fix ONLY the identified issues listed above.\r\n2. Preserve the author's voice and style.\r\n3. Keep all story elements not related to the issues.\r\n4. Make the minimal changes necessary.\r\n5. Return ONLY the rewritten scene text (no commentary, no lists, no alternatives).\r\n\r\nHard constraints:\r\n- Do NOT add new plot elements.\r\n- Do NOT optimize the prose beyond what is strictly required to fix the issues.\r\n- Do NOT rank or compare options.\r\n- Produce ONE rewrite only.`;\r\n  }\r\n\r\n  private determineAnalysisType(issues: ContinuityIssue[]): AnalysisRequest['analysisType'] {\r\n    // Route to appropriate model based on issue complexity\r\n    const hasMustFix = issues.some((i) => i.severity === 'must-fix');\r\n    const hasComplexIssues = issues.some((i) => i.type === 'character' || i.type === 'plot');\r\n\r\n    if (hasMustFix && hasComplexIssues) {\r\n      return 'complex';      // e.g., high-capability model\r\n    } else if (hasComplexIssues) {\r\n      return 'consistency';  // e.g., mid-capability model\r\n    } else {\r\n      return 'simple';       // e.g., cost-effective model\r\n    }\r\n  }\r\n\r\n  // Local heuristic to decide if rewrite should use consensus\r\n  // - Explicit scene flag: (scene as any).critical === true\r\n  // - Or multiple must-fix issues\r\n  // - Or dependencies across >= 2 previous scenes\r\n  private isCriticalRewrite(req: RewriteRequest): boolean {\r\n    if ((req.scene as any)?.critical === true) return true;\r\n    const mustFixCount = req.issuesFound.filter(i => i.severity === 'must-fix').length;\r\n    if (mustFixCount >= 2) return true;\r\n    if ((req.previousScenes?.length ?? 0) >= 2) return true;\r\n    return false;\r\n  }\r\n\r\n  private parseRewriteResponse(\r\n    response: any,\r\n    originalText: string,\r\n    issues: ContinuityIssue[]\r\n  ): RewriteResult {\r\n    // Parse AI response and create structured result (defensive)\r\n    const rewrittenText: string =\r\n      response?.rewrittenText ??\r\n      response?.content?.[0]?.text ??\r\n      response?.text ??\r\n      '';\r\n\r\n    if (!rewrittenText || typeof rewrittenText !== 'string') {\r\n      return {\r\n        success: false,\r\n        issuesAddressed: [],\r\n        changesExplanation: 'No rewrite generated',\r\n        preservedElements: [],\r\n        diffData: [],\r\n        error: 'AI response did not contain rewritten text',\r\n      };\r\n    }\r\n\r\n    // Generate diff data (placeholder for Phase 3.1  see DiffEngine in Task 5)\r\n    const diffData = this.generateBasicDiff(originalText, rewrittenText);\r\n\r\n    return {\r\n      success: true,\r\n      rewrittenText,\r\n      issuesAddressed: issues, // Assume all addressed for Phase 3.1; refine later\r\n      changesExplanation: this.generateExplanation(issues),\r\n      preservedElements: [], // Preservation detection to be added in later phases\r\n      diffData,\r\n      modelUsed: response?.modelUsed || response?.meta?.model || 'unknown',\r\n    };\r\n  }\r\n\r\n  private generateBasicDiff(original: string, rewritten: string): DiffSegment[] {\r\n    // Placeholder  minimal diff to satisfy Phase 3.1 requirements.\r\n    if (original === rewritten) {\r\n      return [\r\n        {\r\n          type: 'unchanged',\r\n          text: rewritten,\r\n          reason: 'No changes detected',\r\n        },\r\n      ];\r\n    }\r\n\r\n    // Show single \"unchanged\" placeholder segment to avoid implying ranking/alternatives.\r\n    return [\r\n      {\r\n        type: 'unchanged',\r\n        text: rewritten,\r\n        reason: 'Full diff pending DiffEngine implementation in Task 5',\r\n      },\r\n    ];\r\n  }\r\n\r\n  private generateExplanation(issues: ContinuityIssue[]): string {\r\n    const fixes = issues.map((i) => {\r\n      switch (i.type) {\r\n        case 'pronoun':\r\n          return 'Clarified pronoun references';\r\n        case 'character':\r\n          return 'Added/clarified character context appropriate to new position';\r\n        case 'timeline':\r\n          return 'Adjusted temporal markers for continuity';\r\n        case 'plot':\r\n          return 'Inserted necessary plot context revealed in prior scenes';\r\n        case 'engagement':\r\n          return 'Adjusted opening lines to maintain engagement after reorder';\r\n        default:\r\n          return `Addressed ${i.type} continuity issue`;\r\n      }\r\n    });\r\n\r\n    // Join with semicolons to form a single human-readable sentence\r\n    return fixes.join('; ');\r\n  }\r\nasync rewriteSceneWithRetry(request: RewriteRequest): Promise<RewriteResult> {\r\n    const sceneId = request.scene.id;\r\n    let lastError: Error | null = null;\r\n  \r\n    for (let attempt = 0; attempt < this.maxRetries; attempt++) {\r\n      try {\r\n        // Clear any previous errors\r\n        lastError = null;\r\n        \r\n        // Exponential backoff\r\n        if (attempt > 0) {\r\n          const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\r\n          await this.delay(delay);\r\n        }\r\n        \r\n        // Attempt rewrite\r\n        const result = await this.rewriteScene(request);\r\n        \r\n        if (result.success) {\r\n          this.retryCount.delete(sceneId);\r\n          return result;\r\n        }\r\n        \r\n        // If not successful but no error, don't retry\r\n        if (!result.error || result.error.includes('No issues')) {\r\n          return result;\r\n        }\r\n        \r\n        lastError = new Error(result.error);\r\n\r\n        if (!this.isRetryableError(lastError)) {\r\n          break;\r\n        }\r\n      } catch (error) {\r\n        console.warn(`[SceneRewriter] Attempt ${attempt + 1} failed:`, error);\r\n        lastError = error instanceof Error ? error : new Error('Unknown error');\r\n        \r\n        // Check if error is retryable\r\n        if (!this.isRetryableError(lastError)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // All retries exhausted\r\n    return {\r\n      success: false,\r\n      issuesAddressed: [],\r\n      changesExplanation: '',\r\n      preservedElements: [],\r\n      diffData: [],\r\n      error: `Failed after ${this.maxRetries} attempts: ${lastError?.message || 'Unknown error'}`\r\n    };\r\n  }\r\n\r\n  private isRetryableError(error: Error): boolean {\r\n    const message = error.message.toLowerCase();\r\n    \r\n    // Don't retry on these errors\r\n    const nonRetryable = [\r\n      'invalid api key',\r\n      'no issues',\r\n      'invalid request',\r\n      'scene not found'\r\n    ];\r\n    \r\n    return !nonRetryable.some(phrase => message.includes(phrase));\r\n  }\r\n\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}\r\n  \r\nexport default SceneRewriter;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\DiffEngine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\PerformanceOptimizer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\RewriteConsensusIntegration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2007,2010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2007,2010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2066,2069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2066,2069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2365,2368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2365,2368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2555,2558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2555,2558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2571,2574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2571,2574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2932,2935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2932,2935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2989,2992],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2989,2992],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3390,3393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3390,3393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3965,3968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3965,3968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4022,4025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4022,4025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4043,4046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4043,4046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4570,4573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4570,4573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4585,4588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4585,4588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4765,4768],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4765,4768],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../shared/types';\r\nimport SceneRewriter from '../SceneRewriter';\r\nimport { ValidationPipeline } from '../../ai/validation/ValidationPipeline';\r\nimport AIServiceManager from '../../ai/AIServiceManager';\r\n\r\ntype AnalyzeReq = Parameters<AIServiceManager['analyzeContinuity']>[0];\r\n\r\nfunction buildScene(overrides?: Partial<Scene>): Scene {\r\n  const base: Scene = {\r\n    id: 's-rewrite',\r\n    text: 'Opening text. The incident will be clarified.',\r\n    wordCount: 8,\r\n    position: 5,\r\n    originalPosition: 2,\r\n    characters: ['Alice'],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: true,\r\n    rewriteStatus: 'pending',\r\n  };\r\n  return { ...base, ...(overrides ?? {}) } as Scene;\r\n}\r\n\r\nfunction buildIssues(n = 1): ContinuityIssue[] {\r\n  return Array.from({ length: n }).map((_, i) => ({\r\n    type: (i % 2 === 0 ? 'plot' : 'character') as ContinuityIssue['type'],\r\n    severity: i === 0 ? 'must-fix' : 'should-fix',\r\n    description: `issue-${i}`,\r\n    textSpan: [0, 5],\r\n  }));\r\n}\r\n\r\nfunction buildReaderCtx(): ReaderKnowledge {\r\n  return {\r\n    knownCharacters: new Set(['Alice']),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: [],\r\n  };\r\n}\r\n\r\nfunction buildPrevScenes(n = 2): Scene[] {\r\n  return Array.from({ length: n }).map((_, i) => ({\r\n    id: `prev-${i}`,\r\n    text: `Previous scene ${i} content.`,\r\n    wordCount: 3,\r\n    position: i,\r\n    originalPosition: i,\r\n    characters: ['Alice'],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending',\r\n  })) as Scene[];\r\n}\r\n\r\nfunction makeManagerStub(recorded: AnalyzeReq[], returnsText = (id: string) => `rewrite-from-${id}`) {\r\n  const stub: Pick<AIServiceManager, 'analyzeContinuity'> = {\r\n    analyzeContinuity: vi.fn(async (req: AnalyzeReq) => {\r\n      recorded.push(req);\r\n      const text =\r\n        (req as any)?.customPrompt\r\n          ? returnsText(String((req as any).__modelId ?? 'primary'))\r\n          : returnsText('noprompt');\r\n      // Simulate provider response that SceneRewriter.parseRewriteResponse tolerates\r\n      return {\r\n        issues: [],\r\n        text, // parseRewriteResponse reads from .text\r\n        metadata: {\r\n          modelUsed: (req as any).__modelId ?? 'mock',\r\n          provider: 'openai',\r\n          costEstimate: 0,\r\n          durationMs: 1,\r\n          confidence: 0.65,\r\n          cached: false,\r\n        },\r\n      } as any;\r\n    }) as any,\r\n  };\r\n  return stub as AIServiceManager;\r\n}\r\n\r\ndescribe('Rewrite consensus adapter integration', () => {\r\n  beforeEach(() => {\r\n    vi.restoreAllMocks();\r\n  });\r\n\r\n  it('single-model path when not critical', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls);\r\n    const rewriter = new SceneRewriter(manager as any);\r\n\r\n    const scene = buildScene({ position: 9 } as any); // no critical flag\r\n    const res = await rewriter.rewriteScene({\r\n      scene,\r\n      issuesFound: buildIssues(1),\r\n      readerContext: buildReaderCtx(),\r\n      previousScenes: buildPrevScenes(1),\r\n      preserveElements: [],\r\n    });\r\n\r\n    expect(res.success).toBe(true);\r\n    expect(typeof res.rewrittenText).toBe('string');\r\n    expect(calls.length).toBe(1);\r\n    const req = calls[0] as any;\r\n    // Enriched fields presence\r\n    expect(req.taskType).toBe('continuity_rewrite');\r\n    expect(typeof req.sceneText).toBe('string');\r\n    expect(typeof req.newPosition).toBe('number');\r\n    expect(req.readerContext?.knownCharacters instanceof Set).toBe(true);\r\n    expect(Array.isArray(req.previousScenes)).toBe(true);\r\n  });\r\n\r\n  it('consensus path when critical: executes two runs and reconciles', async () => {\r\n    const calls: AnalyzeReq[] = [];\r\n    const manager = makeManagerStub(calls, (id) => `R-${id}`);\r\n    const rewriter = new SceneRewriter(manager as any);\r\n\r\n    const scene = buildScene({ position: 3 } as any);\r\n    (scene as any).critical = true;\r\n\r\n    const spyRecon = vi.spyOn(ValidationPipeline, 'reconcile');\r\n\r\n    const res = await rewriter.rewriteScene({\r\n      scene,\r\n      issuesFound: buildIssues(2), // multiple issues implies complexity as well\r\n      readerContext: buildReaderCtx(),\r\n      previousScenes: buildPrevScenes(2),\r\n      preserveElements: ['keep this sentence intact'],\r\n    });\r\n\r\n    expect(res.success).toBe(true);\r\n    // Two attempts from consensus\r\n    expect(calls.length).toBe(2);\r\n    const ids = new Set((calls as any[]).map((r: any) => r.__modelId).filter(Boolean));\r\n    expect(ids.size).toBeGreaterThanOrEqual(2);\r\n\r\n    // Enriched AnalysisRequest fields present on each run\r\n    for (const r of calls as any[]) {\r\n      expect(r.taskType).toBe('continuity_rewrite');\r\n      expect(typeof r.sceneText).toBe('string');\r\n      expect(typeof r.newPosition).toBe('number');\r\n    }\r\n\r\n    expect(spyRecon).toHaveBeenCalledTimes(1);\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\RewriteOrchestrator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[560,563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[560,563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport type { Manuscript, Scene, ContinuityIssue, ReaderKnowledge } from '../../../shared/types';\r\n\r\n// Mock SceneRewriter to avoid real AI calls and to capture inputs\r\nconst callOrder: string[] = [];\r\nconst receivedContexts: Array<{ id: string; knownChars: string[] }> = [];\r\nconst deferredResolvers: Record<string, () => void> = {};\r\nlet throwOn: Set<string> = new Set();\r\n\r\nvi.mock('../SceneRewriter', () => {\r\n  return {\r\n    default: class SceneRewriterMock {\r\n      async rewriteScene(req: any) {\r\n        const id = req.scene.id as string;\r\n        callOrder.push(id);\r\n        receivedContexts.push({\r\n          id,\r\n          knownChars: Array.from(req.readerContext?.knownCharacters ?? []),\r\n        });\r\n\r\n        if (throwOn.has(id)) {\r\n          throw new Error(`Simulated failure for ${id}`);\r\n        }\r\n\r\n        // Allow tests to control resolution for cancellation behavior\r\n        if (deferredResolvers[id]) {\r\n          await new Promise<void>((resolve) => {\r\n            const done = () => resolve();\r\n            deferredResolvers[id] = done;\r\n          });\r\n        }\r\n\r\n        return {\r\n          success: true,\r\n          rewrittenText: `rewritten:${id}`,\r\n          issuesAddressed: req.issuesFound ?? [],\r\n          changesExplanation: `changes for ${id}`,\r\n          preservedElements: [],\r\n          diffData: [],\r\n          modelUsed: 'mock-model',\r\n        };\r\n      }\r\n    }\r\n  };\r\n});\r\n\r\nimport RewriteOrchestrator from '../RewriteOrchestrator';\r\n\r\nfunction buildIssue(): ContinuityIssue {\r\n  return {\r\n    type: 'pronoun',\r\n    severity: 'must-fix',\r\n    description: 'Ambiguous pronoun',\r\n    textSpan: [0, 5],\r\n    suggestedFix: 'Clarify subject',\r\n  };\r\n}\r\n\r\nfunction buildScene(id: string, position: number, chars: string[] = []): Scene {\r\n  const rk: ReaderKnowledge = {\r\n    knownCharacters: new Set(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: []\r\n  };\r\n\r\n  return {\r\n    id,\r\n    text: `Text of ${id}`,\r\n    wordCount: 3,\r\n    position,\r\n    originalPosition: position,\r\n    characters: chars,\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: true,\r\n    rewriteStatus: 'pending',\r\n    continuityAnalysis: {\r\n      issues: [buildIssue()],\r\n      timestamp: Date.now(),\r\n      modelUsed: 'test',\r\n      confidence: 0.9,\r\n      readerContext: rk\r\n    }\r\n  };\r\n}\r\n\r\nfunction buildManuscript(scenes: Scene[], currentOrder: string[]): Manuscript {\r\n  return {\r\n    id: 'm1',\r\n    title: 'Test Manuscript',\r\n    scenes,\r\n    originalOrder: scenes.map(s => s.id),\r\n    currentOrder\r\n  };\r\n}\r\n\r\nbeforeEach(() => {\r\n  callOrder.length = 0;\r\n  receivedContexts.length = 0;\r\n  Object.keys(deferredResolvers).forEach(k => delete deferredResolvers[k]);\r\n  throwOn = new Set();\r\n});\r\n\r\ndescribe('RewriteOrchestrator.rewriteMovedScenes()', () => {\r\n  it('processes scenes in dependency (current narrative) order', async () => {\r\n    const sA = buildScene('A', 1);\r\n    const sB = buildScene('B', 0);\r\n    const sC = buildScene('C', 2);\r\n\r\n    // Narrative order is B, A, C\r\n    const manuscript = buildManuscript([sA, sB, sC], ['B', 'A', 'C']);\r\n\r\n    const orchestrator = new RewriteOrchestrator();\r\n    const progress = await orchestrator.rewriteMovedScenes(manuscript, { skipIfNoIssues: false });\r\n\r\n    expect(progress.totalScenes).toBe(3);\r\n    expect(callOrder).toEqual(['B', 'A', 'C']);\r\n    expect(progress.results.size).toBe(3);\r\n    expect(progress.phase === 'complete' || progress.phase === 'error').toBe(true);\r\n  });\r\n\r\n  it('builds reader context progressively from previous scenes', async () => {\r\n    const s1 = buildScene('S1', 0, ['Alice']);\r\n    const s2 = buildScene('S2', 1, ['Bob']);\r\n    const s3 = buildScene('S3', 2, ['Carol']);\r\n\r\n    const manuscript = buildManuscript([s1, s2, s3], ['S1', 'S2', 'S3']);\r\n\r\n    const orchestrator = new RewriteOrchestrator();\r\n    await orchestrator.rewriteMovedScenes(manuscript, { skipIfNoIssues: false });\r\n\r\n    // Find the record for S2 and S3 calls\r\n    const recS2 = receivedContexts.find(r => r.id === 'S2');\r\n    const recS3 = receivedContexts.find(r => r.id === 'S3');\r\n\r\n    expect(recS2).toBeTruthy();\r\n    expect(recS2?.knownChars).toContain('Alice');\r\n\r\n    expect(recS3).toBeTruthy();\r\n    // By S3, both Alice and Bob should be in known context\r\n    expect(recS3?.knownChars).toEqual(expect.arrayContaining(['Alice', 'Bob']));\r\n  });\r\n\r\n  it('continues batch when a single scene rewrite fails', async () => {\r\n    const s1 = buildScene('S1', 0);\r\n    const s2 = buildScene('S2', 1);\r\n    const s3 = buildScene('S3', 2);\r\n\r\n    const manuscript = buildManuscript([s1, s2, s3], ['S1', 'S2', 'S3']);\r\n\r\n    // Make S2 fail\r\n    throwOn.add('S2');\r\n\r\n    const orchestrator = new RewriteOrchestrator();\r\n    const progress = await orchestrator.rewriteMovedScenes(manuscript, { skipIfNoIssues: false });\r\n\r\n    expect(progress.errors.size).toBe(1);\r\n    expect(progress.errors.get('S2')).toBeTruthy();\r\n    expect(progress.results.size).toBe(2); // S1 and S3 succeeded\r\n  });\r\n\r\n  it('cancellation stops further processing after current scene', async () => {\r\n    const s1 = buildScene('S1', 0);\r\n    const s2 = buildScene('S2', 1);\r\n    const s3 = buildScene('S3', 2);\r\n\r\n    const manuscript = buildManuscript([s1, s2, s3], ['S1', 'S2', 'S3']);\r\n\r\n    // Make first call deferred so we can cancel while it's running\r\n    deferredResolvers['S1'] = () => {};\r\n\r\n    const orchestrator = new RewriteOrchestrator();\r\n    const runPromise = orchestrator.rewriteMovedScenes(manuscript, { skipIfNoIssues: false });\r\n\r\n    // Cancel while first scene is in-flight\r\n    orchestrator.cancelBatch();\r\n\r\n    // Resolve the first scene now\r\n    // Call the stored resolver for S1\r\n    // Note: our mock stores a new resolver when invoked; we need to trigger it.\r\n    // Because we replace it inside the promise constructor, access it via key:\r\n    const resolverKeys = Object.keys(deferredResolvers);\r\n    if (resolverKeys.includes('S1')) {\r\n      // Invoke resolver to allow first scene to complete\r\n      deferredResolvers['S1']();\r\n      delete deferredResolvers['S1'];\r\n    }\r\n\r\n    const progress = await runPromise;\r\n\r\n    // Should have processed only S1 due to cancellation before starting S2\r\n    expect(callOrder).toEqual(['S1']);\r\n    // Phase may be 'error' due to our finalize rule, but primary check is count\r\n    expect(progress.completedScenes).toBeGreaterThanOrEqual(1);\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\SceneRewriter.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[392,395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[392,395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[541,544],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[541,544],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1145,1148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1145,1148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2514,2517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2514,2517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3104,3107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3104,3107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3645,3648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3645,3648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":98,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":101,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3881,3884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3881,3884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4336,4339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4336,4339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":98,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":101,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4763,4766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4763,4766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\r\nimport SceneRewriter from '../../rewrite/SceneRewriter';\r\nimport type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../shared/types';\r\n\r\ndescribe('SceneRewriter', () => {\r\n  const baseScene: Scene = {\r\n    id: 's1',\r\n    text: 'Alice walks into the room. She sees Bob.',\r\n    // optional fields tolerated; leave undefined\r\n  } as any;\r\n\r\n  const issues: ContinuityIssue[] = [\r\n    { id: 'i1', type: 'pronoun', severity: 'should-fix', description: 'Ambiguous \"She\" pronoun.' } as any,\r\n  ];\r\n\r\n  const readerContext: ReaderKnowledge = {\r\n    knownCharacters: new Set(['Alice', 'Bob']),\r\n    establishedTimeline: [{ label: 'Morning' }],\r\n    revealedPlotPoints: ['Alice met Bob previously'],\r\n    establishedSettings: [{ name: 'Apartment' }],\r\n  };\r\n\r\n  it('generates exactly one rewrite and returns structured result', async () => {\r\n    const mockAI = {\r\n      analyzeContinuity: vi.fn().mockResolvedValue({\r\n        rewrittenText: 'Alice walks into the room. Alice sees Bob.',\r\n        modelUsed: 'mock-model',\r\n      }),\r\n    };\r\n\r\n    const rewriter = new SceneRewriter(mockAI as any);\r\n\r\n    const result = await rewriter.rewriteScene({\r\n      scene: baseScene,\r\n      issuesFound: issues,\r\n      readerContext,\r\n      previousScenes: [],\r\n      preserveElements: [],\r\n    });\r\n\r\n    expect(mockAI.analyzeContinuity).toHaveBeenCalledTimes(1);\r\n    const callArg = mockAI.analyzeContinuity.mock.calls[0][0];\r\n    expect(callArg).toMatchObject({\r\n      scene: baseScene,\r\n      previousScenes: [],\r\n      readerContext,\r\n      customPrompt: expect.any(String),\r\n      isRewriteRequest: true,\r\n      preserveElements: [],\r\n    });\r\n\r\n    expect(result.success).toBe(true);\r\n    expect(typeof result.rewrittenText).toBe('string');\r\n    expect(result.rewrittenText).toContain('Alice sees Bob'); // pronoun clarified\r\n    expect(Array.isArray(result.issuesAddressed)).toBe(true);\r\n    expect(typeof result.changesExplanation).toBe('string');\r\n    expect(Array.isArray(result.diffData)).toBe(true);\r\n    expect(result.modelUsed).toBe('mock-model');\r\n  });\r\n\r\n  it('does not mutate original scene text (original text is never lost)', async () => {\r\n    const mockAI = {\r\n      analyzeContinuity: vi.fn().mockResolvedValue({\r\n        rewrittenText: 'Alice walks into the room. Alice sees Bob.',\r\n      }),\r\n    };\r\n    const sceneCopy = { ...baseScene, text: 'Alice walks into the room. She sees Bob.' };\r\n\r\n    const rewriter = new SceneRewriter(mockAI as any);\r\n    const result = await rewriter.rewriteScene({\r\n      scene: sceneCopy,\r\n      issuesFound: issues,\r\n      readerContext,\r\n      previousScenes: [],\r\n      preserveElements: [],\r\n    });\r\n\r\n    expect(sceneCopy.text).toBe('Alice walks into the room. She sees Bob.');\r\n    expect(result.success).toBe(true);\r\n    expect(result.rewrittenText).toBe('Alice walks into the room. Alice sees Bob.');\r\n  });\r\n\r\n  it('fails gracefully when no issues provided', async () => {\r\n    const mockAI = {\r\n      analyzeContinuity: vi.fn(),\r\n    };\r\n    const rewriter = new SceneRewriter(mockAI as any);\r\n\r\n    const result = await rewriter.rewriteScene({\r\n      scene: baseScene,\r\n      issuesFound: [],\r\n      readerContext,\r\n      previousScenes: [],\r\n      preserveElements: [],\r\n    });\r\n\r\n    expect(result.success).toBe(false);\r\n    expect(result.error).toContain('Invalid request');\r\n  });\r\n\r\n  it('routes analysis type based on issues complexity', async () => {\r\n    const mockAI = {\r\n      analyzeContinuity: vi.fn().mockResolvedValue({ rewrittenText: baseScene.text }),\r\n    };\r\n    const rewriter = new SceneRewriter(mockAI as any);\r\n\r\n    // complex path: must-fix + character/plot\r\n    await rewriter.rewriteScene({\r\n      scene: baseScene,\r\n      issuesFound: [\r\n        { id: 'i2', type: 'plot', severity: 'must-fix', description: 'Missing plot context' } as any,\r\n      ],\r\n      readerContext,\r\n      previousScenes: [],\r\n      preserveElements: [],\r\n    });\r\n    let arg = mockAI.analyzeContinuity.mock.calls.at(-1)[0];\r\n    expect(arg.analysisType).toBe('complex');\r\n\r\n    // consistency path: character/plot without must-fix\r\n    await rewriter.rewriteScene({\r\n      scene: baseScene,\r\n      issuesFound: [\r\n        { id: 'i3', type: 'character', severity: 'should-fix', description: 'Character context' } as any,\r\n      ],\r\n      readerContext,\r\n      previousScenes: [],\r\n      preserveElements: [],\r\n    });\r\n    arg = mockAI.analyzeContinuity.mock.calls.at(-1)[0];\r\n    expect(arg.analysisType).toBe('consistency');\r\n\r\n    // simple path: pronoun only\r\n    await rewriter.rewriteScene({\r\n      scene: baseScene,\r\n      issuesFound: [\r\n        { id: 'i4', type: 'pronoun', severity: 'should-fix', description: 'Pronoun clarity' } as any,\r\n      ],\r\n      readerContext,\r\n      previousScenes: [],\r\n      preserveElements: [],\r\n    });\r\n    arg = mockAI.analyzeContinuity.mock.calls.at(-1)[0];\r\n    expect(arg.analysisType).toBe('simple');\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\services\\rewrite\\__tests__\\SceneRewriterRetry.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[609,612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[609,612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[781,784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[781,784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1576,1579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1576,1579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1644,1647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1644,1647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1713,1716],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1713,1716],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1829,1832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1829,1832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2415,2418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2415,2418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2439,2442],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2439,2442],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2508,2511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2508,2511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2624,2627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2624,2627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\r\nimport SceneRewriter from '../SceneRewriter';\r\nimport type { Scene, ContinuityIssue, ReaderKnowledge } from '../../../shared/types';\r\n\r\nfunction makeRequest(overrides: Partial<{\r\n  scene: Scene;\r\n  issues: ContinuityIssue[];\r\n  reader: ReaderKnowledge;\r\n}> = {}) {\r\n  const scene: Scene = overrides.scene || ({\r\n    id: 's1',\r\n    text: 'Original scene text.',\r\n    wordCount: 3,\r\n    position: 0,\r\n    originalPosition: 0,\r\n    characters: [],\r\n    timeMarkers: [],\r\n    locationMarkers: [],\r\n    hasBeenMoved: false,\r\n    rewriteStatus: 'pending'\r\n  } as any);\r\n\r\n  const issues: ContinuityIssue[] = overrides.issues || ([\r\n    { type: 'pronoun', severity: 'should-fix', description: 'Pronoun ambiguity', textSpan: [0, 7] } as any\r\n  ]);\r\n\r\n  const reader: ReaderKnowledge = overrides.reader || {\r\n    knownCharacters: new Set<string>(),\r\n    establishedTimeline: [],\r\n    revealedPlotPoints: [],\r\n    establishedSettings: []\r\n  };\r\n\r\n  return { scene, issues, reader };\r\n}\r\n\r\ndescribe('SceneRewriter retry/backoff', () => {\r\n  it('retries on failure and succeeds on subsequent attempt', async () => {\r\n    const mockAI = {\r\n      analyzeContinuity: vi\r\n        .fn()\r\n        // First attempt: simulate transport error path (rewriteScene catches and returns failure)\r\n        .mockRejectedValueOnce(new Error('network failure'))\r\n        // Second attempt: success\r\n        .mockResolvedValueOnce({ rewrittenText: 'Rewritten successfully', modelUsed: 'mock' })\r\n    };\r\n\r\n    const rewriter = new SceneRewriter(mockAI as any);\r\n    // Remove actual delays for test speed\r\n    (rewriter as any).delay = vi.fn().mockResolvedValue(undefined);\r\n    (rewriter as any).maxRetries = 3;\r\n\r\n    const { scene, issues, reader } = makeRequest();\r\n    const result = await (rewriter as any).rewriteSceneWithRetry({\r\n      scene,\r\n      issuesFound: issues,\r\n      readerContext: reader,\r\n      previousScenes: [],\r\n      preserveElements: []\r\n    });\r\n\r\n    expect(mockAI.analyzeContinuity).toHaveBeenCalledTimes(2);\r\n    expect(result.success).toBe(true);\r\n    expect(result.rewrittenText).toBe('Rewritten successfully');\r\n  });\r\n\r\n  it('fails fast on non-retryable errors (invalid api key)', async () => {\r\n    const mockAI = {\r\n      analyzeContinuity: vi.fn().mockRejectedValue(new Error('Invalid API key'))\r\n    };\r\n\r\n    const rewriter = new SceneRewriter(mockAI as any);\r\n    (rewriter as any).delay = vi.fn().mockResolvedValue(undefined);\r\n    (rewriter as any).maxRetries = 5;\r\n\r\n    const { scene, issues, reader } = makeRequest();\r\n    const result = await (rewriter as any).rewriteSceneWithRetry({\r\n      scene,\r\n      issuesFound: issues,\r\n      readerContext: reader,\r\n      previousScenes: [],\r\n      preserveElements: []\r\n    });\r\n\r\n    // Should only attempt once\r\n    expect(mockAI.analyzeContinuity).toHaveBeenCalledTimes(1);\r\n    expect(result.success).toBe(false);\r\n    expect(result.error).toMatch(/Failed after/i);\r\n    expect(result.error).toMatch(/invalid api key/i);\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\shared\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\shared\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\types\\compromise.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[142,145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[142,145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[152,155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[152,155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[181,184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[181,184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[191,194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[191,194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[218,221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[218,221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[228,231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[228,231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[254,257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[254,257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[264,267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[264,267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[287,290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[287,290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* Minimal ambient typing for compromise NLP to satisfy strict TS */\r\ndeclare module 'compromise' {\r\n  type NLPDoc = {\r\n    match?: (...args: any[]) => any;\r\n    people?: (...args: any[]) => any;\r\n    json?: (...args: any[]) => any;\r\n    out?: (...args: any[]) => any;\r\n    [k: string]: any;\r\n  };\r\n\r\n  const nlp: (text?: string) => NLPDoc;\r\n  export default nlp;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\types\\preload.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[458,461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[458,461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[474,477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[474,477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[547,550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[547,550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[688,691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[688,691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[726,729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[726,729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[813,816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[813,816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1165,1168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1165,1168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1183,1186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1183,1186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Manuscript } from '../shared/types';\r\n\r\ndeclare global {\r\n  interface Window {\r\n    electronAPI: {\r\n      // File ops\r\n      loadFile: () => Promise<Manuscript | null>;\r\n      loadSpecificFile: (filePath: string) => Promise<Manuscript | null>;\r\n      autoLoadManuscript: () => Promise<Manuscript | null>;\r\n      saveFile: (manuscript: Manuscript) => Promise<string | null>;\r\n\r\n      // AI provider endpoints\r\n      configureProviders: (config: any) => Promise<any>;\r\n      testProvider: (\r\n        provider: string,\r\n        config: any\r\n      ) => Promise<{ ok: boolean; error?: { message: string; code: string } }>;\r\n\r\n      // Settings\r\n      loadSettings: () => Promise<any>;\r\n      saveSettings: (settings: any) => Promise<{ success: boolean; error?: string }>;\r\n      testConnection: (params: any) => Promise<{ success: boolean; error?: string }>;\r\n\r\n      // Env info\r\n      platform: string;\r\n      versions: {\r\n        node: string;\r\n        chrome: string;\r\n        electron: string;\r\n      };\r\n    };\r\n    // Minimal ipc bridge typing (only what's exposed)\r\n    electron: {\r\n      ipcRenderer: {\r\n        invoke: (channel: string, ...args: any[]) => Promise<any>;\r\n      };\r\n    };\r\n  }\r\n}\r\n\r\nexport {};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\src\\types\\vitest-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vite.main.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vite.preload.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vite.renderer.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\zeke\\Desktop\\Projects\\rewrite-assistant\\vitest.setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]